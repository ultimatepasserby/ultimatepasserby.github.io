<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2025-06-18T15:49:59+08:00</updated><id>http://localhost:4000/blog/feed.xml</id><entry><title type="html">SAP学习笔记</title><link href="http://localhost:4000/blog/sap/2025/06/12/SAP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="SAP学习笔记" /><published>2025-06-12T00:00:00+08:00</published><updated>2025-06-12T00:00:00+08:00</updated><id>http://localhost:4000/blog/sap/2025/06/12/SAP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/sap/2025/06/12/SAP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="sap学习笔记">SAP学习笔记</h1>

<h2 id="一财务会计fi模块">一、财务会计（FI）模块</h2>

<h3 id="11-总分类账general-ledger">1.1 总分类账（General Ledger）</h3>

<h4 id="知识点">知识点</h4>
<ul>
  <li><strong>科目表</strong>：企业财务科目的清单。</li>
  <li><strong>会计凭证</strong>：记录每笔财务交易的凭证。</li>
  <li><strong>过账</strong>：更新总分类账和相关明细账的过程。</li>
</ul>

<h4 id="操作步骤">操作步骤</h4>
<ol>
  <li>创建会计凭证：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">F-02</code>，输入凭证日期、记账日期、凭证类型等信息。</li>
      <li>输入记账码、科目编码、金额及文本说明。</li>
    </ul>
  </li>
  <li>检查与保存凭证：
    <ul>
      <li>核对信息，使用快捷键 <code class="language-plaintext highlighter-rouge">Ctrl + F3</code> 进行检查。</li>
      <li>确认无误后点击保存或按 <code class="language-plaintext highlighter-rouge">F11</code> 键。</li>
    </ul>
  </li>
  <li>过账操作：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">FB00</code>，输入凭证编号执行过账操作。</li>
    </ul>
  </li>
</ol>

<h4 id="案例">案例</h4>
<p>某企业购买办公用品花费 1000 元，以银行存款支付：</p>
<ul>
  <li>记账码 50（贷方）表示银行存款减少。</li>
  <li>记账码 40（借方）表示办公用品费用增加。</li>
  <li>过账后，总分类账中银行存款科目减少 1000 元，办公用品费用科目增加 1000 元。</li>
</ul>

<hr />

<h3 id="12-应收账款accounts-receivable">1.2 应收账款（Accounts Receivable）</h3>

<h4 id="知识点-1">知识点</h4>
<ul>
  <li><strong>客户主数据</strong>：包含客户的基本信息、财务信息、销售信息等。</li>
  <li><strong>发票处理</strong>：创建销售发票后，系统自动生成应收账款分录。</li>
  <li><strong>收款处理</strong>：收到客户款项时，核销相应的应收账款。</li>
  <li><strong>账龄分析</strong>：对应收账款按账龄进行分类分析。</li>
</ul>

<h4 id="操作步骤-1">操作步骤</h4>
<ol>
  <li>维护客户主数据：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">XD02</code>，设置付款条件、信用额度等。</li>
    </ul>
  </li>
  <li>创建销售发票：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">VF01</code>，输入销售订单号生成发票。</li>
    </ul>
  </li>
  <li>收款处理：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">F-28</code>，选择客户编号并核销发票。</li>
    </ul>
  </li>
  <li>账龄分析：
    <ul>
      <li>执行事务代码 <code class="language-plaintext highlighter-rouge">F.05</code>，运行报表分析应收账款分布。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-1">案例</h4>
<p>企业向客户 A 销售产品，金额为 5000 元：</p>
<ul>
  <li>开具销售发票，系统生成会计凭证，借记应收账款 - 客户 A 5000 元，贷记销售收入 5000 元。</li>
  <li>收到客户 A 的付款 5000 元，系统核销该笔应收账款，同时生成会计凭证，借记银行存款 5000 元，贷记应收账款 - 客户 A 5000 元。</li>
</ul>

<hr />

<h3 id="13-应付账款accounts-payable">1.3 应付账款（Accounts Payable）</h3>

<h4 id="知识点-2">知识点</h4>
<ul>
  <li><strong>供应商主数据</strong>：包含供应商的基本信息、财务信息、采购信息等。</li>
  <li><strong>发票校验</strong>：匹配发票信息与采购订单、收货信息。</li>
  <li><strong>付款处理</strong>：根据付款条件和方式生成付款建议。</li>
  <li><strong>争议处理</strong>：解决发票与采购订单或收货信息存在的差异。</li>
</ul>

<h4 id="操作步骤-2">操作步骤</h4>
<ol>
  <li>维护供应商主数据：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">XK02</code>，设置付款条件、付款方式等。</li>
    </ul>
  </li>
  <li>发票校验：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">MIRO</code>，输入供应商编号、发票信息等。</li>
    </ul>
  </li>
  <li>付款处理：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">F110</code>，设置付款参数并运行付款建议。</li>
    </ul>
  </li>
  <li>争议处理：
    <ul>
      <li>若发现差异，通过事务代码 <code class="language-plaintext highlighter-rouge">MB05</code> 分析原因并调整。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-2">案例</h4>
<p>企业向供应商 B 采购原材料，金额为 3000 元：</p>
<ul>
  <li>进行发票校验后，生成会计凭证，借记原材料 3000 元，贷记应付账款 - 供应商 B 3000 元。</li>
  <li>到了付款日，运行付款程序，系统生成付款凭证，借记应付账款 - 供应商 B 3000 元，贷记银行存款 3000 元。</li>
</ul>

<hr />

<h3 id="14-资产会计asset-accounting">1.4 资产会计（Asset Accounting）</h3>

<h4 id="知识点-3">知识点</h4>
<ul>
  <li><strong>资产主数据</strong>：记录固定资产的详细信息。</li>
  <li><strong>资产购置</strong>：记录资产的购置成本。</li>
  <li><strong>折旧计算</strong>：系统自动计算每月或每年的折旧金额。</li>
  <li><strong>资产转移</strong>：当资产在企业内部不同部门或地点之间转移时。</li>
  <li><strong>资产报废</strong>：核销资产价值并记录相关损益。</li>
</ul>

<h4 id="操作步骤-3">操作步骤</h4>
<ol>
  <li>创建资产主数据：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">AS01</code>，输入资产类别、资产编号等信息。</li>
    </ul>
  </li>
  <li>资产购置：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">F-90</code>，输入资产编号、供应商编号等。</li>
    </ul>
  </li>
  <li>折旧计算与过账：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">AFAB</code> 运行折旧计算程序。</li>
    </ul>
  </li>
  <li>资产转移：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">ABUMN</code>，输入原资产编号、目标资产编号等。</li>
    </ul>
  </li>
  <li>资产报废：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">ABAVN</code>，输入资产编号、报废原因等。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-3">案例</h4>
<p>企业购置一台设备，价值 100000 元，使用年限为 10 年：</p>
<ul>
  <li>创建资产主数据，录入相关信息。</li>
  <li>进行资产购置操作，生成会计凭证，借记固定资产 - 设备 100000 元，贷记银行存款 100000 元。</li>
  <li>每月系统自动计算折旧金额为 833.33 元，生成折旧会计凭证，借记管理费用 - 折旧费 833.33 元，贷记累计折旧 - 设备 833.33 元。</li>
</ul>

<hr />

<h2 id="二物料管理mm模块">二、物料管理（MM）模块</h2>

<h3 id="21-物料主数据material-master-data">2.1 物料主数据（Material Master Data）</h3>

<h4 id="知识点-4">知识点</h4>
<ul>
  <li><strong>基本数据视图</strong>：记录物料的通用信息。</li>
  <li><strong>采购视图</strong>：包含采购相关信息。</li>
  <li><strong>库存视图</strong>：记录库存管理信息。</li>
  <li><strong>会计视图</strong>：用于财务核算。</li>
</ul>

<h4 id="操作步骤-4">操作步骤</h4>
<ol>
  <li>创建物料主数据：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">MM01</code>，输入行业领域、物料类型等信息。</li>
    </ul>
  </li>
  <li>修改物料主数据：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">MM02</code>，输入物料编号修改信息。</li>
    </ul>
  </li>
  <li>显示物料主数据：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">MM03</code>，查看详细内容。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-4">案例</h4>
<p>某电子制造企业生产智能手机，创建手机屏幕的物料主数据：</p>
<ul>
  <li>基本数据视图：物料描述为 “XX 型号手机屏幕”，物料组为 “电子显示屏”。</li>
  <li>采购视图：采购组为 “电子采购组”，主要供应商为 “供应商 A”。</li>
  <li>库存视图：启用批次管理，设置库存地点为 “原材料仓库 1”。</li>
</ul>

<hr />

<h3 id="22-采购管理purchasing">2.2 采购管理（Purchasing）</h3>

<h4 id="知识点-5">知识点</h4>
<ul>
  <li><strong>采购申请</strong>：企业内部部门提出采购需求的单据。</li>
  <li><strong>采购订单</strong>：向供应商发出的采购合同。</li>
  <li><strong>供应商评估</strong>：对供应商的交货及时性、产品质量等进行评估。</li>
  <li><strong>收货</strong>：收到供应商货物时，在系统中进行收货操作。</li>
  <li><strong>发票校验</strong>：将供应商发票与采购订单、收货信息进行匹配。</li>
</ul>

<h4 id="操作步骤-5">操作步骤</h4>
<ol>
  <li>创建采购申请：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">ME51N</code>，输入工厂、采购组等信息。</li>
    </ul>
  </li>
  <li>创建采购订单：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">ME21N</code>，基于采购申请创建订单。</li>
    </ul>
  </li>
  <li>供应商评估：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">ME60</code>，选择评估期间、维度等。</li>
    </ul>
  </li>
  <li>收货操作：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">MIGO</code>，选择 “采购订单收货”。</li>
    </ul>
  </li>
  <li>发票校验：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">MIRO</code>，输入供应商编号、发票信息等。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-5">案例</h4>
<p>企业生产部门因生产计划，使用 <code class="language-plaintext highlighter-rouge">ME51N</code> 创建采购申请，申请采购 1000 个手机电池：</p>
<ul>
  <li>采购部门通过 <code class="language-plaintext highlighter-rouge">ME21N</code> 创建采购订单，规定单价为 50 元 / 个。</li>
  <li>10 天后，仓库人员使用 <code class="language-plaintext highlighter-rouge">MIGO</code> 对收到的 1000 个手机电池进行收货操作。</li>
  <li>收到供应商 B 的发票，财务人员通过 <code class="language-plaintext highlighter-rouge">MIRO</code> 进行发票校验，匹配成功后确认应付账款。</li>
</ul>

<hr />

<h3 id="23-库存管理inventory-management">2.3 库存管理（Inventory Management）</h3>

<h4 id="知识点-6">知识点</h4>
<ul>
  <li><strong>入库</strong>：包括采购收货入库、生产入库、其他入库。</li>
  <li><strong>出库</strong>：包括生产领料出库、销售出库、其他出库。</li>
  <li><strong>库存盘点</strong>：定期对库存进行实地盘点。</li>
  <li><strong>库存转移</strong>：物料在企业内部不同库存地点之间的转移。</li>
</ul>

<h4 id="操作步骤-6">操作步骤</h4>
<ol>
  <li>入库操作：
    <ul>
      <li>采购收货入库：使用事务代码 <code class="language-plaintext highlighter-rouge">MIGO</code>，选择 “采购订单收货”。</li>
      <li>生产入库：使用事务代码 <code class="language-plaintext highlighter-rouge">MIGO</code>，选择 “生产订单收货”。</li>
      <li>其他入库：使用事务代码 <code class="language-plaintext highlighter-rouge">MIGO</code>，选择 “其他收货”。</li>
    </ul>
  </li>
  <li>出库操作：
    <ul>
      <li>生产领料出库：使用事务代码 <code class="language-plaintext highlighter-rouge">MB1A</code>，选择移动类型（如 261）。</li>
      <li>销售出库：使用事务代码 <code class="language-plaintext highlighter-rouge">VL02N</code>，创建外向交货单。</li>
      <li>其他出库：使用事务代码 <code class="language-plaintext highlighter-rouge">MB1A</code>，选择移动类型（如 551）。</li>
    </ul>
  </li>
  <li>库存盘点：
    <ul>
      <li>创建盘点凭证：使用事务代码 <code class="language-plaintext highlighter-rouge">MI01</code>。</li>
      <li>录入盘点结果：使用事务代码 <code class="language-plaintext highlighter-rouge">MI04</code>。</li>
      <li>差异处理：使用事务代码 <code class="language-plaintext highlighter-rouge">MI20</code>。</li>
    </ul>
  </li>
  <li>库存转移：
    <ul>
      <li>一步式转移：使用事务代码 <code class="language-plaintext highlighter-rouge">MB1B</code>，选择移动类型（如 311）。</li>
      <li>两步式转移：先使用 MB1B 进行发出过账，再进行接收过账。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-6">案例</h4>
<p>企业手机生产线生产完成 100 台手机：</p>
<ul>
  <li>使用 MIGO 进行生产入库操作，将成品手机入库到 “成品仓库”。</li>
  <li>销售部门接到客户订单，通过 VL02N 创建外向交货单，完成 10 台手机的销售出库。</li>
</ul>

<hr />

<h3 id="24-发票校验invoice-verification">2.4 发票校验（Invoice Verification）</h3>

<h4 id="知识点-7">知识点</h4>
<ul>
  <li><strong>发票匹配</strong>：将供应商发票上的物料、数量、价格等信息与采购订单和收货单进行比对。</li>
  <li><strong>差异处理</strong>：发票与采购订单或收货信息存在差异时的处理方法。</li>
  <li><strong>生成会计凭证</strong>：发票校验通过后，系统自动生成会计凭证。</li>
</ul>

<h4 id="操作步骤-7">操作步骤</h4>
<ol>
  <li>发票录入：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">MIRO</code>，输入供应商编号、发票日期等基本信息。</li>
    </ul>
  </li>
  <li>选择匹配方式并匹配发票：
    <ul>
      <li>根据业务需求选择匹配方式，选择对应的采购订单和收货单。</li>
    </ul>
  </li>
  <li>差异处理：
    <ul>
      <li>若存在差异，系统提示差异类型和金额，需核实情况并手动调整。</li>
    </ul>
  </li>
  <li>过账发票：
    <ul>
      <li>确认发票信息无误后，点击 “过账” 按钮生成会计凭证。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-7">案例</h4>
<p>企业向供应商 C 采购一批电路板，采购订单数量为 500 块，单价为 100 元 / 块：</p>
<ul>
  <li>收货时实际收到 498 块，收到供应商 C 的发票，发票数量为 500 块，单价为 102 元 / 块。</li>
  <li>财务人员使用 MIRO 进行发票校验，系统提示数量差异和价格差异。</li>
  <li>经核实，确认数量差异是运输损耗，价格差异是供应商临时调价且已提前通知采购部门但未及时更新订单价格。</li>
</ul>

<hr />

<h2 id="三销售与分销sd模块">三、销售与分销（SD）模块</h2>

<h3 id="31-销售组织sales-organization">3.1 销售组织（Sales Organization）</h3>

<h4 id="知识点-8">知识点</h4>
<ul>
  <li><strong>组织架构关系</strong>：销售组织与分销渠道、产品组共同构成 SD 模块的组织架构。</li>
  <li><strong>业务职能</strong>：制定销售策略、管理客户关系、处理销售订单、安排交货和开票等。</li>
</ul>

<h4 id="操作步骤-8">操作步骤</h4>
<ol>
  <li>创建销售组织：
    <ul>
      <li>使用 IMG 路径进入设置界面，点击 “新建” 按钮，输入销售组织代码、名称和所属公司代码。</li>
    </ul>
  </li>
  <li>分配分销渠道和产品组：
    <ul>
      <li>在 IMG 路径中分配分销渠道和产品组。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-8">案例</h4>
<p>某大型家电制造企业创建了多个销售组织，分别对应不同的地理区域：</p>
<ul>
  <li>每个销售组织下设置了直销、批发等分销渠道，以及空调、冰箱等产品组。</li>
</ul>

<hr />

<h3 id="32-客户主数据customer-master-data">3.2 客户主数据（Customer Master Data）</h3>

<h4 id="知识点-9">知识点</h4>
<ul>
  <li><strong>数据视图分类</strong>：一般数据视图、销售数据视图、公司代码数据视图。</li>
  <li><strong>信用管理</strong>：通过客户主数据中的信用额度、信用期限等设置，结合信用控制范围，对客户进行信用评估和风险管控。</li>
</ul>

<h4 id="操作步骤-9">操作步骤</h4>
<ol>
  <li>创建客户主数据：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">XD01</code>，输入客户名称、地址等基本信息。</li>
    </ul>
  </li>
  <li>修改客户主数据：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">XD02</code>，输入客户编号修改信息。</li>
    </ul>
  </li>
  <li>显示客户主数据：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">XD03</code>，查看详细内容。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-9">案例</h4>
<p>某家具销售企业新开发了一家大型客户 “XX 家居连锁公司”：</p>
<ul>
  <li>使用 XD01 创建客户主数据，在一般数据视图录入客户公司名称、总部地址和联系人电话。</li>
  <li>在销售数据视图，设置该客户属于 “零售” 分销渠道，采用特定的客户定价过程。</li>
  <li>在公司代码数据视图，设定信用额度为 500 万元，付款条件为货到 45 天付款。</li>
</ul>

<hr />

<h3 id="33-销售订单处理sales-order-processing">3.3 销售订单处理（Sales Order Processing）</h3>

<h4 id="知识点-10">知识点</h4>
<ul>
  <li><strong>订单类型</strong>：标准订单、寄售订单、加急订单等。</li>
  <li><strong>可用性检查</strong>：确保企业有能力按时交付货物。</li>
  <li><strong>定价过程</strong>：根据客户主数据中的定价条件、销售订单中的产品和数量等因素，自动计算订单价格。</li>
</ul>

<h4 id="操作步骤-10">操作步骤</h4>
<ol>
  <li>创建销售订单：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">VA01</code>，选择订单类型，输入销售组织、分销渠道、产品组和售达方等信息。</li>
    </ul>
  </li>
  <li>订单确认与可用性检查：
    <ul>
      <li>系统自动进行可用性检查，若检查通过可在 VA02 中对订单进行最终确认。</li>
    </ul>
  </li>
  <li>订单后续处理：
    <ul>
      <li>确认后的订单可通过事务代码 VA03 查看详细信息，并触发后续的交货、开票等业务流程。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-10">案例</h4>
<p>某服装销售企业接到客户 “时尚潮流服装店” 的订单，订购 1000 件新款 T 恤：</p>
<ul>
  <li>使用 VA01 创建标准销售订单，选择对应的销售组织、分销渠道和客户。</li>
  <li>输入物料编号后，系统带出 T 恤的单价为 50 元 / 件，根据客户主数据中的折扣条件，自动计算出折扣后的总价。</li>
  <li>系统进行可用性检查时，发现库存只有 800 件，企业通过 VA02 修改订单交货日期，并安排生产部门加急生产剩余的 200 件。</li>
</ul>

<hr />

<h3 id="34-交货处理delivery-processing">3.4 交货处理（Delivery Processing）</h3>

<h4 id="知识点-11">知识点</h4>
<ul>
  <li><strong>交货单创建</strong>：根据销售订单创建交货单。</li>
  <li><strong>拣配与发货</strong>：从仓库中提取货物并进行发货过账。</li>
</ul>

<h4 id="操作步骤-11">操作步骤</h4>
<ol>
  <li>创建交货单：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">VL01N</code>，输入销售订单编号，系统自动带出订单中的物料、客户等信息。</li>
    </ul>
  </li>
  <li>拣配货物：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">LT06</code> 进行拣配操作，记录实际拣配的货物数量和批次等信息。</li>
    </ul>
  </li>
  <li>发货过账：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">VL02N</code> 对交货单进行发货过账。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-11">案例</h4>
<p>上述服装销售企业针对 “时尚潮流服装店” 的订单：</p>
<ul>
  <li>使用 VL01N 根据销售订单创建交货单。</li>
  <li>仓库人员接到交货单后，使用 LT06 进行拣配，从仓库中挑选出 1000 件新款 T 恤。</li>
  <li>拣配完成后，通过 VL02N 对交货单进行发货过账。</li>
</ul>

<hr />

<h3 id="35-发票处理billing-processing">3.5 发票处理（Billing Processing）</h3>

<h4 id="知识点-12">知识点</h4>
<ul>
  <li><strong>发票类型</strong>：销售发票、贷项凭证、借项凭证等。</li>
  <li><strong>发票校验与过账</strong>：生成发票后，需对发票内容进行校验，确保金额、物料等信息准确无误。</li>
</ul>

<h4 id="操作步骤-12">操作步骤</h4>
<ol>
  <li>创建发票：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">VF01</code>，选择发票类型，输入交货单编号等信息。</li>
    </ul>
  </li>
  <li>发票校验：
    <ul>
      <li>使用事务代码 <code class="language-plaintext highlighter-rouge">VF02</code> 检查发票内容是否正确。</li>
    </ul>
  </li>
  <li>发票过账：
    <ul>
      <li>校验通过后，在 VF02 中点击 “过账” 按钮生成会计凭证。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-12">案例</h4>
<p>服装销售企业在完成向 “时尚潮流服装店” 的货物交付后：</p>
<ul>
  <li>使用 VF01 根据交货单创建销售发票，系统自动计算发票金额为 50000 元，加上增值税 6500 元，合计总金额 56500 元。</li>
  <li>财务人员通过 VF02 对发票进行校验，确认无误后进行过账操作。</li>
</ul>

<hr />

<h2 id="四hana数据库">四、HANA数据库</h2>

<h3 id="41-hana数据库概述">4.1 HANA数据库概述</h3>

<h4 id="知识点-13">知识点</h4>
<ul>
  <li><strong>内存计算技术</strong>：极大提升了数据处理速度，能够实现实时数据分析和复杂计算。</li>
  <li><strong>列存储与行存储</strong>：列存储适用于数据分析场景，行存储则适用于事务处理。</li>
  <li><strong>多模型数据处理</strong>：支持非结构化数据和空间数据的处理。</li>
</ul>

<h4 id="案例-13">案例</h4>
<p>某电商企业每天产生海量的交易数据和用户行为数据：</p>
<ul>
  <li>使用 HANA 数据库后，基于内存计算技术，同样的数据分析任务在几分钟内即可完成，企业能够实时掌握销售趋势、用户偏好等信息。</li>
</ul>

<hr />

<h3 id="42-hana数据库架构">4.2 HANA数据库架构</h3>

<h4 id="知识点-14">知识点</h4>
<ul>
  <li><strong>硬件层</strong>：通常采用高性能的服务器集群。</li>
  <li><strong>系统软件层</strong>：包含操作系统、虚拟化软件等。</li>
  <li><strong>HANA数据库层</strong>：核心部分，包括数据存储引擎、计算引擎、事务处理引擎等。</li>
  <li><strong>应用层</strong>：用户通过各种应用程序访问 HANA 数据库。</li>
</ul>

<h4 id="操作步骤-13">操作步骤</h4>
<ol>
  <li>硬件部署：
    <ul>
      <li>配置多台具有高主频 CPU、大容量内存和高速 SSD 的服务器。</li>
    </ul>
  </li>
  <li>系统软件安装：
    <ul>
      <li>安装适合 HANA 运行的操作系统，配置好系统参数。</li>
    </ul>
  </li>
  <li>HANA数据库安装与配置：
    <ul>
      <li>使用 HANA 安装包进行数据库安装，配置数据库实例。</li>
    </ul>
  </li>
  <li>应用层部署：
    <ul>
      <li>将开发好的应用程序部署到应用服务器上。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-14">案例</h4>
<p>一家大型制造企业计划部署 HANA 数据库以支持其智能制造业务：</p>
<ul>
  <li>在硬件层，采购了 10 台高性能服务器组成集群。</li>
  <li>在系统软件层，安装 SUSE Linux 操作系统和 VMware vSphere 虚拟化软件。</li>
  <li>安装 HANA 数据库时，为数据库实例分配 300GB 内存。</li>
  <li>最后，将企业自主开发的生产数据分析应用部署到应用服务器，连接 HANA 数据库。</li>
</ul>

<hr />

<h3 id="43-hana数据建模">4.3 HANA数据建模</h3>

<h4 id="知识点-15">知识点</h4>
<ul>
  <li><strong>表和视图</strong>：HANA 中的表分为行存储表和列存储表，视图是虚拟的表。</li>
  <li><strong>计算视图</strong>：HANA 的核心建模对象，支持属性视图、分析视图和计算视图。</li>
  <li><strong>数据关系</strong>：定义表与表之间的关联关系。</li>
</ul>

<h4 id="操作步骤-14">操作步骤</h4>
<ol>
  <li>创建表：
    <ul>
      <li>在 HANA Studio 中，右键点击模式，选择 “新建” → “表”。</li>
    </ul>
  </li>
  <li>创建视图：
    <ul>
      <li>同样在 HANA Studio 中，右键点击模式，选择 “新建” → “视图”。</li>
    </ul>
  </li>
  <li>定义数据关系：
    <ul>
      <li>在创建表时设置外键字段，并关联到主表的主键。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-15">案例</h4>
<p>某零售企业使用 HANA 数据库管理销售数据：</p>
<ul>
  <li>创建了 “销售订单表”、“客户表” 和 “产品表”。</li>
  <li>创建一个计算视图，将 “销售订单表” 与 “客户表” 通过客户编号关联，添加计算列计算每个客户的订单数量和总销售额。</li>
</ul>

<hr />

<h3 id="44-hana应用开发">4.4 HANA应用开发</h3>

<h4 id="知识点-16">知识点</h4>
<ul>
  <li><strong>开发语言与技术</strong>：支持 SQL、SQLScript、Java、Python 等。</li>
  <li><strong>应用接口</strong>：提供 OData、JDBC/ODBC 等接口。</li>
  <li><strong>开发工具</strong>：主要使用 HANA Studio 和 SAP Web IDE。</li>
</ul>

<h4 id="操作步骤-15">操作步骤</h4>
<ol>
  <li>确定开发需求与技术选型：
    <ul>
      <li>明确应用的功能需求，选择合适的开发语言和技术。</li>
    </ul>
  </li>
  <li>数据库开发：
    <ul>
      <li>在 HANA Studio 中编写存储过程、函数、视图等数据库对象。</li>
    </ul>
  </li>
  <li>前端开发与集成：
    <ul>
      <li>使用前端开发技术开发用户界面，通过 OData 接口与 HANA 数据库连接。</li>
    </ul>
  </li>
  <li>测试与部署：
    <ul>
      <li>对应用进行功能测试、性能测试和安全测试，测试通过后部署到生产环境。</li>
    </ul>
  </li>
</ol>

<h4 id="案例-16">案例</h4>
<p>某金融企业为了实现对客户信用风险的实时评估，基于 HANA 数据库进行应用开发：</p>
<ul>
  <li>后端使用 SQLScript 编写存储过程，从前端应用获取数据。</li>
  <li>前端使用 SAPUI5 开发用户界面，通过 OData 接口获取后端计算的信用评分数据。</li>
  <li>开发完成后，经过全面测试，将应用部署到企业的生产环境中。</li>
</ul>

<hr />]]></content><author><name></name></author><category term="SAP" /><summary type="html"><![CDATA[SAP学习笔记]]></summary></entry><entry><title type="html">Linux学习笔记</title><link href="http://localhost:4000/blog/linux/2025/06/05/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="Linux学习笔记" /><published>2025-06-05T00:00:00+08:00</published><updated>2025-06-05T00:00:00+08:00</updated><id>http://localhost:4000/blog/linux/2025/06/05/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/linux/2025/06/05/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="linux-学习笔记">Linux 学习笔记</h1>

<h2 id="一linux-基础概念">一、Linux 基础概念</h2>
<h3 id="1-操作系统核心">1. 操作系统核心</h3>
<h4 id="内核kernel">内核（Kernel）</h4>
<p>内核是 Linux 操作系统的核心，负责管理硬件资源，如内存、CPU、设备 I/O 等，同时提供系统服务，如文件管理、进程调度等。
<strong>例子</strong>：当我们运行一个程序时，内核会为该程序分配内存和 CPU 资源，确保程序能够正常运行。</p>

<h4 id="用户态与内核态">用户态与内核态</h4>
<ul>
  <li><strong>用户态</strong>：运行应用程序，权限受限，不能直接操作硬件。</li>
  <li><strong>内核态</strong>：执行特权指令，直接操作硬件。</li>
  <li><strong>切换方式</strong>：系统调用、异常、中断。
<strong>例子</strong>：当我们在用户态下执行 <code class="language-plaintext highlighter-rouge">read</code> 系统调用读取文件时，会触发系统调用，使程序从用户态切换到内核态，由内核完成文件读取操作，然后再切换回用户态。</li>
</ul>

<h3 id="2-linux-发行版分类">2. Linux 发行版分类</h3>
<p>| <strong>类型</strong> | <strong>代表系统</strong> | <strong>包管理器</strong> |
| —- | —- | —- |
| Debian 系 | Ubuntu | <code class="language-plaintext highlighter-rouge">apt</code>/<code class="language-plaintext highlighter-rouge">apt-get</code> |
| Red Hat 系 | CentOS, Fedora | <code class="language-plaintext highlighter-rouge">yum</code>/<code class="language-plaintext highlighter-rouge">dnf</code> |
| Arch 系 | Arch Linux, Manjaro | <code class="language-plaintext highlighter-rouge">pacman</code> |</p>

<p><strong>例子</strong>：如果我们使用的是 Ubuntu 系统，要安装 Nginx 服务器，可以使用以下命令：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>nginx
</code></pre></div></div>

<h2 id="二文件系统与目录结构">二、文件系统与目录结构</h2>
<h3 id="1-核心原则">1. 核心原则</h3>
<h4 id="一切皆文件">一切皆文件</h4>
<p>在 Linux 中，硬件设备、目录、进程等均抽象为文件。例如，<code class="language-plaintext highlighter-rouge">/dev/sda</code> 表示磁盘。
<strong>例子</strong>：我们可以使用 <code class="language-plaintext highlighter-rouge">ls</code> 命令查看 <code class="language-plaintext highlighter-rouge">/dev</code> 目录下的设备文件：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> /dev
</code></pre></div></div>

<h4 id="inode-机制">inode 机制</h4>
<p>inode 存储文件元数据，如权限、大小、时间戳等，可以通过 <code class="language-plaintext highlighter-rouge">stat</code> 命令查看。
<strong>例子</strong>：查看 <code class="language-plaintext highlighter-rouge">test.txt</code> 文件的 inode 信息：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">stat </span>test.txt
</code></pre></div></div>

<h3 id="2-目录结构解析">2. 目录结构解析</h3>
<p>| <strong>目录</strong> | <strong>作用</strong> |
| —- | —- |
| <code class="language-plaintext highlighter-rouge">/bin</code> | 基础命令（<code class="language-plaintext highlighter-rouge">ls</code>, <code class="language-plaintext highlighter-rouge">cat</code>） |
| <code class="language-plaintext highlighter-rouge">/etc</code> | 配置文件（<code class="language-plaintext highlighter-rouge">/etc/hostname</code> 改主机名） |
| <code class="language-plaintext highlighter-rouge">/home</code> | 用户主目录 |
| <code class="language-plaintext highlighter-rouge">/var</code> | 动态数据（日志文件 <code class="language-plaintext highlighter-rouge">/var/log</code>） |
| <code class="language-plaintext highlighter-rouge">/proc</code> | 虚拟文件系统，映射内核实时状态（如 <code class="language-plaintext highlighter-rouge">/proc/cpuinfo</code>） |</p>

<p><strong>例子</strong>：查看当前系统的 CPU 信息：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /proc/cpuinfo
</code></pre></div></div>

<h3 id="3-文件类型与权限">3. 文件类型与权限</h3>
<h4 id="文件类型标识">文件类型标识</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">-</code>：普通文件</li>
  <li><code class="language-plaintext highlighter-rouge">d</code>：目录</li>
  <li><code class="language-plaintext highlighter-rouge">l</code>：符号链接（软链接）</li>
  <li><code class="language-plaintext highlighter-rouge">c</code>/<code class="language-plaintext highlighter-rouge">b</code>：字符/块设备文件</li>
</ul>

<h4 id="权限管理">权限管理</h4>
<ul>
  <li>字符权限：<code class="language-plaintext highlighter-rouge">r</code>（读，4）、<code class="language-plaintext highlighter-rouge">w</code>（写，2）、<code class="language-plaintext highlighter-rouge">x</code>（执行，1）。</li>
  <li>命令：<code class="language-plaintext highlighter-rouge">chmod u+x file</code>（添加用户执行权限）或 <code class="language-plaintext highlighter-rouge">chmod 755 file</code>。</li>
</ul>

<p><strong>例子</strong>：给 <code class="language-plaintext highlighter-rouge">test.sh</code> 文件添加用户执行权限：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod </span>u+x test.sh
</code></pre></div></div>

<h2 id="三常用命令详解">三、常用命令详解</h2>
<h3 id="1-文件与目录操作">1. 文件与目录操作</h3>
<h4 id="增删改查">增删改查</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> dir1/dir2    <span class="c"># 递归创建目录</span>
find /home <span class="nt">-name</span> <span class="s2">"*.log"</span>  <span class="c"># 查找日志文件</span>
<span class="nb">cp</span> <span class="nt">-r</span> dir1 dir2      <span class="c"># 递归复制目录</span>
<span class="nb">rm</span> <span class="nt">-rf</span> tmp           <span class="c"># 强制删除非空目录</span>
</code></pre></div></div>

<p><strong>例子</strong>：在 <code class="language-plaintext highlighter-rouge">/tmp</code> 目录下递归创建 <code class="language-plaintext highlighter-rouge">test/dir</code> 目录：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> /tmp/test/dir
</code></pre></div></div>

<h4 id="查看内容">查看内容</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cat</code>：全量输出</li>
  <li><code class="language-plaintext highlighter-rouge">tail -f log.txt</code>：实时追踪日志。</li>
</ul>

<p><strong>例子</strong>：实时追踪 <code class="language-plaintext highlighter-rouge">app.log</code> 文件的日志：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tail</span> <span class="nt">-f</span> app.log
</code></pre></div></div>

<h3 id="2-系统管理命令">2. 系统管理命令</h3>
<h4 id="进程管理">进程管理</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps aux | <span class="nb">grep </span>nginx  <span class="c"># 查看 Nginx 进程</span>
top                 <span class="c"># 动态监控资源占用</span>
<span class="nb">kill</span> <span class="nt">-9</span> PID         <span class="c"># 强制终止进程</span>
</code></pre></div></div>

<p><strong>例子</strong>：查看所有 Nginx 进程：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps aux | <span class="nb">grep </span>nginx
</code></pre></div></div>

<h4 id="服务管理">服务管理</h4>
<p><code class="language-plaintext highlighter-rouge">systemctl start nginx</code></p>

<p><strong>例子</strong>：启动 Nginx 服务：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start nginx
</code></pre></div></div>

<h3 id="3-网络工具">3. 网络工具</h3>
<ul>
  <li>配置 IP：<code class="language-plaintext highlighter-rouge">ip addr add 192.168.1.10/24 dev eth0</code></li>
  <li>诊断工具：<code class="language-plaintext highlighter-rouge">ping</code>、<code class="language-plaintext highlighter-rouge">traceroute</code>、<code class="language-plaintext highlighter-rouge">netstat</code>。</li>
</ul>

<p><strong>例子</strong>：测试与 <code class="language-plaintext highlighter-rouge">www.google.com</code> 的网络连接：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping www.google.com
</code></pre></div></div>

<h2 id="四系统管理与安全">四、系统管理与安全</h2>
<h3 id="1-包管理器">1. 包管理器</h3>
<h4 id="安装软件">安装软件</h4>
<ul>
  <li>Ubuntu：<code class="language-plaintext highlighter-rouge">sudo apt install nginx</code></li>
  <li>CentOS：<code class="language-plaintext highlighter-rouge">sudo yum install httpd</code>。</li>
</ul>

<p><strong>例子</strong>：在 CentOS 系统上安装 Apache 服务器：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install </span>httpd
</code></pre></div></div>

<h3 id="2-防火墙配置">2. 防火墙配置</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>80/tcp <span class="nt">--permanent</span>  <span class="c"># 开放 80 端口</span>
firewall-cmd <span class="nt">--reload</span>                      <span class="c"># 重载配置</span>
</code></pre></div></div>

<p><strong>例子</strong>：开放 443 端口并重新加载防火墙配置：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>443/tcp <span class="nt">--permanent</span>
firewall-cmd <span class="nt">--reload</span>
</code></pre></div></div>

<h3 id="3-安全实践">3. 安全实践</h3>
<ul>
  <li>定期更新：<code class="language-plaintext highlighter-rouge">sudo apt update &amp;&amp; sudo apt upgrade</code>。</li>
  <li>密钥登录：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-keygen <span class="nt">-t</span> ed25519                   <span class="c"># 生成密钥</span>
ssh-copy-id user@host                   <span class="c"># 部署公钥</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>例子</strong>：生成 ed25519 密钥并将公钥部署到远程服务器：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-keygen <span class="nt">-t</span> ed25519
ssh-copy-id user@192.168.1.100
</code></pre></div></div>

<h2 id="五shell-编程与脚本">五、Shell 编程与脚本</h2>
<h3 id="1-基础语法">1. 基础语法</h3>
<h4 id="变量">变量</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">name</span><span class="o">=</span><span class="s2">"Linux"</span>
</code></pre></div></div>

<h4 id="条件判断">条件判断</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> file.txt <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"文件存在"</span>
<span class="k">fi</span>
</code></pre></div></div>

<h4 id="循环">循环</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..5<span class="o">}</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<p><strong>例子</strong>：判断 <code class="language-plaintext highlighter-rouge">test.txt</code> 文件是否存在，如果存在则输出提示信息：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> test.txt <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"test.txt 文件存在"</span>
<span class="k">fi</span>
</code></pre></div></div>

<h3 id="2-输入输出重定向">2. 输入输出重定向</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">command &gt; output.log</code>：覆盖输出到文件。</li>
  <li><code class="language-plaintext highlighter-rouge">command 2&gt;&amp;1</code>：合并标准错误与标准输出。</li>
</ul>

<p><strong>例子</strong>：将 <code class="language-plaintext highlighter-rouge">ls</code> 命令的输出覆盖到 <code class="language-plaintext highlighter-rouge">output.log</code> 文件中：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="o">&gt;</span> output.log
</code></pre></div></div>

<h2 id="六磁盘与存储管理">六、磁盘与存储管理</h2>
<h3 id="1-分区与格式化">1. 分区与格式化</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fdisk /dev/sdb           <span class="c"># 分区操作</span>
mkfs.ext4 /dev/sdb1      <span class="c"># 格式化为 ext4</span>
mount /dev/sdb1 /mnt/data <span class="c"># 挂载到目录</span>
</code></pre></div></div>

<p><strong>例子</strong>：对 <code class="language-plaintext highlighter-rouge">/dev/sdb</code> 磁盘进行分区，将第一个分区格式化为 ext4 并挂载到 <code class="language-plaintext highlighter-rouge">/mnt/data</code> 目录：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fdisk /dev/sdb
mkfs.ext4 /dev/sdb1
mount /dev/sdb1 /mnt/data
</code></pre></div></div>

<h3 id="2-逻辑卷管理lvm">2. 逻辑卷管理（LVM）</h3>
<p>步骤：物理卷（PV）→ 卷组（VG）→ 逻辑卷（LV）。</p>

<h3 id="3-swap-交换空间">3. Swap 交换空间</h3>
<p>作用：扩展虚拟内存，防止物理内存不足。</p>

<h2 id="七开发环境部署">七、开发环境部署</h2>
<h3 id="1-git-配置">1. Git 配置</h3>
<h4 id="关联-github">关联 GitHub</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> user.email <span class="s2">"your@email.com"</span>
ssh <span class="nt">-T</span> git@github.com      <span class="c"># 测试 SSH 连接</span>
</code></pre></div></div>

<p><strong>例子</strong>：配置全局 Git 用户邮箱并测试与 GitHub 的 SSH 连接：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> user.email <span class="s2">"test@example.com"</span>
ssh <span class="nt">-T</span> git@github.com
</code></pre></div></div>

<h3 id="2-文本编辑器-vim">2. 文本编辑器 Vim</h3>
<h4 id="三种模式">三种模式</h4>
<ul>
  <li>命令模式：移动光标、删除字符（<code class="language-plaintext highlighter-rouge">x</code>）。</li>
  <li>输入模式（<code class="language-plaintext highlighter-rouge">i</code> 进入）：编辑文本。</li>
  <li>末行模式（<code class="language-plaintext highlighter-rouge">:</code>）：保存（<code class="language-plaintext highlighter-rouge">:w</code>）、退出（<code class="language-plaintext highlighter-rouge">:q!</code>）。</li>
</ul>

<p><strong>例子</strong>：使用 Vim 打开 <code class="language-plaintext highlighter-rouge">test.txt</code> 文件，进入输入模式编辑文件内容，然后保存并退出：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim test.txt
i  <span class="c"># 进入输入模式</span>
<span class="c"># 编辑文件内容</span>
Esc  <span class="c"># 退出输入模式</span>
:wq  <span class="c"># 保存并退出</span>
</code></pre></div></div>

<h2 id="八推荐资源">八、推荐资源</h2>
<ul>
  <li>命令查询：<a href="http://man.linuxde.net/">Linux 命令大全</a></li>
  <li>实战项目：<a href="https://github.com/judasn/Linux-Tutorial">Linux-Tutorial</a>（含 Zookeeper、Docker 配置）。</li>
</ul>

<h2 id="补充内容">补充内容</h2>

<h3 id="补充一基础命令分类详解">补充一：基础命令分类详解</h3>
<h4 id="1-文件与目录操作命令">1. 文件与目录操作命令</h4>
<p>| <strong>命令</strong> | <strong>作用</strong> | <strong>常用参数</strong> | <strong>示例</strong> |
| —- | —- | —- | —- |
| <code class="language-plaintext highlighter-rouge">ls</code> | 查看目录内容 | <code class="language-plaintext highlighter-rouge">-l</code>(详情) <code class="language-plaintext highlighter-rouge">-a</code>(隐藏文件) | <code class="language-plaintext highlighter-rouge">ls -la /etc</code> |
| <code class="language-plaintext highlighter-rouge">cd</code> | 切换目录 | <code class="language-plaintext highlighter-rouge">~</code>(家目录) <code class="language-plaintext highlighter-rouge">..</code>(上级) | <code class="language-plaintext highlighter-rouge">cd ~/projects</code> |
| <code class="language-plaintext highlighter-rouge">pwd</code> | 显示当前路径 | - | <code class="language-plaintext highlighter-rouge">pwd</code> |
| <code class="language-plaintext highlighter-rouge">touch</code> | 创建空文件/更新文件时间戳 | - | <code class="language-plaintext highlighter-rouge">touch test.txt</code> |
| <code class="language-plaintext highlighter-rouge">cp</code> | 复制文件/目录 | <code class="language-plaintext highlighter-rouge">-r</code>(递归) <code class="language-plaintext highlighter-rouge">-i</code>(交互) | <code class="language-plaintext highlighter-rouge">cp -r dir1 dir2</code> |
| <code class="language-plaintext highlighter-rouge">mv</code> | 移动/重命名文件 | <code class="language-plaintext highlighter-rouge">-f</code>(强制) | <code class="language-plaintext highlighter-rouge">mv old.txt new.txt</code> |
| <code class="language-plaintext highlighter-rouge">rm</code> | 删除文件 | <code class="language-plaintext highlighter-rouge">-r</code>(递归) <code class="language-plaintext highlighter-rouge">-f</code>(强制) | <code class="language-plaintext highlighter-rouge">rm -rf tmp/</code> (⚠️谨慎使用) |
| <code class="language-plaintext highlighter-rouge">find</code> | 文件搜索 | <code class="language-plaintext highlighter-rouge">-name</code>(名称) <code class="language-plaintext highlighter-rouge">-type</code>(类型) | <code class="language-plaintext highlighter-rouge">find / -name "*.conf"</code> |</p>

<h4 id="2-文本查看与处理命令">2. 文本查看与处理命令</h4>
<p>| <strong>命令</strong> | <strong>用途</strong> | <strong>关键技巧</strong> |
| —- | —- | —- |
| <code class="language-plaintext highlighter-rouge">cat</code> | 显示整个文件内容 | <code class="language-plaintext highlighter-rouge">cat file1 &gt; file2</code> (覆盖重定向) |
| <code class="language-plaintext highlighter-rouge">head</code> | 显示文件头部 | <code class="language-plaintext highlighter-rouge">head -n 10 log.txt</code> (前 10 行) |
| <code class="language-plaintext highlighter-rouge">tail</code> | 显示文件尾部 | <code class="language-plaintext highlighter-rouge">tail -f app.log</code> (实时追踪日志) |
| <code class="language-plaintext highlighter-rouge">grep</code> | 文本搜索 | <code class="language-plaintext highlighter-rouge">grep "error" log.txt -C 3</code> (显示匹配行前后 3 行) |
| <code class="language-plaintext highlighter-rouge">awk</code> | 文本分析处理 | <code class="language-plaintext highlighter-rouge">awk '{print $1}' data.txt</code> (打印第一列) |
| <code class="language-plaintext highlighter-rouge">sed</code> | 流编辑器 | <code class="language-plaintext highlighter-rouge">sed 's/old/new/g' file</code> (全局替换) |</p>

<h4 id="3-压缩与解压命令">3. 压缩与解压命令</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-czvf</span> archive.tar.gz <span class="nb">dir</span>/    <span class="c"># 压缩目录为 gzip 格式</span>
<span class="nb">tar</span> <span class="nt">-xzvf</span> archive.tar.gz         <span class="c"># 解压 gzip 压缩包</span>
unzip file.zip                   <span class="c"># 解压 zip 文件</span>
</code></pre></div></div>

<h3 id="补充二用户与权限管理">补充二：用户与权限管理</h3>
<h4 id="1-用户组管理命令">1. 用户/组管理命令</h4>
<p>| <strong>命令</strong> | <strong>功能</strong> | <strong>关键参数</strong> | <strong>示例</strong> |
| —- | —- | —- | —- |
| <code class="language-plaintext highlighter-rouge">useradd</code> | 创建用户 | <code class="language-plaintext highlighter-rouge">-m</code>(创建家目录) <code class="language-plaintext highlighter-rouge">-s</code>(指定 Shell) | <code class="language-plaintext highlighter-rouge">useradd -m -s /bin/bash john</code> |
| <code class="language-plaintext highlighter-rouge">passwd</code> | 修改用户密码 | - | <code class="language-plaintext highlighter-rouge">passwd john</code> |
| <code class="language-plaintext highlighter-rouge">usermod</code> | 修改用户属性 | <code class="language-plaintext highlighter-rouge">-aG</code>(追加用户组) | <code class="language-plaintext highlighter-rouge">usermod -aG sudo john</code> |
| <code class="language-plaintext highlighter-rouge">userdel</code> | 删除用户 | <code class="language-plaintext highlighter-rouge">-r</code>(同时删除家目录) | <code class="language-plaintext highlighter-rouge">userdel -r john</code> |
| <code class="language-plaintext highlighter-rouge">groupadd</code> | 创建用户组 | - | <code class="language-plaintext highlighter-rouge">groupadd dev_team</code> |
| <code class="language-plaintext highlighter-rouge">groups</code> | 查看用户所属组 | - | <code class="language-plaintext highlighter-rouge">groups john</code> |</p>

<h4 id="2-权限控制进阶">2. 权限控制进阶</h4>
<h4 id="权限继承机制">权限继承机制</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod </span>g+s /shared_dir    <span class="c"># 设置目录的 SetGID 位，新文件继承父目录组</span>
setfacl <span class="nt">-m</span> u:tom:rwx file <span class="c"># 通过 ACL 给单独用户授权</span>
</code></pre></div></div>

<h4 id="特殊权限位">特殊权限位</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">SetUID</code>(4)：允许用户以文件所有者权限执行（如 <code class="language-plaintext highlighter-rouge">/usr/bin/passwd</code>）</li>
  <li><code class="language-plaintext highlighter-rouge">SetGID</code>(2)：目录中新文件继承组身份</li>
  <li><code class="language-plaintext highlighter-rouge">Sticky Bit</code>(1)：防删除位（如 <code class="language-plaintext highlighter-rouge">/tmp</code> 目录）</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod </span>4755 /usr/bin/myapp  <span class="c"># 设置 SetUID 位</span>
</code></pre></div></div>

<h3 id="补充三进程与系统监控">补充三：进程与系统监控</h3>
<h4 id="1-进程管理命令">1. 进程管理命令</h4>
<p>| <strong>命令</strong> | <strong>功能</strong> | <strong>场景</strong> |
| —- | —- | —- |
| <code class="language-plaintext highlighter-rouge">ps</code> | 查看进程快照 | <code class="language-plaintext highlighter-rouge">ps aux \| grep nginx</code> |
| <code class="language-plaintext highlighter-rouge">top</code> | 动态资源监控（类似任务管理器） | 按 <code class="language-plaintext highlighter-rouge">P</code> 按 CPU 排序，按 <code class="language-plaintext highlighter-rouge">M</code> 按内存排序 |
| <code class="language-plaintext highlighter-rouge">htop</code> | 增强版 top（需安装） | 支持鼠标操作、树状视图 |
| <code class="language-plaintext highlighter-rouge">kill</code> | 终止进程 | <code class="language-plaintext highlighter-rouge">kill -15 PID</code>（优雅停止） |
| <code class="language-plaintext highlighter-rouge">pkill</code> | 按进程名终止 | <code class="language-plaintext highlighter-rouge">pkill -f "python app.py"</code> |
| <code class="language-plaintext highlighter-rouge">nohup</code> | 后台运行并忽略挂断信号 | <code class="language-plaintext highlighter-rouge">nohup ./start.sh &amp;</code> |</p>

<h4 id="2-系统资源查看">2. 系统资源查看</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>free <span class="nt">-h</span>          <span class="c"># 查看内存使用（-h 人性化单位）</span>
<span class="nb">df</span> <span class="nt">-Th</span>           <span class="c"># 查看磁盘空间（-T 文件系统类型）</span>
<span class="nb">uptime</span>           <span class="c"># 系统运行时间及平均负载</span>
</code></pre></div></div>

<h3 id="补充四环境变量与启动配置">补充四：环境变量与启动配置</h3>
<h4 id="1-环境变量操作">1. 环境变量操作</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nv">$PATH</span>              <span class="c"># 查看 PATH 变量</span>
<span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span>/opt/jdk  <span class="c"># 临时设置变量</span>
<span class="nb">echo</span> <span class="s1">'export PATH=$PATH:/new_dir'</span> <span class="o">&gt;&gt;</span> ~/.bashrc  <span class="c"># 永久生效</span>
<span class="nb">source</span> ~/.bashrc        <span class="c"># 立即加载配置</span>
</code></pre></div></div>

<h4 id="2-开机启动项管理">2. 开机启动项管理</h4>
<ul>
  <li>Systemd 系统：<code class="language-plaintext highlighter-rouge">systemctl enable nginx</code></li>
  <li>传统 SysV：<code class="language-plaintext highlighter-rouge">update-rc.d apache2 defaults</code></li>
</ul>

<h3 id="补充五网络配置进阶">补充五：网络配置进阶</h3>
<h4 id="1-网络诊断工具">1. 网络诊断工具</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ss <span class="nt">-tunlp</span>            <span class="c"># 替代 netstat，查看端口占用</span>
tcpdump <span class="nt">-i</span> eth0 port 80  <span class="c"># 抓取 80 端口数据包</span>
mtr google.com       <span class="c"># 网络路由跟踪（结合 ping+traceroute）</span>
</code></pre></div></div>

<h4 id="2-防火墙深度配置">2. 防火墙深度配置</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 允许特定 IP 访问 22 端口</span>
firewall-cmd <span class="nt">--add-rich-rule</span><span class="o">=</span><span class="s1">'rule family="ipv4" source address="192.168.1.100" port port="22" protocol="tcp" accept'</span>
</code></pre></div></div>

<h3 id="补充六shell-脚本实战案例">补充六：Shell 脚本实战案例</h3>
<h4 id="自动备份脚本-backupsh">自动备份脚本 (<code class="language-plaintext highlighter-rouge">backup.sh</code>)</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c"># 定义变量</span>
<span class="nv">BACKUP_DIR</span><span class="o">=</span><span class="s2">"/backups"</span>
<span class="nv">DATE</span><span class="o">=</span><span class="si">$(</span><span class="nb">date</span> +%Y%m%d<span class="si">)</span>
<span class="nv">USER</span><span class="o">=</span><span class="s2">"mysql"</span>

<span class="c"># 创建备份目录</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$BACKUP_DIR</span>/<span class="nv">$DATE</span>

<span class="c"># 备份 MySQL 数据库</span>
mysqldump <span class="nt">-u</span> <span class="nv">$USER</span> <span class="nt">-p</span><span class="s1">'password'</span> mydb <span class="o">&gt;</span> <span class="nv">$BACKUP_DIR</span>/<span class="nv">$DATE</span>/mydb.sql

<span class="c"># 压缩并删除 7 天前备份</span>
<span class="nb">gzip</span> <span class="nv">$BACKUP_DIR</span>/<span class="nv">$DATE</span>/mydb.sql
find <span class="nv">$BACKUP_DIR</span> <span class="nt">-type</span> d <span class="nt">-mtime</span> +7 | xargs <span class="nb">rm</span> <span class="nt">-rf</span>
</code></pre></div></div>

<h3 id="附录">附录</h3>
<h4 id="1-linux-命令行常用快捷键">1. Linux 命令行常用快捷键</h4>
<p>| 快捷键 | 功能说明 |
| —- | —- |
| tab | 自动补全命令或路径 |
| Ctrl+a | 将光标移动到命令行行首 |
| Ctrl+e | 将光标移动到命令行行尾 |
| Ctrl+f | 将光标向右移动一个字符 |
| Ctrl+b | 将光标向左移动一个字符 |
| Ctrl+k | 剪切从光标到行尾的字符 |
| Ctrl+u | 剪切从光标到行首的字符 |
| Ctrl+w | 剪切光标前面的一个单词 |
| Ctrl+y | 复制剪切命名剪切的内容 |
| Ctrl+c | 中断正在执行的任务 |
| Ctrl+h | 删除光标前面的一个字符 |
| Ctrl+d | 退出当前命令行 |
| Ctrl+r | 搜索历史命令 |
| Ctrl+g | 退出历史命令搜索 |
| Ctrl+l | 清除屏幕上所有内容在屏幕的最上方开启一个新行 |
| Ctrl+s | 锁定终端使之暂时无法输入内容 |
| Ctrl+q | 退出终端锁定 |
| Ctrl+z | 将正在终端执行的任务停下来放到后台 |
| !! | 执行上一条命令 |
| !数字 | 执行数字对应的历史命令 |
| !字母 | 执行最近的以字母打头的命令 |
| !$ / Esc+. | 获得上一条命令最后一个参数 |
| Esc+b | 移动到当前单词的开头 |
| Esc+f | 移动到当前单词的结尾 |</p>

<h4 id="2-man-查阅命令手册的内容说明">2. man 查阅命令手册的内容说明</h4>
<p>| 手册中的标题 | 功能说明 |
| —- | —- |
| NAME | 命令的说明和介绍 |
| SYNOPSIS | 使用该命令的基本语法 |
| DESCRIPTION | 使用该命令的详细描述，各个参数的作用，有时候这些信息会出现在 OPTIONS 中 |
| OPTIONS | 命令相关参数选项的说明 |
| EXAMPLES | 使用该命令的参考例子 |
| EXIT STATUS | 命令结束的退出状态码，通常 0 表示成功执行 |
| SEE ALSO | 和命令相关的其他命令或信息 |
| BUGS | 和命令相关的缺陷的描述 |
| AUTHOR | 该命令的作者介绍 |</p>]]></content><author><name></name></author><category term="Linux" /><summary type="html"><![CDATA[Linux 学习笔记]]></summary></entry><entry><title type="html">Cpp学习笔记</title><link href="http://localhost:4000/blog/c++/2025/06/03/Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="Cpp学习笔记" /><published>2025-06-03T00:00:00+08:00</published><updated>2025-06-03T00:00:00+08:00</updated><id>http://localhost:4000/blog/c++/2025/06/03/Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/c++/2025/06/03/Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="c-学习笔记">C++ 学习笔记</h1>

<h2 id="一基础语法">一、基础语法</h2>
<p>基础语法是学习 C++ 的基石，它包括变量、数据类型、控制结构等基本元素。</p>

<h3 id="知识点">知识点</h3>
<ol>
  <li><strong>数据类型</strong>
    <ul>
      <li><strong>基本数据类型</strong>：如 <code class="language-plaintext highlighter-rouge">int</code>（整数类型）、<code class="language-plaintext highlighter-rouge">float</code>（单精度浮点类型）、<code class="language-plaintext highlighter-rouge">double</code>（双精度浮点类型）、<code class="language-plaintext highlighter-rouge">char</code>（字符类型）、<code class="language-plaintext highlighter-rouge">bool</code>（布尔类型）等。</li>
      <li><strong>复合数据类型</strong>：数组、结构体、枚举等。例如，数组可以存储相同类型的多个元素，结构体可以将不同类型的数据组合在一起。</li>
    </ul>
  </li>
  <li><strong>变量声明与初始化</strong>
    <ul>
      <li>声明变量时需要指定数据类型，如 <code class="language-plaintext highlighter-rouge">int num;</code> 声明了一个整数变量 <code class="language-plaintext highlighter-rouge">num</code>。</li>
      <li>初始化可以在声明时进行，如 <code class="language-plaintext highlighter-rouge">int num = 10;</code>，也可以使用构造函数初始化，如 <code class="language-plaintext highlighter-rouge">std::string str("Hello");</code>。</li>
    </ul>
  </li>
  <li><strong>控制结构</strong>
    <ul>
      <li><strong>条件语句</strong>：<code class="language-plaintext highlighter-rouge">if-else</code> 用于根据条件执行不同的代码块，<code class="language-plaintext highlighter-rouge">switch</code> 用于多分支选择。</li>
      <li><strong>循环语句</strong>：<code class="language-plaintext highlighter-rouge">for</code> 循环适用于已知循环次数的情况，<code class="language-plaintext highlighter-rouge">while</code> 循环和 <code class="language-plaintext highlighter-rouge">do-while</code> 循环适用于未知循环次数的情况。</li>
    </ul>
  </li>
  <li><strong>函数</strong>
    <ul>
      <li>函数的定义包括返回类型、函数名、参数列表和函数体。例如：
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>函数调用时需要传递相应的参数，如 <code class="language-plaintext highlighter-rouge">int result = add(3, 5);</code>。</li>
      <li>函数还支持默认参数、函数重载等特性。</li>
    </ul>
  </li>
</ol>

<h3 id="案例">案例</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">// 结构体定义</span>
<span class="k">struct</span> <span class="nc">Person</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 函数定义，使用默认参数</span>
<span class="kt">void</span> <span class="nf">printPerson</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">printAge</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Name: "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">printAge</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">", Age: "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 变量声明与初始化</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">3.14f</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">isTrue</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="c1">// 数组初始化</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

    <span class="c1">// 结构体初始化</span>
    <span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="p">{</span><span class="s">"John"</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span>

    <span class="c1">// 函数调用</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Add result: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">printPerson</span><span class="p">(</span><span class="n">person</span><span class="p">);</span>
    <span class="n">printPerson</span><span class="p">(</span><span class="n">person</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="c1">// 控制结构示例</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isTrue</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"It's true!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Array element: "</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="二异常处理">二、异常处理</h2>
<p>异常处理机制允许程序在运行时处理错误情况，避免程序崩溃。</p>

<h3 id="知识点-1">知识点</h3>
<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">try-catch</code> 块</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">try</code> 块中包含可能抛出异常的代码，<code class="language-plaintext highlighter-rouge">catch</code> 块用于捕获和处理异常。可以有多个 <code class="language-plaintext highlighter-rouge">catch</code> 块，分别处理不同类型的异常。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">throw</code> 语句</strong>
    <ul>
      <li>用于抛出异常，可以抛出内置类型或自定义异常类型。例如：<code class="language-plaintext highlighter-rouge">throw std::runtime_error("Something went wrong!");</code></li>
    </ul>
  </li>
  <li><strong>标准异常类</strong>
    <ul>
      <li>C++ 标准库提供了一系列异常类，如 <code class="language-plaintext highlighter-rouge">std::exception</code> 是所有标准异常类的基类，<code class="language-plaintext highlighter-rouge">std::runtime_error</code> 用于表示运行时错误，<code class="language-plaintext highlighter-rouge">std::logic_error</code> 用于表示逻辑错误等。</li>
    </ul>
  </li>
  <li><strong>自定义异常类</strong>
    <ul>
      <li>可以通过继承 <code class="language-plaintext highlighter-rouge">std::exception</code> 类来创建自定义异常类，并重写 <code class="language-plaintext highlighter-rouge">what()</code> 方法。</li>
    </ul>
  </li>
</ol>

<h3 id="案例-1">案例</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span>
<span class="c1">// 自定义异常类</span>
<span class="k">class</span> <span class="nc">DivideByZeroException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"Division by zero!"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">double</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 抛出自定义异常</span>
        <span class="k">throw</span> <span class="n">DivideByZeroException</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The result is: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">DivideByZeroException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 捕获自定义异常</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Exception caught: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 捕获其他标准异常</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Generic exception caught: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="三线程管理">三、线程管理</h2>
<p>C++11 引入了标准线程库，允许程序创建和管理多个线程。</p>

<h3 id="知识点-2">知识点</h3>
<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">std::thread</code> 类</strong>
    <ul>
      <li>用于创建和管理线程，可以通过构造函数传递可调用对象（函数、函数对象、Lambda 表达式等）和参数来创建线程。</li>
    </ul>
  </li>
  <li><strong>线程的创建和启动</strong>
    <ul>
      <li>例如：<code class="language-plaintext highlighter-rouge">std::thread t(func, args...);</code>，线程创建后会立即启动执行。</li>
    </ul>
  </li>
  <li><strong>线程的等待和分离</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">t.join()</code> 会阻塞当前线程，直到被等待的线程执行结束。</li>
      <li><code class="language-plaintext highlighter-rouge">t.detach()</code> 会使线程在后台独立运行，当前线程将失去对该线程的直接控制权。</li>
    </ul>
  </li>
  <li><strong>线程生命周期管理</strong>
    <ul>
      <li>需要确保对线程对象调用 <code class="language-plaintext highlighter-rouge">join</code> 或 <code class="language-plaintext highlighter-rouge">detach</code> 方法，否则在线程对象析构时会触发 <code class="language-plaintext highlighter-rouge">std::terminate</code> 函数，导致程序异常终止。可以使用 RAII 技术来管理线程资源。</li>
    </ul>
  </li>
</ol>

<h3 id="案例-2">案例</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span>
<span class="c1">// RAII 类用于管理线程资源</span>
<span class="k">class</span> <span class="nc">ThreadGuard</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">ThreadGuard</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">t_</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">ThreadGuard</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t_</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">t_</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">ThreadGuard</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadGuard</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">ThreadGuard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadGuard</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">t_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from thread!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">throwException</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Exception in thread!"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 创建并启动线程</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span>
    <span class="n">ThreadGuard</span> <span class="n">guard</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">throwException</span><span class="p">);</span>
        <span class="n">ThreadGuard</span> <span class="n">guard2</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Exception caught: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from main!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="四同步机制">四、同步机制</h2>
<p>同步机制用于协调多个线程的执行，避免数据竞争和不一致性。</p>

<h3 id="知识点-3">知识点</h3>
<ol>
  <li><strong>互斥锁（<code class="language-plaintext highlighter-rouge">std::mutex</code>）</strong>
    <ul>
      <li>用于保护共享资源，确保同一时间只有一个线程可以访问。<code class="language-plaintext highlighter-rouge">std::mutex</code> 是最基本的互斥量，<code class="language-plaintext highlighter-rouge">std::recursive_mutex</code> 允许同一个线程多次获取该锁。</li>
    </ul>
  </li>
  <li><strong>锁的获取和释放</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">std::lock_guard</code> 构造时自动加锁，析构时自动解锁，不支持手动释放锁。</li>
      <li><code class="language-plaintext highlighter-rouge">std::unique_lock</code> 比 <code class="language-plaintext highlighter-rouge">std::lock_guard</code> 更灵活，支持延迟加锁、手动解锁，还可以与条件变量配合使用。</li>
      <li><code class="language-plaintext highlighter-rouge">std::scoped_lock</code>（C++17）支持一次性获取多个锁，避免死锁问题。</li>
    </ul>
  </li>
  <li><strong>条件变量（<code class="language-plaintext highlighter-rouge">std::condition_variable</code>）</strong>
    <ul>
      <li>用于线程间的事件通知，通常与 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 配合使用。需要使用谓词循环检查来避免虚假唤醒。</li>
    </ul>
  </li>
  <li><strong>避免死锁</strong>
    <ul>
      <li>可以通过固定锁获取顺序、使用 <code class="language-plaintext highlighter-rouge">std::lock</code> 或 <code class="language-plaintext highlighter-rouge">std::scoped_lock</code>、避免持锁时调用用户代码等方法来避免死锁。</li>
    </ul>
  </li>
</ol>

<h3 id="案例-3">案例</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">shared_variable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">ready</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 自动获取和释放锁</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
        <span class="o">++</span><span class="n">shared_variable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
        <span class="n">ready</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">waitForReady</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[]{</span> <span class="k">return</span> <span class="n">ready</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Shared variable: "</span> <span class="o">&lt;&lt;</span> <span class="n">shared_variable</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">waitForReady</span><span class="p">);</span>

    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="五高级工具">五、高级工具</h2>
<p>高级工具提供了更强大和灵活的编程能力，如智能指针和函数对象。</p>

<h3 id="知识点-4">知识点</h3>
<ol>
  <li><strong>智能指针</strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">std::unique_ptr</code></strong>：独占所有权的智能指针，同一时间只能有一个 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 指向同一个对象。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">std::shared_ptr</code></strong>：共享所有权的智能指针，多个 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 可以指向同一个对象，通过引用计数来管理对象的生命周期。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">std::weak_ptr</code></strong>：弱引用智能指针，用于解决 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 的循环引用问题，它不增加引用计数。</li>
    </ul>
  </li>
  <li><strong>函数对象（<code class="language-plaintext highlighter-rouge">std::function</code>）</strong>
    <ul>
      <li>可以存储、复制和调用任何可调用对象，如函数、函数指针、函数对象、Lambda 表达式等。</li>
    </ul>
  </li>
  <li><strong>lambda 表达式</strong>
    <ul>
      <li>一种匿名函数，用于创建简洁的函数对象。可以捕获外部变量，分为值捕获和引用捕获。</li>
    </ul>
  </li>
</ol>

<h3 id="案例-4">案例</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span>
<span class="c1">// 函数对象类</span>
<span class="k">class</span> <span class="nc">Adder</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 智能指针</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">uniquePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Unique pointer value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">uniquePtr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sharedPtr1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sharedPtr2</span> <span class="o">=</span> <span class="n">sharedPtr1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Shared pointer use count: "</span> <span class="o">&lt;&lt;</span> <span class="n">sharedPtr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">weakPtr</span> <span class="o">=</span> <span class="n">sharedPtr1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">lockedPtr</span> <span class="o">=</span> <span class="n">weakPtr</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Weak pointer value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">lockedPtr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 函数对象</span>
    <span class="n">Adder</span> <span class="n">adder</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">func</span> <span class="o">=</span> <span class="n">adder</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Function object result: "</span> <span class="o">&lt;&lt;</span> <span class="n">func</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// lambda 表达式</span>
    <span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lambda result: "</span> <span class="o">&lt;&lt;</span> <span class="n">lambda</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">captureLambda</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Captured lambda result: "</span> <span class="o">&lt;&lt;</span> <span class="n">captureLambda</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="六原子操作">六、原子操作</h2>
<p>原子操作是不可分割的操作，用于在多线程环境中实现无锁编程。</p>

<h3 id="知识点-5">知识点</h3>
<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">std::atomic</code> 模板类</strong>
    <ul>
      <li>用于创建原子类型，如 <code class="language-plaintext highlighter-rouge">std::atomic&lt;int&gt;</code>、<code class="language-plaintext highlighter-rouge">std::atomic&lt;bool&gt;</code> 等。</li>
    </ul>
  </li>
  <li><strong>原子操作</strong>
    <ul>
      <li>如 <code class="language-plaintext highlighter-rouge">load()</code> 用于读取原子变量的值，<code class="language-plaintext highlighter-rouge">store()</code> 用于写入原子变量的值，<code class="language-plaintext highlighter-rouge">fetch_add()</code> 用于原子地增加变量的值等。</li>
    </ul>
  </li>
  <li><strong>内存顺序（Memory Order）</strong>
    <ul>
      <li>包括 <code class="language-plaintext highlighter-rouge">std::memory_order_relaxed</code>（仅保证原子性，没有顺序约束）、<code class="language-plaintext highlighter-rouge">std::memory_order_acquire</code>（读屏障）、<code class="language-plaintext highlighter-rouge">std::memory_order_release</code>（写屏障）、<code class="language-plaintext highlighter-rouge">std::memory_order_seq_cst</code>（顺序一致性，默认内存序）等。</li>
    </ul>
  </li>
</ol>

<h3 id="案例-5">案例</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atomic_variable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">atomic_increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">atomic_variable</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">atomic_increment</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">atomic_increment</span><span class="p">);</span>

    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Atomic variable: "</span> <span class="o">&lt;&lt;</span> <span class="n">atomic_variable</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="七并发结构">七、并发结构</h2>
<p>并发结构是为多线程环境设计的数据结构，提供高效的并发访问。</p>

<h3 id="知识点-6">知识点</h3>
<ol>
  <li><strong>并发队列（<code class="language-plaintext highlighter-rouge">std::queue</code> + 同步机制）</strong>
    <ul>
      <li>用于线程间的数据传递，需要使用互斥锁和条件变量来保证线程安全。</li>
    </ul>
  </li>
  <li><strong>并发哈希表</strong>
    <ul>
      <li>提供高效的并发查找和插入操作，可以使用细粒度锁或无锁算法来实现。</li>
    </ul>
  </li>
  <li><strong>基于锁的并发数据结构设计</strong>
    <ul>
      <li>如线程安全的栈、队列等，需要使用互斥锁来保护共享数据。</li>
    </ul>
  </li>
  <li><strong>无锁设计</strong>
    <ul>
      <li>如使用 CAS（Compare-And-Swap）操作实现无锁数据结构，避免锁带来的开销。</li>
    </ul>
  </li>
</ol>

<h3 id="案例-6">案例</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">ConcurrentQueue</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">queue_</span><span class="p">;</span>
    <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cond_var_</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx_</span><span class="p">);</span>
        <span class="n">queue_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
        <span class="n">cond_var_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx_</span><span class="p">);</span>
        <span class="n">cond_var_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
        <span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">queue_</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
        <span class="n">queue_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">ConcurrentQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Consumed: "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>

    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="八实战优化">八、实战优化</h2>
<p>实战优化涉及到如何在实际项目中应用上述知识，提高程序的性能和可靠性。</p>

<h3 id="知识点-7">知识点</h3>
<ol>
  <li><strong>性能分析</strong>
    <ul>
      <li>使用工具如 <code class="language-plaintext highlighter-rouge">gprof</code>、<code class="language-plaintext highlighter-rouge">valgrind</code> 等分析程序的性能瓶颈，找出耗时的函数和内存泄漏问题。</li>
    </ul>
  </li>
  <li><strong>并发算法优化</strong>
    <ul>
      <li>如并行排序、并行搜索等，可以使用 C++17 引入的并行算法库来实现。</li>
    </ul>
  </li>
  <li><strong>内存管理优化</strong>
    <ul>
      <li>合理使用智能指针和内存池，避免频繁的内存分配和释放带来的开销。</li>
    </ul>
  </li>
  <li><strong>线程池与工作窃取</strong>
    <ul>
      <li>线程池可以避免频繁创建和销毁线程的开销，提高性能。工作窃取算法可以提高线程的利用率。</li>
    </ul>
  </li>
</ol>

<h3 id="案例-7">案例</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;execution&gt;</span><span class="cp">
</span>
<span class="c1">// 并行求和函数</span>
<span class="kt">int</span> <span class="nf">parallel_sum</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">parallel_sum</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Sum: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="C++" /><summary type="html"><![CDATA[C++ 学习笔记]]></summary></entry><entry><title type="html">Java学习笔记</title><link href="http://localhost:4000/blog/java/2025/06/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="Java学习笔记" /><published>2025-06-03T00:00:00+08:00</published><updated>2025-06-03T00:00:00+08:00</updated><id>http://localhost:4000/blog/java/2025/06/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/java/2025/06/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="java学习笔记">Java学习笔记</h1>

<h3 id="一java基础-core-java">一、Java基础 (Core Java)</h3>

<h4 id="1-语法基础">1. 语法基础</h4>
<ul>
  <li><strong>数据类型</strong>：Java有基本数据类型（如<code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">char</code>等）和引用数据类型（如类、接口、数组）。</li>
  <li><strong>变量</strong>：用于存储数据的容器，使用前需声明并赋值。</li>
  <li><strong>运算符</strong>：如算术运算符（<code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>）、逻辑运算符（<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, <code class="language-plaintext highlighter-rouge">||</code>, <code class="language-plaintext highlighter-rouge">!</code>）等。</li>
  <li><strong>流程控制</strong>：包括<code class="language-plaintext highlighter-rouge">if/else</code>, <code class="language-plaintext highlighter-rouge">switch</code>, <code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">while</code>, <code class="language-plaintext highlighter-rouge">do-while</code>等语句，用于控制程序的执行流程。</li>
  <li><strong>数组</strong>：用于存储相同类型数据的有序集合。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SyntaxBasics</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 数据类型和变量</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">'A'</span><span class="o">;</span>

        <span class="c1">// 运算符</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">5</span><span class="o">;</span>

        <span class="c1">// 流程控制</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result is greater than 15"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result is less than or equal to 15"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 数组</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="2-面向对象编程oop">2. 面向对象编程(OOP)</h4>
<ul>
  <li><strong>核心概念</strong>
    <ul>
      <li><strong>类与对象</strong>：类是对象的抽象，对象是类的实例。</li>
      <li><strong>封装</strong>：将数据和操作数据的方法绑定在一起，隐藏对象的内部实现细节。</li>
      <li><strong>继承</strong>：子类继承父类的属性和方法，实现代码复用。</li>
      <li><strong>多态</strong>：同一个方法可以根据对象的不同类型表现出不同的行为。</li>
      <li><strong>抽象</strong>：抽象类和接口用于定义抽象方法，强制子类实现。</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 抽象类</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Animal</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 子类</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Dog</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">" says Woof!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OOPExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Buddy"</span><span class="o">);</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-常用类库">3. 常用类库</h4>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Object</code>类</strong>：所有类的父类，提供了<code class="language-plaintext highlighter-rouge">toString()</code>, <code class="language-plaintext highlighter-rouge">equals()</code>, <code class="language-plaintext highlighter-rouge">hashCode()</code>等方法。</li>
  <li><strong>字符串</strong>：<code class="language-plaintext highlighter-rouge">String</code>是不可变的，<code class="language-plaintext highlighter-rouge">StringBuilder</code>和<code class="language-plaintext highlighter-rouge">StringBuffer</code>是可变的，<code class="language-plaintext highlighter-rouge">StringBuffer</code>是线程安全的。</li>
  <li><strong>包装类</strong>：将基本数据类型封装成对象，支持自动装箱和拆箱。</li>
  <li><strong>日期时间API</strong>：Java 8引入的<code class="language-plaintext highlighter-rouge">java.time</code>包提供了更方便的日期时间处理类。</li>
  <li><strong>异常处理</strong>：使用<code class="language-plaintext highlighter-rouge">try-catch-finally</code>块捕获和处理异常，也可以使用<code class="language-plaintext highlighter-rouge">try-with-resources</code>自动关闭资源。</li>
  <li><strong>泛型</strong>：提供类型安全，消除强制类型转换。</li>
  <li><strong>反射</strong>：在运行时获取类的信息，动态创建对象、调用方法和访问字段。</li>
  <li><strong>注解</strong>：为代码提供元数据，可用于编译时检查、运行时处理等。</li>
  <li><strong>I/O流</strong>：用于读写数据，分为字节流和字符流。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.FileReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.time.LocalDate</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="c1">// 注解</span>
<span class="nd">@interface</span> <span class="nc">MyAnnotation</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 使用注解</span>
<span class="nd">@MyAnnotation</span><span class="o">(</span><span class="s">"Test Annotation"</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printMessage</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CommonLibraryExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Object类</span>
        <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>

        <span class="c1">// 字符串</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">" World"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>

        <span class="c1">// 包装类</span>
        <span class="nc">Integer</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">// 自动装箱</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span> <span class="c1">// 自动拆箱</span>

        <span class="c1">// 日期时间API</span>
        <span class="nc">LocalDate</span> <span class="n">today</span> <span class="o">=</span> <span class="nc">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Today: "</span> <span class="o">+</span> <span class="n">today</span><span class="o">);</span>

        <span class="c1">// 异常处理</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">FileReader</span> <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"test.txt"</span><span class="o">))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">data</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">data</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">data</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 泛型</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 反射</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">MyClass</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
            <span class="nc">Object</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">().</span><span class="na">newInstance</span><span class="o">();</span>
            <span class="nc">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"printMessage"</span><span class="o">);</span>
            <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 注解</span>
        <span class="nc">MyClass</span> <span class="n">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">();</span>
        <span class="nc">MyAnnotation</span> <span class="n">annotation</span> <span class="o">=</span> <span class="n">myClass</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">MyAnnotation</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">annotation</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Annotation value: "</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="二java集合框架-java-collections-framework">二、Java集合框架 (Java Collections Framework)</h3>

<h4 id="1-核心接口">1. 核心接口</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Collection</code>：是所有集合的根接口，定义了集合的基本操作。</li>
  <li><code class="language-plaintext highlighter-rouge">List</code>：有序集合，允许重复元素。</li>
  <li><code class="language-plaintext highlighter-rouge">Set</code>：无序集合，不允许重复元素。</li>
  <li><code class="language-plaintext highlighter-rouge">Queue</code>/<code class="language-plaintext highlighter-rouge">Deque</code>：队列和双端队列，用于实现先进先出（FIFO）或后进先出（LIFO）的操作。</li>
  <li><code class="language-plaintext highlighter-rouge">Map</code>：键值对的集合，键是唯一的。</li>
</ul>

<h4 id="2-常用实现类">2. 常用实现类</h4>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">List</code></strong>：<code class="language-plaintext highlighter-rouge">ArrayList</code>基于数组实现，随机访问快；<code class="language-plaintext highlighter-rouge">LinkedList</code>基于双向链表实现，插入删除快。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Set</code></strong>：<code class="language-plaintext highlighter-rouge">HashSet</code>基于<code class="language-plaintext highlighter-rouge">HashMap</code>实现，无序；<code class="language-plaintext highlighter-rouge">TreeSet</code>基于红黑树实现，有序。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Queue</code>/<code class="language-plaintext highlighter-rouge">Deque</code></strong>：<code class="language-plaintext highlighter-rouge">LinkedList</code>可作为队列和双端队列使用；<code class="language-plaintext highlighter-rouge">PriorityQueue</code>是优先队列。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Map</code></strong>：<code class="language-plaintext highlighter-rouge">HashMap</code>基于数组+链表/红黑树实现，重点掌握其原理、哈希冲突和扩容；<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>是线程安全的。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CollectionExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// List</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Cherry"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"List: "</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>

        <span class="c1">// Set</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span> <span class="c1">// 重复元素不会被添加</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Set: "</span> <span class="o">+</span> <span class="n">set</span><span class="o">);</span>

        <span class="c1">// Queue</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">);</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Cherry"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Queue: "</span> <span class="o">+</span> <span class="n">queue</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Poll: "</span> <span class="o">+</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>

        <span class="c1">// Map</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Cherry"</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Map: "</span> <span class="o">+</span> <span class="n">map</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-工具类">3. 工具类</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Collections</code>：提供了排序、查找、同步包装等方法。</li>
  <li><code class="language-plaintext highlighter-rouge">Arrays</code>：提供了操作数组的方法，如排序、查找等。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CollectionUtilsExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Collections工具类</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sorted list: "</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>

        <span class="c1">// Arrays工具类</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sorted array: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="4-关键知识点">4. 关键知识点</h4>
<ul>
  <li><strong>迭代器</strong>：用于遍历集合元素。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fail-fast</code>机制与<code class="language-plaintext highlighter-rouge">fail-safe</code>机制</strong>：<code class="language-plaintext highlighter-rouge">fail-fast</code>在集合结构发生变化时会抛出<code class="language-plaintext highlighter-rouge">ConcurrentModificationException</code>；<code class="language-plaintext highlighter-rouge">fail-safe</code>则不会。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Comparable</code>与<code class="language-plaintext highlighter-rouge">Comparator</code>接口</strong>：用于定义对象的排序规则。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Iterator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Person</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="na">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s">" ("</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CollectionKeyPointsExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 迭代器</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Cherry"</span><span class="o">);</span>
        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="c1">// Comparable接口</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">,</span> <span class="mi">25</span><span class="o">));</span>
        <span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">,</span> <span class="mi">20</span><span class="o">));</span>
        <span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Charlie"</span><span class="o">,</span> <span class="mi">30</span><span class="o">));</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sorted people: "</span> <span class="o">+</span> <span class="n">people</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="三java并发编程-java-concurrencymultithreading">三、Java并发编程 (Java Concurrency/Multithreading)</h3>

<h4 id="1-核心概念">1. 核心概念</h4>
<ul>
  <li><strong>进程 vs 线程</strong>：进程是程序在操作系统中的一次执行过程，线程是进程中的一个执行单元。</li>
  <li><strong>线程生命周期/状态</strong>：包括<code class="language-plaintext highlighter-rouge">NEW</code>, <code class="language-plaintext highlighter-rouge">RUNNABLE</code>, <code class="language-plaintext highlighter-rouge">BLOCKED</code>, <code class="language-plaintext highlighter-rouge">WAITING</code>, <code class="language-plaintext highlighter-rouge">TIMED_WAITING</code>, <code class="language-plaintext highlighter-rouge">TERMINATED</code>。</li>
  <li><strong>上下文切换</strong>：操作系统在多个线程之间切换执行上下文。</li>
</ul>

<h4 id="2-线程创建与使用">2. 线程创建与使用</h4>
<ul>
  <li><strong>继承<code class="language-plaintext highlighter-rouge">Thread</code>类</strong>：重写<code class="language-plaintext highlighter-rouge">run()</code>方法。</li>
  <li><strong>实现<code class="language-plaintext highlighter-rouge">Runnable</code>接口</strong>：实现<code class="language-plaintext highlighter-rouge">run()</code>方法。</li>
  <li><strong>实现<code class="language-plaintext highlighter-rouge">Callable</code>接口 + <code class="language-plaintext highlighter-rouge">Future</code>/<code class="language-plaintext highlighter-rouge">FutureTask</code></strong>：可返回结果。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span>

<span class="c1">// 继承Thread类</span>
<span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread is running: "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 实现Runnable接口</span>
<span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Runnable is running: "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 实现Callable接口</span>
<span class="kd">class</span> <span class="nc">MyCallable</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Callable result"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadCreationExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="c1">// 继承Thread类</span>
        <span class="nc">MyThread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">// 实现Runnable接口</span>
        <span class="nc">MyRunnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">runnableThread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
        <span class="n">runnableThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">// 实现Callable接口</span>
        <span class="nc">MyCallable</span> <span class="n">callable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyCallable</span><span class="o">();</span>
        <span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newSingleThreadExecutor</span><span class="o">();</span>
        <span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">callable</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Callable result: "</span> <span class="o">+</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-线程池">3. 线程池</h4>
<ul>
  <li><strong>核心原理</strong>：<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>及其核心参数（核心线程数、最大线程数、工作队列、拒绝策略、线程工厂、存活时间）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Executors</code>工厂类</strong>：常用但不推荐在生产环境直接使用，推荐手动创建<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadPoolExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ThreadPoolExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span>
                <span class="mi">2</span><span class="o">,</span> <span class="c1">// 核心线程数</span>
                <span class="mi">5</span><span class="o">,</span> <span class="c1">// 最大线程数</span>
                <span class="mi">60</span><span class="o">,</span> <span class="c1">// 线程存活时间</span>
                <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
                <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;&gt;(</span><span class="mi">10</span><span class="o">),</span> <span class="c1">// 工作队列</span>
                <span class="nc">Executors</span><span class="o">.</span><span class="na">defaultThreadFactory</span><span class="o">(),</span> <span class="c1">// 线程工厂</span>
                <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">.</span><span class="na">AbortPolicy</span><span class="o">()</span> <span class="c1">// 拒绝策略</span>
        <span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">taskId</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Task "</span> <span class="o">+</span> <span class="n">taskId</span> <span class="o">+</span> <span class="s">" is running on thread: "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">});</span>
        <span class="o">}</span>

        <span class="n">executor</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="4-线程同步与通信">4. 线程同步与通信</h4>
<ul>
  <li><strong>锁机制</strong>：<code class="language-plaintext highlighter-rouge">synchronized</code>关键字和<code class="language-plaintext highlighter-rouge">Lock</code>接口及其实现（如<code class="language-plaintext highlighter-rouge">ReentrantLock</code>）。</li>
  <li><strong>原子类</strong>：<code class="language-plaintext highlighter-rouge">java.util.concurrent.atomic</code>包中的类，基于<code class="language-plaintext highlighter-rouge">CAS</code>实现。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">volatile</code>关键字</strong>：保证可见性和禁止指令重排序。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ThreadLocal</code></strong>：线程局部变量。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.atomic.AtomicInteger</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="c1">// 锁机制</span>
<span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 原子类</span>
<span class="kd">class</span> <span class="nc">AtomicCounter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">AtomicInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// volatile关键字</span>
<span class="kd">class</span> <span class="nc">VolatileExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFlag</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">getFlag</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// ThreadLocal</span>
<span class="kd">class</span> <span class="nc">ThreadLocalExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">threadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">threadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">removeValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">threadLocal</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadSynchronizationExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="c1">// 锁机制</span>
        <span class="nc">Counter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Counter</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Counter value: "</span> <span class="o">+</span> <span class="n">counter</span><span class="o">.</span><span class="na">getCount</span><span class="o">());</span>

        <span class="c1">// 原子类</span>
        <span class="nc">AtomicCounter</span> <span class="n">atomicCounter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicCounter</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">t3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">atomicCounter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">t4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">atomicCounter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">t3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t4</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t3</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">t4</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Atomic counter value: "</span> <span class="o">+</span> <span class="n">atomicCounter</span><span class="o">.</span><span class="na">getCount</span><span class="o">());</span>

        <span class="c1">// volatile关键字</span>
        <span class="nc">VolatileExample</span> <span class="n">volatileExample</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VolatileExample</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">t5</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">volatileExample</span><span class="o">.</span><span class="na">setFlag</span><span class="o">();</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">t6</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">volatileExample</span><span class="o">.</span><span class="na">getFlag</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// 等待</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Flag is set to true"</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="n">t5</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t6</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t5</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">t6</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>

        <span class="c1">// ThreadLocal</span>
        <span class="nc">Thread</span> <span class="n">t7</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">ThreadLocalExample</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 7 value: "</span> <span class="o">+</span> <span class="nc">ThreadLocalExample</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
            <span class="nc">ThreadLocalExample</span><span class="o">.</span><span class="na">removeValue</span><span class="o">();</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">t8</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">ThreadLocalExample</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 8 value: "</span> <span class="o">+</span> <span class="nc">ThreadLocalExample</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
            <span class="nc">ThreadLocalExample</span><span class="o">.</span><span class="na">removeValue</span><span class="o">();</span>
        <span class="o">});</span>
        <span class="n">t7</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t8</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t7</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">t8</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="5-并发工具类">5. 并发工具类</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CountDownLatch</code>：倒计时门闩，一个或多个线程等待其他线程完成操作。</li>
  <li><code class="language-plaintext highlighter-rouge">CyclicBarrier</code>：循环栅栏，一组线程互相等待到达某个屏障点。</li>
  <li><code class="language-plaintext highlighter-rouge">Semaphore</code>：信号量，控制同时访问特定资源的线程数。</li>
  <li><code class="language-plaintext highlighter-rouge">Exchanger</code>：线程间交换数据。</li>
  <li><code class="language-plaintext highlighter-rouge">Phaser</code>：更灵活的屏障（Java 7+）。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcurrentUtilsExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="c1">// CountDownLatch</span>
        <span class="nc">CountDownLatch</span> <span class="n">latch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CountDownLatch</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">taskId</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Task "</span> <span class="o">+</span> <span class="n">taskId</span> <span class="o">+</span> <span class="s">" is running"</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Task "</span> <span class="o">+</span> <span class="n">taskId</span> <span class="o">+</span> <span class="s">" is completed"</span><span class="o">);</span>
                <span class="n">latch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
            <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">latch</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"All tasks are completed"</span><span class="o">);</span>

        <span class="c1">// CyclicBarrier</span>
        <span class="nc">CyclicBarrier</span> <span class="n">barrier</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CyclicBarrier</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"All threads reached the barrier"</span><span class="o">));</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">taskId</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread "</span> <span class="o">+</span> <span class="n">taskId</span> <span class="o">+</span> <span class="s">" is waiting at the barrier"</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">barrier</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="o">|</span> <span class="nc">BrokenBarrierException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread "</span> <span class="o">+</span> <span class="n">taskId</span> <span class="o">+</span> <span class="s">" passed the barrier"</span><span class="o">);</span>
            <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Semaphore</span>
        <span class="nc">Semaphore</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Semaphore</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">taskId</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">semaphore</span><span class="o">.</span><span class="na">acquire</span><span class="o">();</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Task "</span> <span class="o">+</span> <span class="n">taskId</span> <span class="o">+</span> <span class="s">" acquired the semaphore"</span><span class="o">);</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">semaphore</span><span class="o">.</span><span class="na">release</span><span class="o">();</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Task "</span> <span class="o">+</span> <span class="n">taskId</span> <span class="o">+</span> <span class="s">" released the semaphore"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// Exchanger</span>
        <span class="nc">Exchanger</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">exchanger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Exchanger</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Data from Thread 1"</span><span class="o">;</span>
                <span class="nc">String</span> <span class="n">receivedData</span> <span class="o">=</span> <span class="n">exchanger</span><span class="o">.</span><span class="na">exchange</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 1 received: "</span> <span class="o">+</span> <span class="n">receivedData</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Data from Thread 2"</span><span class="o">;</span>
                <span class="nc">String</span> <span class="n">receivedData</span> <span class="o">=</span> <span class="n">exchanger</span><span class="o">.</span><span class="na">exchange</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 2 received: "</span> <span class="o">+</span> <span class="n">receivedData</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="6-并发集合">6. 并发集合</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>：线程安全的哈希表。</li>
  <li><code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList</code>/<code class="language-plaintext highlighter-rouge">CopyOnWriteArraySet</code>：线程安全的列表和集合。</li>
  <li><code class="language-plaintext highlighter-rouge">BlockingQueue</code>及其实现类：用于线程间的阻塞队列。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.BlockingQueue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ConcurrentHashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.CopyOnWriteArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.LinkedBlockingQueue</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcurrentCollectionExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ConcurrentHashMap</span>
        <span class="nc">ConcurrentHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ConcurrentHashMap: "</span> <span class="o">+</span> <span class="n">map</span><span class="o">);</span>

        <span class="c1">// CopyOnWriteArrayList</span>
        <span class="nc">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"CopyOnWriteArrayList: "</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>

        <span class="c1">// BlockingQueue</span>
        <span class="nc">BlockingQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;&gt;();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"BlockingQueue: "</span> <span class="o">+</span> <span class="n">queue</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Poll: "</span> <span class="o">+</span> <span class="n">queue</span><span class="o">.</span><span class="na">take</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="7-aqs">7. <code class="language-plaintext highlighter-rouge">AQS</code></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code>：是<code class="language-plaintext highlighter-rouge">ReentrantLock</code>、<code class="language-plaintext highlighter-rouge">CountDownLatch</code>、<code class="language-plaintext highlighter-rouge">Semaphore</code>等众多同步器的基础框架。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="o">;</span>

<span class="c1">// 自定义同步器</span>
<span class="kd">class</span> <span class="nc">MySync</span> <span class="kd">extends</span> <span class="nc">AbstractQueuedSynchronizer</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getState</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">setState</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 自定义锁</span>
<span class="kd">class</span> <span class="nc">MyLock</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MySync</span> <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MySync</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sync</span><span class="o">.</span><span class="na">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AQSExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyLock</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 1 acquired the lock"</span><span class="o">);</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 1 released the lock"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 2 acquired the lock"</span><span class="o">);</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 2 released the lock"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="8-forkjoin框架">8. <code class="language-plaintext highlighter-rouge">Fork/Join</code>框架</h4>
<ul>
  <li>用于并行执行任务（分治思想）。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.ForkJoinPool</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.RecursiveTask</span><span class="o">;</span>

<span class="c1">// 计算数组元素之和</span>
<span class="kd">class</span> <span class="nc">SumTask</span> <span class="kd">extends</span> <span class="nc">RecursiveTask</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THRESHOLD</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">SumTask</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="nc">Integer</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="no">THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="nc">SumTask</span> <span class="n">leftTask</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumTask</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
            <span class="nc">SumTask</span> <span class="n">rightTask</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumTask</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>

            <span class="n">leftTask</span><span class="o">.</span><span class="na">fork</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">rightResult</span> <span class="o">=</span> <span class="n">rightTask</span><span class="o">.</span><span class="na">compute</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">leftResult</span> <span class="o">=</span> <span class="n">leftTask</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>

            <span class="k">return</span> <span class="n">leftResult</span> <span class="o">+</span> <span class="n">rightResult</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ForkJoinExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">ForkJoinPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ForkJoinPool</span><span class="o">();</span>
        <span class="nc">SumTask</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumTask</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sum: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="9-completablefuture">9. <code class="language-plaintext highlighter-rouge">CompletableFuture</code></h4>
<ul>
  <li>强大的异步编程工具（Java 8+），支持链式调用、组合异步操作、处理结果和异常。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.CompletableFuture</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutionException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CompletableFutureExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="c1">// 异步任务</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="s">"Hello"</span><span class="o">;</span>
        <span class="o">});</span>

        <span class="c1">// 链式调用</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">combinedFuture</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" World"</span><span class="o">)</span>
                                                        <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">);</span>

        <span class="c1">// 获取结果</span>
        <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">combinedFuture</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="四java虚拟机-java-virtual-machine---jvm">四、Java虚拟机 (Java Virtual Machine - JVM)</h3>

<h4 id="1-内存区域运行时数据区">1. 内存区域（运行时数据区）</h4>
<ul>
  <li><strong>程序计数器</strong>：记录当前线程执行的字节码行号。</li>
  <li><strong>虚拟机栈</strong>：每个方法执行时会创建一个栈帧，包含局部变量表、操作数栈、动态链接、方法出口等信息。</li>
  <li><strong>本地方法栈</strong>：与虚拟机栈类似，用于执行本地方法。</li>
  <li><strong>堆</strong>：是Java对象存储的主要区域，也是垃圾回收的主要区域。</li>
  <li><strong>方法区</strong>：存储类信息、常量、静态变量等，JDK 8+为元空间（Metaspace）。</li>
  <li><strong>运行时常量池</strong>：是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。</li>
</ul>

<h4 id="2-垃圾回收-garbage-collection---gc">2. 垃圾回收 (Garbage Collection - GC)</h4>
<ul>
  <li><strong>对象存活性判断</strong>：Java采用可达性分析算法，通过一系列的GC Roots对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</li>
  <li><strong>引用类型</strong>：包括强引用、软引用、弱引用和虚引用。</li>
  <li><strong>GC算法</strong>：标记-清除、标记-复制、标记-整理、分代收集理论。</li>
  <li><strong>垃圾收集器</strong>：不同的垃圾收集器适用于不同的场景，如新生代收集器（<code class="language-plaintext highlighter-rouge">Serial</code>, <code class="language-plaintext highlighter-rouge">ParNew</code>, <code class="language-plaintext highlighter-rouge">Parallel Scavenge</code>）、老年代收集器（<code class="language-plaintext highlighter-rouge">Serial Old</code>, <code class="language-plaintext highlighter-rouge">Parallel Old</code>, <code class="language-plaintext highlighter-rouge">CMS</code>）、整堆收集器（<code class="language-plaintext highlighter-rouge">G1</code>, <code class="language-plaintext highlighter-rouge">ZGC</code>, <code class="language-plaintext highlighter-rouge">Shenandoah</code>）。</li>
  <li><strong>GC日志分析</strong>：通过设置JVM参数（如<code class="language-plaintext highlighter-rouge">-Xlog:gc*</code>或<code class="language-plaintext highlighter-rouge">-XX:+PrintGCDetails</code>）可以查看GC日志，分析GC的性能。</li>
  <li><strong>内存分配与回收策略</strong>：对象优先在Eden区分配、大对象直接进入老年代、长期存活对象进入老年代、动态对象年龄判定、空间分配担保。</li>
</ul>

<h4 id="3-类加载机制-class-loading">3. 类加载机制 (Class Loading)</h4>
<ul>
  <li><strong>过程</strong>：加载（Loading） -&gt; 链接（Linking：验证、准备、解析） -&gt; 初始化（Initialization）。</li>
  <li><strong>类加载器</strong>：包括启动类加载器（<code class="language-plaintext highlighter-rouge">Bootstrap ClassLoader</code>）、扩展类加载器（<code class="language-plaintext highlighter-rouge">Extension ClassLoader</code>）、应用程序类加载器（<code class="language-plaintext highlighter-rouge">Application ClassLoader</code>/<code class="language-plaintext highlighter-rouge">System ClassLoader</code>）和自定义类加载器。</li>
  <li><strong>双亲委派模型(Parent Delegation Model)</strong>：原理是当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。作用是避免重复加载和保证核心类的安全。</li>
</ul>

<h4 id="4-jvm性能监控与调优">4. JVM性能监控与调优</h4>
<ul>
  <li><strong>常用命令行工具</strong>：<code class="language-plaintext highlighter-rouge">jps</code>, <code class="language-plaintext highlighter-rouge">jstat</code>, <code class="language-plaintext highlighter-rouge">jinfo</code>, <code class="language-plaintext highlighter-rouge">jmap</code>, <code class="language-plaintext highlighter-rouge">jstack</code>, <code class="language-plaintext highlighter-rouge">jcmd</code>等。</li>
  <li><strong>图形化工具</strong>：<code class="language-plaintext highlighter-rouge">JConsole</code>, <code class="language-plaintext highlighter-rouge">VisualVM</code>, <code class="language-plaintext highlighter-rouge">Java Mission Control</code> (JMC)等。</li>
  <li><strong>内存分析工具</strong>：<code class="language-plaintext highlighter-rouge">MAT</code> (Eclipse Memory Analyzer Tool), <code class="language-plaintext highlighter-rouge">JProfiler</code>等。</li>
  <li><strong>调优目标</strong>：减少GC停顿时间、提高吞吐量、控制内存占用。</li>
  <li><strong>常见参数</strong>：堆内存设置（<code class="language-plaintext highlighter-rouge">-Xms</code>, <code class="language-plaintext highlighter-rouge">-Xmx</code>）、新生代/老年代比例（<code class="language-plaintext highlighter-rouge">-XX:NewRatio</code>）、Eden/Survivor比例（<code class="language-plaintext highlighter-rouge">-XX:SurvivorRatio</code>）、元空间设置（<code class="language-plaintext highlighter-rouge">-XX:MetaspaceSize</code>, <code class="language-plaintext highlighter-rouge">-XX:MaxMetaspaceSize</code>）、选择垃圾收集器（<code class="language-plaintext highlighter-rouge">-XX:+UseG1GC</code>, <code class="language-plaintext highlighter-rouge">-XX:+UseZGC</code>等）、GC日志相关参数。</li>
</ul>

<h4 id="5-java内存模型-java-memory-model---jmm">5. Java内存模型 (Java Memory Model - JMM)</h4>
<ul>
  <li><strong>主内存与工作内存</strong>：主内存是所有线程共享的，工作内存是每个线程独有的，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。</li>
  <li><strong>内存间交互操作</strong>：包括<code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">use</code>, <code class="language-plaintext highlighter-rouge">assign</code>, <code class="language-plaintext highlighter-rouge">store</code>, <code class="language-plaintext highlighter-rouge">write</code>, <code class="language-plaintext highlighter-rouge">lock</code>, <code class="language-plaintext highlighter-rouge">unlock</code>等。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">volatile</code>的特殊规则</strong>：保证可见性和禁止指令重排序，但不保证原子性。</li>
  <li><strong>原子性、可见性、有序性</strong>：是并发编程中的三个重要特性。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">happens-before</code>原则</strong>：用于判断一个操作是否对另一个操作可见。</li>
</ul>

<h3 id="五数据库-database">五、数据库 (Database)</h3>

<h4 id="1-sql基础">1. SQL基础</h4>
<ul>
  <li><strong>DDL（数据定义语言）</strong>：用于定义数据库对象，如<code class="language-plaintext highlighter-rouge">CREATE</code>, <code class="language-plaintext highlighter-rouge">ALTER</code>, <code class="language-plaintext highlighter-rouge">DROP</code>等。</li>
  <li><strong>DML（数据操作语言）</strong>：用于操作数据库中的数据，如<code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>等。</li>
  <li><strong>DQL（数据查询语言）</strong>：用于查询数据库中的数据，如<code class="language-plaintext highlighter-rouge">SELECT</code>。</li>
  <li><strong>DCL（数据控制语言）</strong>：用于控制数据库的访问权限，如<code class="language-plaintext highlighter-rouge">GRANT</code>, <code class="language-plaintext highlighter-rouge">REVOKE</code>等。</li>
  <li><strong>TCL（事务控制语言）</strong>：用于管理数据库事务，如<code class="language-plaintext highlighter-rouge">COMMIT</code>, <code class="language-plaintext highlighter-rouge">ROLLBACK</code>等。</li>
</ul>

<h4 id="2-jdbc-java-database-connectivity">2. JDBC (Java Database Connectivity)</h4>
<ul>
  <li><strong>核心接口</strong>：包括<code class="language-plaintext highlighter-rouge">Driver</code>, <code class="language-plaintext highlighter-rouge">Connection</code>, <code class="language-plaintext highlighter-rouge">Statement</code>, <code class="language-plaintext highlighter-rouge">PreparedStatement</code>, <code class="language-plaintext highlighter-rouge">CallableStatement</code>, <code class="language-plaintext highlighter-rouge">ResultSet</code>等。</li>
  <li><strong>使用步骤</strong>：注册驱动、获取连接、创建语句对象、执行SQL、处理结果集、关闭资源。</li>
  <li><strong>事务管理</strong>：通过<code class="language-plaintext highlighter-rouge">Connection</code>对象的<code class="language-plaintext highlighter-rouge">setAutoCommit()</code>、<code class="language-plaintext highlighter-rouge">commit()</code>和<code class="language-plaintext highlighter-rouge">rollback()</code>方法来管理事务。</li>
  <li><strong>连接池原理与使用</strong>：连接池可以减少数据库连接的创建和销毁开销，提高性能。常见的连接池实现有<code class="language-plaintext highlighter-rouge">HikariCP</code>, <code class="language-plaintext highlighter-rouge">Druid</code>等。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.sql.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JDBCExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost:3306/test"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"root"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"password"</span><span class="o">;</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
             <span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span>
             <span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="s">"SELECT * FROM users"</span><span class="o">))</span> <span class="o">{</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ID: "</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">", Name: "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-orm框架">3. ORM框架</h4>
<ul>
  <li><strong>MyBatis</strong>
    <ul>
      <li><strong>核心概念</strong>：包括<code class="language-plaintext highlighter-rouge">SqlSessionFactory</code>, <code class="language-plaintext highlighter-rouge">SqlSession</code>, <code class="language-plaintext highlighter-rouge">Mapper</code>接口/XML等。</li>
      <li><strong>动态SQL</strong>：可以根据不同的条件生成不同的SQL语句。</li>
      <li><strong>缓存机制</strong>：包括一级缓存（基于<code class="language-plaintext highlighter-rouge">SqlSession</code>）和二级缓存（基于<code class="language-plaintext highlighter-rouge">Mapper</code>）。</li>
      <li><strong>插件开发</strong>：可以通过实现<code class="language-plaintext highlighter-rouge">Interceptor</code>接口来开发插件。</li>
      <li><strong>与Spring集成</strong>：可以通过Spring来管理MyBatis的组件。</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.apache.ibatis.io.Resources</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.ibatis.session.SqlSession</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.ibatis.session.SqlSessionFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.ibatis.session.SqlSessionFactoryBuilder</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>

<span class="c1">// 实体类</span>
<span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setId</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"User{id="</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">", name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"'}"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Mapper接口</span>
<span class="kd">interface</span> <span class="nc">UserMapper</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="nf">getUserById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyBatisExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">resource</span> <span class="o">=</span> <span class="s">"mybatis-config.xml"</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="nc">Resources</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="n">resource</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">SqlSessionFactory</span> <span class="n">sqlSessionFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SqlSessionFactoryBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">(</span><span class="n">inputStream</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">(</span><span class="nc">SqlSession</span> <span class="n">session</span> <span class="o">=</span> <span class="n">sqlSessionFactory</span><span class="o">.</span><span class="na">openSession</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">UserMapper</span> <span class="n">userMapper</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">getMapper</span><span class="o">(</span><span class="nc">UserMapper</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userMapper</span><span class="o">.</span><span class="na">getUserById</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong>JPA (Java Persistence API) / Hibernate</strong>
    <ul>
      <li><strong>ORM概念</strong>：通过实体类和映射注解（如<code class="language-plaintext highlighter-rouge">@Entity</code>, <code class="language-plaintext highlighter-rouge">@Table</code>, <code class="language-plaintext highlighter-rouge">@Column</code>等）将Java对象映射到数据库表。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">EntityManager</code></strong>：用于管理实体的生命周期，如持久化、查询、删除等。</li>
      <li><strong>JPA Repository (Spring Data JPA)</strong>：提供了简单的CRUD操作和自定义查询方法。</li>
      <li><strong>对象关系映射策略</strong>：包括一对一、一对多、多对一、多对多等关系的映射。</li>
      <li><strong>Hibernate缓存</strong>：包括一级Session缓存、二级缓存和查询缓存。</li>
      <li><strong>Hibernate与MyBatis对比</strong>：Hibernate是全自动的ORM框架，提供了更高级的功能和更简洁的代码；MyBatis是半自动的ORM框架，更灵活，适合对SQL有较高要求的场景。</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">javax.persistence.Entity</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.GeneratedValue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.GenerationType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.Id</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.EntityManager</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.EntityManagerFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.Persistence</span><span class="o">;</span>

<span class="c1">// 实体类</span>
<span class="nd">@Entity</span>
<span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setId</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Product{id="</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">", name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"'}"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JPAExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">EntityManagerFactory</span> <span class="n">emf</span> <span class="o">=</span> <span class="nc">Persistence</span><span class="o">.</span><span class="na">createEntityManagerFactory</span><span class="o">(</span><span class="s">"myPU"</span><span class="o">);</span>
        <span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">().</span><span class="na">begin</span><span class="o">();</span>
            <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">();</span>
            <span class="n">product</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"Test Product"</span><span class="o">);</span>
            <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
            <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">().</span><span class="na">commit</span><span class="o">();</span>

            <span class="nc">Product</span> <span class="n">retrievedProduct</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Product</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">product</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">retrievedProduct</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">emf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="4-数据库连接池">4. 数据库连接池</h4>
<ul>
  <li><strong>原理</strong>：连接池在初始化时会创建一定数量的数据库连接，当应用程序需要使用数据库连接时，从连接池中获取一个空闲的连接，使用完毕后将连接返回给连接池，而不是直接关闭连接。</li>
  <li><strong>优势</strong>：减少数据库连接的创建和销毁开销，提高性能；可以对连接进行管理和监控。</li>
  <li><strong>常见实现</strong>：<code class="language-plaintext highlighter-rouge">HikariCP</code>是高性能的默认选择，<code class="language-plaintext highlighter-rouge">Druid</code>功能强大，带有监控功能。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">com.zaxxer.hikari.HikariConfig</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.zaxxer.hikari.HikariDataSource</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.sql.Connection</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.sql.ResultSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.sql.Statement</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConnectionPoolExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HikariConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariConfig</span><span class="o">();</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setJdbcUrl</span><span class="o">(</span><span class="s">"jdbc:mysql://localhost:3306/test"</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"root"</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">"password"</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setMaximumPoolSize</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>

        <span class="nc">HikariDataSource</span> <span class="n">dataSource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariDataSource</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
             <span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span>
             <span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="s">"SELECT * FROM users"</span><span class="o">))</span> <span class="o">{</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ID: "</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">", Name: "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="六开发框架-development-frameworks">六、开发框架 (Development Frameworks)</h3>

<h4 id="1-spring-framework">1. Spring Framework</h4>
<ul>
  <li><strong>IoC (Inversion of Control) / DI (Dependency Injection)</strong>
    <ul>
      <li><strong>核心概念</strong>：IoC是一种设计原则，将对象的创建和依赖关系的管理交给容器来完成；DI是IoC的具体实现方式，通过构造器注入、Setter注入、字段注入等方式将依赖对象注入到目标对象中。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">BeanFactory</code> vs <code class="language-plaintext highlighter-rouge">ApplicationContext</code></strong>：<code class="language-plaintext highlighter-rouge">BeanFactory</code>是Spring的基础容器，<code class="language-plaintext highlighter-rouge">ApplicationContext</code>是<code class="language-plaintext highlighter-rouge">BeanFactory</code>的子接口，提供了更多的功能，如国际化支持、事件发布等。</li>
      <li><strong>Bean作用域</strong>：包括<code class="language-plaintext highlighter-rouge">singleton</code>（单例）、<code class="language-plaintext highlighter-rouge">prototype</code>（原型）等。</li>
      <li><strong>Bean生命周期</strong>：包括实例化、属性赋值、初始化、销毁等阶段。</li>
      <li><strong>依赖注入方式</strong>：构造器注入、Setter注入、字段注入（不推荐）。</li>
      <li><strong>注解</strong>：<code class="language-plaintext highlighter-rouge">@Autowired</code>, <code class="language-plaintext highlighter-rouge">@Resource</code>, <code class="language-plaintext highlighter-rouge">@Component</code>及相关注解（<code class="language-plaintext highlighter-rouge">@Service</code>, <code class="language-plaintext highlighter-rouge">@Repository</code>, <code class="language-plaintext highlighter-rouge">@Controller</code>）。</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="c1">// 服务类</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">(</span><span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">userRepository</span><span class="o">.</span><span class="na">saveUser</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 仓库类</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">saveUser</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"User saved"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 主类</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>

<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringIoCExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">SpringIoCExample</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">UserService</span> <span class="n">userService</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">UserService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">userService</span><span class="o">.</span><span class="na">doSomething</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong>AOP (Aspect-Oriented Programming)</strong>
    <ul>
      <li><strong>核心概念</strong>：包括切面（Aspect）、连接点（Joinpoint）、通知（Advice）、切点（Pointcut）、引入（Introduction）、织入（Weaving）等。</li>
      <li><strong>通知类型</strong>：<code class="language-plaintext highlighter-rouge">@Before</code>, <code class="language-plaintext highlighter-rouge">@After</code>, <code class="language-plaintext highlighter-rouge">@AfterReturning</code>, <code class="language-plaintext highlighter-rouge">@AfterThrowing</code>, <code class="language-plaintext highlighter-rouge">@Around</code>。</li>
      <li><strong>实现原理</strong>：基于动态代理（JDK Proxy vs CGLIB）。</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.aspectj.lang.JoinPoint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.aspectj.lang.annotation.After</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.aspectj.lang.annotation.Aspect</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.aspectj.lang.annotation.Before</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.aspectj.lang.annotation.Pointcut</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="c1">// 切面类</span>
<span class="nd">@Aspect</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">LoggingAspect</span> <span class="o">{</span>
    <span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(* com.example.UserService.*(..))"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">userServiceMethods</span><span class="o">()</span> <span class="o">{}</span>

    <span class="nd">@Before</span><span class="o">(</span><span class="s">"userServiceMethods()"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">beforeAdvice</span><span class="o">(</span><span class="nc">JoinPoint</span> <span class="n">joinPoint</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before method: "</span> <span class="o">+</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@After</span><span class="o">(</span><span class="s">"userServiceMethods()"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterAdvice</span><span class="o">(</span><span class="nc">JoinPoint</span> <span class="n">joinPoint</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After method: "</span> <span class="o">+</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 主类</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.EnableAspectJAutoProxy</span><span class="o">;</span>

<span class="nd">@EnableAspectJAutoProxy</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringAOPExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">SpringAOPExample</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">UserService</span> <span class="n">userService</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">UserService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">userService</span><span class="o">.</span><span class="na">doSomething</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong>事务管理</strong>
    <ul>
      <li><strong>声明式事务</strong>：通过<code class="language-plaintext highlighter-rouge">@Transactional</code>注解来管理事务。</li>
      <li><strong>传播行为</strong>：定义了事务在不同方法调用时的传播方式，如<code class="language-plaintext highlighter-rouge">Propagation.REQUIRED</code>, <code class="language-plaintext highlighter-rouge">Propagation.REQUIRES_NEW</code>等。</li>
      <li><strong>隔离级别</strong>：定义了事务之间的隔离程度，如<code class="language-plaintext highlighter-rouge">Isolation.READ_COMMITTED</code>, <code class="language-plaintext highlighter-rouge">Isolation.SERIALIZABLE</code>等。</li>
      <li><strong>回滚规则</strong>：可以指定哪些异常会导致事务回滚。</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.transaction.annotation.Transactional</span><span class="o">;</span>

<span class="c1">// 服务类</span>
<span class="nd">@Service</span>
<span class="kd">class</span> <span class="nc">TransactionalService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="nf">TransactionalService</span><span class="o">(</span><span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doTransactionalOperation</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">userRepository</span><span class="o">.</span><span class="na">saveUser</span><span class="o">();</span>
        <span class="c1">// 模拟异常</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Transaction failed"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 主类</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.EnableTransactionManagement</span><span class="o">;</span>

<span class="nd">@EnableTransactionManagement</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringTransactionExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">SpringTransactionExample</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">TransactionalService</span> <span class="n">transactionalService</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">TransactionalService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">transactionalService</span><span class="o">.</span><span class="na">doTransactionalOperation</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Exception caught: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong>Spring MVC</strong>
    <ul>
      <li><strong>核心组件</strong>：包括<code class="language-plaintext highlighter-rouge">DispatcherServlet</code>, <code class="language-plaintext highlighter-rouge">HandlerMapping</code>, <code class="language-plaintext highlighter-rouge">HandlerAdapter</code>, <code class="language-plaintext highlighter-rouge">ViewResolver</code>等。</li>
      <li><strong>请求处理流程</strong>：客户端发送请求到<code class="language-plaintext highlighter-rouge">DispatcherServlet</code>，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code>根据<code class="language-plaintext highlighter-rouge">HandlerMapping</code>找到对应的处理器，通过<code class="language-plaintext highlighter-rouge">HandlerAdapter</code>调用处理器方法，处理器方法返回<code class="language-plaintext highlighter-rouge">ModelAndView</code>对象，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code>根据<code class="language-plaintext highlighter-rouge">ViewResolver</code>将<code class="language-plaintext highlighter-rouge">ModelAndView</code>对象解析为视图并返回给客户端。</li>
      <li><strong>常用注解</strong>：<code class="language-plaintext highlighter-rouge">@Controller</code>, <code class="language-plaintext highlighter-rouge">@RestController</code>, <code class="language-plaintext highlighter-rouge">@RequestMapping</code>, <code class="language-plaintext highlighter-rouge">@RequestParam</code>, <code class="language-plaintext highlighter-rouge">@PathVariable</code>, <code class="language-plaintext highlighter-rouge">@RequestBody</code>, <code class="language-plaintext highlighter-rouge">@ResponseBody</code>等。</li>
      <li><strong>数据绑定与验证</strong>：可以将请求参数绑定到Java对象中，并进行数据验证。</li>
      <li><strong>文件上传下载</strong>：可以通过<code class="language-plaintext highlighter-rouge">MultipartFile</code>实现文件上传，通过<code class="language-plaintext highlighter-rouge">ResponseEntity</code>实现文件下载。</li>
      <li><strong>拦截器</strong>：可以通过实现<code class="language-plaintext highlighter-rouge">HandlerInterceptor</code>接口来定义拦截器，对请求进行预处理和后处理。</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.stereotype.Controller</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.GetMapping</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RequestParam</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.ResponseBody</span><span class="o">;</span>

<span class="c1">// 控制器类</span>
<span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloController</span> <span class="o">{</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(</span><span class="nd">@RequestParam</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"name"</span><span class="o">,</span> <span class="n">defaultValue</span> <span class="o">=</span> <span class="s">"World"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hello, "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 主类</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>

<span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringMVCExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">SpringMVCExample</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong>Spring核心模块</strong>：包括Spring Core, Spring Beans, Spring Context, Spring AOP, Spring Expression Language (SpEL)等。</li>
</ul>

<h4 id="2-spring-boot">2. Spring Boot</h4>
<ul>
  <li><strong>核心特性</strong>
    <ul>
      <li><strong>自动配置</strong>：通过<code class="language-plaintext highlighter-rouge">@EnableAutoConfiguration</code>和<code class="language-plaintext highlighter-rouge">spring.factories</code>文件实现自动配置，减少了开发人员的配置工作。</li>
      <li><strong>起步依赖</strong>：提供了一系列的Starter依赖，方便开发人员快速集成各种功能。</li>
      <li><strong>嵌入式Web服务器</strong>：支持Tomcat, Jetty, Undertow等嵌入式Web服务器。</li>
      <li><strong>Actuator</strong>：提供了应用监控与管理的功能。</li>
      <li><strong>外部化配置</strong>：可以通过<code class="language-plaintext highlighter-rouge">application.properties</code>/<code class="language-plaintext highlighter-rouge">application.yml</code>文件和Profile来进行外部化配置。</li>
    </ul>
  </li>
  <li><strong>简化Spring开发</strong>：采用约定优于配置的原则，零XML配置（Java Config）。</li>
  <li><strong>常用注解</strong>：<code class="language-plaintext highlighter-rouge">@SpringBootApplication</code>。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.GetMapping</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestController</span><span class="o">;</span>

<span class="nd">@RestController</span>
<span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringBootExample</span> <span class="o">{</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hello, Spring Boot!"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">SpringBootExample</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-spring-cloud-微服务">3. Spring Cloud (微服务)</h4>
<ul>
  <li><strong>服务注册与发现</strong>：常用的服务注册中心有Eureka, Nacos, Consul等。</li>
  <li><strong>服务调用</strong>：可以使用<code class="language-plaintext highlighter-rouge">RestTemplate</code>或<code class="language-plaintext highlighter-rouge">OpenFeign</code>进行服务调用。</li>
  <li><strong>负载均衡</strong>：可以使用<code class="language-plaintext highlighter-rouge">Ribbon</code>或<code class="language-plaintext highlighter-rouge">Spring Cloud LoadBalancer</code>进行负载均衡。</li>
  <li><strong>服务熔断与降级</strong>：常用的服务熔断与降级框架有Hystrix, Sentinel, Resilience4j等。</li>
  <li><strong>服务网关</strong>：可以使用Zuul或<code class="language-plaintext highlighter-rouge">Spring Cloud Gateway</code>作为服务网关。</li>
  <li><strong>配置中心</strong>：可以使用<code class="language-plaintext highlighter-rouge">Spring Cloud Config</code>或Nacos Config作为配置中心。</li>
  <li><strong>分布式链路追踪</strong>：可以使用Sleuth + Zipkin进行分布式链路追踪。</li>
  <li><strong>消息驱动</strong>：可以使用<code class="language-plaintext highlighter-rouge">Spring Cloud Stream</code>进行消息驱动开发。</li>
  <li><strong>分布式事务</strong>：可以使用Seata进行分布式事务管理。</li>
</ul>

<h3 id="七系统设计与工具-system-design--tools">七、系统设计与工具 (System Design &amp; Tools)</h3>

<h4 id="1-常用设计模式">1. 常用设计模式</h4>
<ul>
  <li><strong>创建型</strong>：包括单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式等。</li>
  <li><strong>结构型</strong>：包括适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式等。</li>
  <li><strong>行为型</strong>：包括策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式等。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 单例模式（懒汉式，线程安全）</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">Singleton</span> <span class="n">instance</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 工厂模式</span>
<span class="kd">interface</span> <span class="nc">Shape</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">draw</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">implements</span> <span class="nc">Shape</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Drawing a circle"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">implements</span> <span class="nc">Shape</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Drawing a rectangle"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">ShapeFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Shape</span> <span class="nf">getShape</span><span class="o">(</span><span class="nc">String</span> <span class="n">shapeType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">shapeType</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">shapeType</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">"CIRCLE"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Circle</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">shapeType</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">"RECTANGLE"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Rectangle</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 主类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DesignPatternExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 单例模式</span>
        <span class="nc">Singleton</span> <span class="n">singleton</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">singleton</span><span class="o">);</span>

        <span class="c1">// 工厂模式</span>
        <span class="nc">ShapeFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ShapeFactory</span><span class="o">();</span>
        <span class="nc">Shape</span> <span class="n">circle</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getShape</span><span class="o">(</span><span class="s">"CIRCLE"</span><span class="o">);</span>
        <span class="n">circle</span><span class="o">.</span><span class="na">draw</span><span class="o">();</span>
        <span class="nc">Shape</span> <span class="n">rectangle</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getShape</span><span class="o">(</span><span class="s">"RECTANGLE"</span><span class="o">);</span>
        <span class="n">rectangle</span><span class="o">.</span><span class="na">draw</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="2-数据结构与算法基础">2. 数据结构与算法基础</h4>
<ul>
  <li><strong>数据结构</strong>：包括数组、链表、栈、队列、树（二叉树、二叉搜索树、AVL树、红黑树）、堆、图、哈希表等。</li>
  <li><strong>常用算法</strong>：包括排序（冒泡、选择、插入、希尔、归并、快速、堆排序）、查找、递归、DFS/BFS、动态规划、贪心算法等。</li>
  <li><strong>Big O表示法</strong>：用于描述算法的时间复杂度和空间复杂度。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 快速排序</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">QuickSort</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">pivotIndex</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span>
            <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">pivotIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">pivotIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">high</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">low</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">num</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-网络基础">3. 网络基础</h4>
<ul>
  <li><strong>OSI七层模型/TCP/IP四层模型</strong>：OSI七层模型包括物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；TCP/IP四层模型包括网络接口层、网络层、传输层、应用层。</li>
  <li><strong>TCP vs UDP</strong>：TCP是面向连接的、可靠的传输协议，UDP是无连接的、不可靠的传输协议。</li>
  <li><strong>三次握手与四次挥手</strong>：TCP建立连接时需要进行三次握手，断开连接时需要进行四次挥手。</li>
  <li><strong>HTTP/HTTPS协议</strong>：HTTP是超文本传输协议，HTTPS是在HTTP的基础上加入了SSL/TLS协议，保证了数据传输的安全性。</li>
  <li><strong>WebSocket</strong>：是一种在单个TCP连接上进行全双工通信的协议，适用于实时通信场景。</li>
</ul>

<h4 id="4-linux常用命令">4. Linux常用命令</h4>
<ul>
  <li><strong>文件操作</strong>：<code class="language-plaintext highlighter-rouge">ls</code>, <code class="language-plaintext highlighter-rouge">cd</code>, <code class="language-plaintext highlighter-rouge">cp</code>, <code class="language-plaintext highlighter-rouge">mv</code>, <code class="language-plaintext highlighter-rouge">rm</code>, <code class="language-plaintext highlighter-rouge">mkdir</code>, <code class="language-plaintext highlighter-rouge">cat</code>, <code class="language-plaintext highlighter-rouge">more</code>, <code class="language-plaintext highlighter-rouge">less</code>, <code class="language-plaintext highlighter-rouge">tail</code>, <code class="language-plaintext highlighter-rouge">head</code>, <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">find</code>等。</li>
  <li><strong>系统管理</strong>：<code class="language-plaintext highlighter-rouge">ps</code>, <code class="language-plaintext highlighter-rouge">top</code>, <code class="language-plaintext highlighter-rouge">kill</code>, <code class="language-plaintext highlighter-rouge">df</code>, <code class="language-plaintext highlighter-rouge">du</code>, <code class="language-plaintext highlighter-rouge">free</code>, <code class="language-plaintext highlighter-rouge">netstat</code>, <code class="language-plaintext highlighter-rouge">ifconfig</code>等。</li>
  <li><strong>权限管理</strong>：<code class="language-plaintext highlighter-rouge">chmod</code>, <code class="language-plaintext highlighter-rouge">chown</code>, <code class="language-plaintext highlighter-rouge">chgrp</code>等。</li>
  <li><strong>文本处理</strong>：<code class="language-plaintext highlighter-rouge">sed</code>, <code class="language-plaintext highlighter-rouge">awk</code>等。</li>
  <li><strong>压缩解压</strong>：<code class="language-plaintext highlighter-rouge">tar</code>, <code class="language-plaintext highlighter-rouge">gzip</code>, <code class="language-plaintext highlighter-rouge">zip/unzip</code>等。</li>
  <li><strong>网络工具</strong>：<code class="language-plaintext highlighter-rouge">ping</code>, <code class="language-plaintext highlighter-rouge">telnet</code>, <code class="language-plaintext highlighter-rouge">curl</code>, <code class="language-plaintext highlighter-rouge">wget</code>等。</li>
</ul>

<h4 id="5-构建工具">5. 构建工具</h4>
<ul>
  <li><strong>Maven</strong>
    <ul>
      <li><strong>POM文件结构</strong>：包括项目的基本信息、依赖管理、插件配置等。</li>
      <li><strong>坐标(GAV)</strong>：包括groupId, artifactId, version，用于唯一标识一个项目。</li>
      <li><strong>依赖管理</strong>：包括依赖范围（scope）、传递依赖、依赖冲突解决等。</li>
      <li><strong>仓库</strong>：包括本地仓库、远程仓库、中央仓库。</li>
      <li><strong>生命周期与插件</strong>：Maven有三个主要的生命周期（clean, default, site），可以通过插件来扩展功能。</li>
      <li><strong>多模块项目</strong>：可以将一个大型项目拆分成多个模块，方便管理和维护。</li>
    </ul>
  </li>
  <li><strong>Gradle</strong>
    <ul>
      <li><strong>基于Groovy/DSL</strong>：Gradle使用Groovy或Kotlin DSL来编写构建脚本。</li>
      <li><strong>构建脚本(<code class="language-plaintext highlighter-rouge">build.gradle</code>)</strong>：包括项目的基本信息、依赖管理、任务定义等。</li>
      <li><strong>依赖管理</strong>：与Maven类似，支持传递依赖和依赖冲突解决。</li>
      <li><strong>任务定义</strong>：可以自定义任务，实现自动化构建。</li>
    </ul>
  </li>
</ul>

<h4 id="6-版本控制">6. 版本控制</h4>
<ul>
  <li><strong>Git</strong>
    <ul>
      <li><strong>核心概念</strong>：包括工作区、暂存区、版本库。</li>
      <li><strong>常用命令</strong>：<code class="language-plaintext highlighter-rouge">git init/clone/add/commit/status/diff/log/show/push/pull/fetch/branch/checkout/merge/rebase/stash/tag</code>等。</li>
      <li><strong>分支管理策略</strong>：如Git Flow，用于规范分支的创建、合并和删除。</li>
      <li><strong>远程仓库操作</strong>：可以使用GitHub, GitLab, Gitee等远程仓库进行代码托管。</li>
    </ul>
  </li>
</ul>

<h4 id="7-集成开发环境-ide">7. 集成开发环境 (IDE)</h4>
<ul>
  <li><strong>IntelliJ IDEA</strong>：功能强大，支持多种开发语言和框架，提供了丰富的插件和工具。</li>
  <li><strong>Eclipse</strong>：开源的集成开发环境，广泛应用于Java开发。</li>
</ul>

<p>面试准备部分是为求职者提供在 Java 相关面试中可能会遇到的各类问题以及项目经验阐述方法，以下为你详细展开讲解各部分内容：</p>

<h3 id="1-java-基础面试题">1. Java 基础面试题</h3>
<ul>
  <li><strong>高频基础概念</strong>
    <ul>
      <li><strong>数据类型</strong>：要清楚基本数据类型（如 <code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">double</code>、<code class="language-plaintext highlighter-rouge">boolean</code> 等）和引用数据类型（类、接口、数组）的区别，以及它们的默认值。例如，<code class="language-plaintext highlighter-rouge">int</code> 的默认值是 0，而引用类型的默认值是 <code class="language-plaintext highlighter-rouge">null</code>。</li>
      <li><strong>运算符</strong>：理解不同运算符的优先级和结合性，如算术运算符、逻辑运算符、位运算符等。例如，<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> 和 <code class="language-plaintext highlighter-rouge">&amp;</code> 的区别，<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> 具有短路特性。</li>
      <li><strong>流程控制</strong>：掌握 <code class="language-plaintext highlighter-rouge">if - else</code>、<code class="language-plaintext highlighter-rouge">switch</code>、<code class="language-plaintext highlighter-rouge">for</code>、<code class="language-plaintext highlighter-rouge">while</code>、<code class="language-plaintext highlighter-rouge">do - while</code> 等语句的使用场景和执行流程。例如，<code class="language-plaintext highlighter-rouge">switch</code> 语句在 JDK 7 之后可以使用字符串作为表达式。</li>
    </ul>
  </li>
  <li><strong>OOP（面向对象编程）</strong>
    <ul>
      <li><strong>核心概念</strong>：类与对象是 OOP 的基础，要能解释类是对象的抽象，对象是类的实例。封装是将数据和操作数据的方法绑定在一起，隐藏内部实现细节；继承是子类继承父类的属性和方法，实现代码复用；多态是同一个方法可以根据对象的不同类型表现出不同的行为；抽象是将一类对象的共同特征提取出来形成抽象类或接口。</li>
      <li><strong>关键机制</strong>：构造方法用于创建对象时初始化对象的状态；方法重载是指在同一个类中，方法名相同但参数列表不同；方法重写是子类重写父类的方法，要求方法名、参数列表和返回值类型都相同；访问权限控制符决定了类、方法和变量的访问范围。</li>
      <li><strong>抽象类与接口</strong>：抽象类可以包含抽象方法和非抽象方法，而接口只能包含抽象方法（JDK 8 之后可以有默认方法和静态方法）。抽象类适用于需要共享代码和部分实现的场景，接口适用于定义规范和行为的场景。</li>
      <li><code class="language-plaintext highlighter-rouge">this</code> 和 <code class="language-plaintext highlighter-rouge">super</code> 关键字：<code class="language-plaintext highlighter-rouge">this</code> 关键字指向当前对象，用于区分成员变量和局部变量；<code class="language-plaintext highlighter-rouge">super</code> 关键字指向父类对象，用于调用父类的方法和构造方法。</li>
    </ul>
  </li>
  <li><strong>集合</strong>：了解 <code class="language-plaintext highlighter-rouge">Collection</code> 接口下的 <code class="language-plaintext highlighter-rouge">List</code>、<code class="language-plaintext highlighter-rouge">Set</code>、<code class="language-plaintext highlighter-rouge">Queue</code> 以及 <code class="language-plaintext highlighter-rouge">Map</code> 接口的特点和常用实现类。例如，<code class="language-plaintext highlighter-rouge">List</code> 是有序可重复的，<code class="language-plaintext highlighter-rouge">Set</code> 是无序不可重复的，<code class="language-plaintext highlighter-rouge">Map</code> 是键值对的集合。</li>
  <li><strong>异常</strong>：清楚 <code class="language-plaintext highlighter-rouge">Throwable</code> 类的层次结构，包括 <code class="language-plaintext highlighter-rouge">Error</code> 和 <code class="language-plaintext highlighter-rouge">Exception</code>。区分 Checked Exception 和 Unchecked Exception（RuntimeException），掌握 <code class="language-plaintext highlighter-rouge">try - catch - finally</code> 和 <code class="language-plaintext highlighter-rouge">try - with - resources</code> 语句的使用，以及如何自定义异常。</li>
  <li><strong>泛型</strong>：理解泛型的概念和优势，如类型安全、消除强制转换。掌握通配符（<code class="language-plaintext highlighter-rouge">?</code>、<code class="language-plaintext highlighter-rouge">? extends T</code>、<code class="language-plaintext highlighter-rouge">? super T</code>）的使用和类型擦除的原理。</li>
  <li><strong>反射</strong>：知道如何使用 <code class="language-plaintext highlighter-rouge">Class</code> 类获取类的信息，动态创建对象、调用方法和访问字段。反射在框架开发中应用广泛，如 Spring 框架的依赖注入。</li>
  <li><strong>新特性</strong>：了解 Java 8 及之后的新特性，如 Lambda 表达式、Stream API、方法引用、接口默认方法和静态方法、日期时间 API 等。</li>
</ul>

<h3 id="2-集合面试题">2. 集合面试题</h3>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">HashMap</code>/<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 原理</strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">HashMap</code></strong>：基于哈希表实现，通过键的哈希值计算数组索引，使用链表或红黑树解决哈希冲突。当链表长度超过 8 且数组长度大于 64 时，链表会转换为红黑树；当红黑树节点数小于 6 时，红黑树会转换为链表。要了解其扩容机制，当元素数量达到阈值（容量 * 负载因子）时，会进行扩容操作，扩容为原来的 2 倍。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code></strong>：是线程安全的哈希表，在 JDK 7 中采用分段锁机制，将整个哈希表分成多个段，每个段是一个独立的小哈希表，不同段可以同时进行读写操作；在 JDK 8 中采用 CAS + synchronized 机制，通过 CAS 操作保证并发插入和更新，使用 synchronized 对链表或红黑树的头节点加锁，减少锁的粒度。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ArrayList</code> vs <code class="language-plaintext highlighter-rouge">LinkedList</code></strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">ArrayList</code></strong>：基于数组实现，随机访问快，时间复杂度为 O(1)，但插入和删除操作慢，需要移动元素，时间复杂度为 O(n)。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">LinkedList</code></strong>：基于双向链表实现，插入和删除操作快，时间复杂度为 O(1)，但随机访问慢，需要遍历链表，时间复杂度为 O(n)。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">HashSet</code> 原理</strong>：基于 <code class="language-plaintext highlighter-rouge">HashMap</code> 实现，<code class="language-plaintext highlighter-rouge">HashSet</code> 中的元素存储在 <code class="language-plaintext highlighter-rouge">HashMap</code> 的键中，值统一为一个静态常量对象。<code class="language-plaintext highlighter-rouge">HashSet</code> 利用 <code class="language-plaintext highlighter-rouge">HashMap</code> 的哈希冲突解决机制来保证元素的唯一性。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fail - fast</code> vs <code class="language-plaintext highlighter-rouge">fail - safe</code></strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">fail - fast</code></strong>：当在迭代集合时，如果集合的结构被修改（如添加、删除元素），会立即抛出 <code class="language-plaintext highlighter-rouge">ConcurrentModificationException</code> 异常。<code class="language-plaintext highlighter-rouge">ArrayList</code>、<code class="language-plaintext highlighter-rouge">HashMap</code> 等集合采用 <code class="language-plaintext highlighter-rouge">fail - fast</code> 机制。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">fail - safe</code></strong>：在迭代集合时，会复制一份集合的快照进行迭代，即使集合的结构被修改，也不会抛出异常。<code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList</code>、<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code> 等集合采用 <code class="language-plaintext highlighter-rouge">fail - safe</code> 机制。</li>
    </ul>
  </li>
</ul>

<h3 id="3-并发面试题">3. 并发面试题</h3>
<ul>
  <li><strong>线程状态</strong>：了解线程的生命周期和状态，包括 <code class="language-plaintext highlighter-rouge">NEW</code>（新建）、<code class="language-plaintext highlighter-rouge">RUNNABLE</code>（可运行）、<code class="language-plaintext highlighter-rouge">BLOCKED</code>（阻塞）、<code class="language-plaintext highlighter-rouge">WAITING</code>（等待）、<code class="language-plaintext highlighter-rouge">TIMED_WAITING</code>（定时等待）、<code class="language-plaintext highlighter-rouge">TERMINATED</code>（终止）。知道线程状态之间的转换条件，如调用 <code class="language-plaintext highlighter-rouge">start()</code> 方法使线程从 <code class="language-plaintext highlighter-rouge">NEW</code> 状态转换为 <code class="language-plaintext highlighter-rouge">RUNNABLE</code> 状态，调用 <code class="language-plaintext highlighter-rouge">wait()</code> 方法使线程从 <code class="language-plaintext highlighter-rouge">RUNNABLE</code> 状态转换为 <code class="language-plaintext highlighter-rouge">WAITING</code> 状态。</li>
  <li><strong>线程创建</strong>：掌握三种线程创建方式，继承 <code class="language-plaintext highlighter-rouge">Thread</code> 类、实现 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口和实现 <code class="language-plaintext highlighter-rouge">Callable</code> 接口 + <code class="language-plaintext highlighter-rouge">Future</code>/<code class="language-plaintext highlighter-rouge">FutureTask</code>。了解它们的优缺点，如继承 <code class="language-plaintext highlighter-rouge">Thread</code> 类会限制类的继承，而实现 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口和 <code class="language-plaintext highlighter-rouge">Callable</code> 接口更灵活。</li>
  <li><strong>线程池</strong>：理解线程池的核心原理，包括 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 的核心参数（核心线程数、最大线程数、工作队列、拒绝策略、线程工厂、存活时间）。知道 <code class="language-plaintext highlighter-rouge">Executors</code> 工厂类的常用方法（如 <code class="language-plaintext highlighter-rouge">newFixedThreadPool</code>、<code class="language-plaintext highlighter-rouge">newCachedThreadPool</code> 等）及其缺点，推荐手动创建 <code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code> 以避免资源耗尽问题。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">synchronized</code>/<code class="language-plaintext highlighter-rouge">Lock</code></strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">synchronized</code></strong>：是 Java 内置的锁机制，可以修饰方法和代码块。修饰方法时，锁对象是当前对象或类对象；修饰代码块时，需要指定锁对象。<code class="language-plaintext highlighter-rouge">synchronized</code> 基于监视器锁（Monitor）实现，是可重入锁。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">Lock</code></strong>：是一个接口，常用的实现类有 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>。<code class="language-plaintext highlighter-rouge">Lock</code> 提供了更灵活的锁操作，如可中断锁、定时锁、公平锁等。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">volatile</code></strong>：保证变量的可见性，即一个线程修改了 <code class="language-plaintext highlighter-rouge">volatile</code> 变量的值，其他线程能立即看到最新值。同时，<code class="language-plaintext highlighter-rouge">volatile</code> 禁止指令重排序，但不保证原子性。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">CAS</code></strong>：即 Compare - And - Swap，是一种无锁算法。<code class="language-plaintext highlighter-rouge">CAS</code> 操作包含三个操作数：内存位置（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值；否则，处理器不做任何操作。<code class="language-plaintext highlighter-rouge">CAS</code> 在 <code class="language-plaintext highlighter-rouge">AtomicInteger</code>、<code class="language-plaintext highlighter-rouge">AtomicReference</code> 等原子类中广泛应用。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">AQS</code></strong>：<code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code> 是一个抽象队列同步器，是许多同步器（如 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>、<code class="language-plaintext highlighter-rouge">CountDownLatch</code>、<code class="language-plaintext highlighter-rouge">Semaphore</code> 等）的基础框架。<code class="language-plaintext highlighter-rouge">AQS</code> 内部使用一个 <code class="language-plaintext highlighter-rouge">int</code> 类型的状态变量和一个双向队列来实现锁和同步机制。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ThreadLocal</code></strong>：是线程局部变量，每个使用 <code class="language-plaintext highlighter-rouge">ThreadLocal</code> 的线程都有自己独立的副本，线程之间互不影响。<code class="language-plaintext highlighter-rouge">ThreadLocal</code> 常用于保存线程上下文信息，如用户信息、事务信息等。</li>
  <li><strong>并发工具类</strong>：了解 <code class="language-plaintext highlighter-rouge">CountDownLatch</code>、<code class="language-plaintext highlighter-rouge">CyclicBarrier</code>、<code class="language-plaintext highlighter-rouge">Semaphore</code>、<code class="language-plaintext highlighter-rouge">Exchanger</code>、<code class="language-plaintext highlighter-rouge">Phaser</code> 等并发工具类的作用和使用场景。例如，<code class="language-plaintext highlighter-rouge">CountDownLatch</code> 用于一个或多个线程等待其他线程完成操作，<code class="language-plaintext highlighter-rouge">CyclicBarrier</code> 用于一组线程互相等待到达某个屏障点。</li>
</ul>

<h3 id="4-jvm-面试题">4. JVM 面试题</h3>
<ul>
  <li><strong>内存区域</strong>：清楚 JVM 的运行时数据区，包括程序计数器、虚拟机栈、本地方法栈、堆、方法区（JDK 8 之后为元空间）和运行时常量池。了解每个区域的作用和特点，如堆是 GC 主要区域，存放对象实例；虚拟机栈用于存储局部变量表、操作数栈等。</li>
  <li><strong>垃圾回收</strong>
    <ul>
      <li><strong>对象存活性判断</strong>：知道引用计数法和可达性分析算法，Java 采用可达性分析算法，通过 GC Roots 来判断对象是否可达。</li>
      <li><strong>引用类型</strong>：掌握强引用、软引用、弱引用和虚引用的区别和应用场景。强引用是最常见的引用类型，只要强引用存在，对象就不会被回收；软引用在内存不足时会被回收；弱引用在下次垃圾回收时会被回收；虚引用主要用于跟踪对象被垃圾回收的状态。</li>
      <li><strong>GC 算法</strong>：了解标记 - 清除、标记 - 复制、标记 - 整理、分代收集理论等 GC 算法的原理和优缺点。</li>
      <li><strong>垃圾收集器</strong>：熟悉不同的垃圾收集器，如新生代收集器（<code class="language-plaintext highlighter-rouge">Serial</code>、<code class="language-plaintext highlighter-rouge">ParNew</code>、<code class="language-plaintext highlighter-rouge">Parallel Scavenge</code>）、老年代收集器（<code class="language-plaintext highlighter-rouge">Serial Old</code>、<code class="language-plaintext highlighter-rouge">Parallel Old</code>、<code class="language-plaintext highlighter-rouge">CMS</code>）和整堆收集器（<code class="language-plaintext highlighter-rouge">G1</code>、<code class="language-plaintext highlighter-rouge">ZGC</code>、<code class="language-plaintext highlighter-rouge">Shenandoah</code>）的特点和适用场景。</li>
      <li><strong>GC 日志分析</strong>：知道如何使用 <code class="language-plaintext highlighter-rouge">-Xlog:gc*</code> 或 <code class="language-plaintext highlighter-rouge">-XX:+PrintGCDetails</code> 等参数来开启 GC 日志，并能分析日志中的信息，如垃圾回收的时间、内存使用情况等。</li>
      <li><strong>内存分配与回收策略</strong>：了解对象优先在 Eden 区分配、大对象直接进入老年代、长期存活对象进入老年代、动态对象年龄判定、空间分配担保等内存分配与回收策略。</li>
    </ul>
  </li>
  <li><strong>类加载机制</strong>
    <ul>
      <li><strong>过程</strong>：掌握类加载的过程，包括加载、链接（验证、准备、解析）和初始化。了解每个阶段的主要任务，如加载阶段将类的字节码文件加载到内存中，初始化阶段执行类的静态代码块和静态变量的赋值操作。</li>
      <li><strong>类加载器</strong>：清楚 <code class="language-plaintext highlighter-rouge">Bootstrap ClassLoader</code>、<code class="language-plaintext highlighter-rouge">Extension ClassLoader</code>、<code class="language-plaintext highlighter-rouge">Application ClassLoader</code> 和自定义类加载器的作用和加载范围。</li>
      <li><strong>双亲委派模型</strong>：理解双亲委派模型的原理和作用，即类加载器在加载类时，先委托给父类加载器加载，只有父类加载器无法加载时，才由自己加载。双亲委派模型可以避免重复加载和保证核心类的安全。了解破坏双亲委派模型的场景，如 SPI 机制和 OSGi。</li>
    </ul>
  </li>
  <li><strong>JMM（Java 内存模型）</strong>：了解 JMM 的主内存与工作内存的概念，以及内存间交互操作（<code class="language-plaintext highlighter-rouge">read</code>、<code class="language-plaintext highlighter-rouge">load</code>、<code class="language-plaintext highlighter-rouge">use</code>、<code class="language-plaintext highlighter-rouge">assign</code>、<code class="language-plaintext highlighter-rouge">store</code>、<code class="language-plaintext highlighter-rouge">write</code>、<code class="language-plaintext highlighter-rouge">lock</code>、<code class="language-plaintext highlighter-rouge">unlock</code>）。掌握 <code class="language-plaintext highlighter-rouge">volatile</code> 的特殊规则（可见性、禁止重排序），以及原子性、可见性、有序性的概念和 <code class="language-plaintext highlighter-rouge">happens - before</code> 原则。</li>
</ul>

<h3 id="5-数据库面试题">5. 数据库面试题</h3>
<ul>
  <li><strong>SQL 优化</strong>：掌握 SQL 优化的方法，如合理使用索引、避免全表扫描、优化查询语句结构、减少子查询等。例如，在经常用于查询条件和排序的字段上创建索引。</li>
  <li><strong>索引原理（B + 树）</strong>：了解 B + 树的结构和特点，B + 树是一种平衡的多路搜索树，所有数据都存储在叶子节点上，叶子节点之间通过指针相连。B + 树适用于数据库索引，因为它可以提高查询效率，减少磁盘 I/O 次数。</li>
  <li><strong>事务特性（ACID）</strong>：清楚事务的四个特性，原子性（Atomicity）表示事务中的操作要么全部执行，要么全部不执行；一致性（Consistency）表示事务执行前后数据库的状态保持一致；隔离性（Isolation）表示多个事务之间相互隔离，互不影响；持久性（Durability）表示事务一旦提交，其结果将永久保存在数据库中。</li>
  <li><strong>隔离级别</strong>：了解数据库的四种隔离级别，读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。不同的隔离级别会导致不同的并发问题，如脏读、不可重复读和幻读。</li>
  <li><strong>锁</strong>：掌握行锁、表锁、间隙锁、死锁的概念和使用场景。行锁是对一行数据加锁，表锁是对整个表加锁，间隙锁用于解决幻读问题，死锁是指两个或多个事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。</li>
  <li><strong>MVCC（多版本并发控制）</strong>：了解 MVCC 的原理和作用，MVCC 是一种并发控制技术，通过为数据的每个版本添加时间戳或版本号，实现多事务的并发访问，提高数据库的并发性能。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">explain</code></strong>：知道如何使用 <code class="language-plaintext highlighter-rouge">explain</code> 关键字来分析 SQL 语句的执行计划，了解执行计划中的各个字段的含义，如 <code class="language-plaintext highlighter-rouge">id</code>、<code class="language-plaintext highlighter-rouge">select_type</code>、<code class="language-plaintext highlighter-rouge">table</code>、<code class="language-plaintext highlighter-rouge">type</code>、<code class="language-plaintext highlighter-rouge">possible_keys</code>、<code class="language-plaintext highlighter-rouge">key</code>、<code class="language-plaintext highlighter-rouge">key_len</code>、<code class="language-plaintext highlighter-rouge">ref</code>、<code class="language-plaintext highlighter-rouge">rows</code>、<code class="language-plaintext highlighter-rouge">Extra</code> 等，通过分析执行计划可以找出 SQL 语句的性能瓶颈。</li>
  <li><strong>分库分表</strong>：了解分库分表的概念和原因，当数据库的数据量和并发量达到一定程度时，需要进行分库分表来提高数据库的性能和可扩展性。掌握垂直分库分表和水平分库分表的方法和优缺点。</li>
  <li><strong>主从复制、读写分离</strong>：了解主从复制的原理和实现方式，主从复制是指将主数据库的数据复制到从数据库，实现数据的备份和读写分离。读写分离是指将读操作和写操作分别分配到不同的数据库服务器上，提高数据库的并发性能。</li>
</ul>

<h3 id="6-框架面试题">6. 框架面试题</h3>
<ul>
  <li><strong>Spring IoC/AOP 原理</strong>
    <ul>
      <li><strong>IoC（控制反转）</strong>：理解 IoC 的核心概念，即对象的创建和依赖关系的管理由 Spring 容器负责，而不是由对象本身负责。掌握 <code class="language-plaintext highlighter-rouge">BeanFactory</code> 和 <code class="language-plaintext highlighter-rouge">ApplicationContext</code> 的区别，<code class="language-plaintext highlighter-rouge">ApplicationContext</code> 是 <code class="language-plaintext highlighter-rouge">BeanFactory</code> 的子接口，提供了更多的功能，如国际化支持、事件发布等。了解 Bean 的作用域（<code class="language-plaintext highlighter-rouge">singleton</code>、<code class="language-plaintext highlighter-rouge">prototype</code> 等）和生命周期，以及依赖注入的方式（构造器注入、Setter 注入、字段注入）。</li>
      <li><strong>AOP（面向切面编程）</strong>：掌握 AOP 的核心概念，如切面（Aspect）、连接点（Joinpoint）、通知（Advice）、切点（Pointcut）、引入（Introduction）、织入（Weaving）。了解通知的类型（<code class="language-plaintext highlighter-rouge">@Before</code>、<code class="language-plaintext highlighter-rouge">@After</code>、<code class="language-plaintext highlighter-rouge">@AfterReturning</code>、<code class="language-plaintext highlighter-rouge">@AfterThrowing</code>、<code class="language-plaintext highlighter-rouge">@Around</code>）和 AOP 的实现原理（动态代理 - JDK Proxy vs CGLIB）。</li>
    </ul>
  </li>
  <li><strong>Bean 生命周期</strong>：清楚 Bean 的生命周期，包括实例化、属性赋值、初始化、使用和销毁等阶段。了解在每个阶段可以使用的回调方法，如 <code class="language-plaintext highlighter-rouge">InitializingBean</code> 接口的 <code class="language-plaintext highlighter-rouge">afterPropertiesSet()</code> 方法和 <code class="language-plaintext highlighter-rouge">DisposableBean</code> 接口的 <code class="language-plaintext highlighter-rouge">destroy()</code> 方法。</li>
  <li><strong>事务传播行为</strong>：掌握 Spring 事务的传播行为，如 <code class="language-plaintext highlighter-rouge">Propagation.REQUIRED</code>（如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务）、<code class="language-plaintext highlighter-rouge">Propagation.REQUIRES_NEW</code>（总是创建一个新的事务，如果当前存在事务，则将当前事务挂起）等。了解不同传播行为的应用场景。</li>
  <li><strong>Spring MVC 流程</strong>：熟悉 Spring MVC 的核心组件（<code class="language-plaintext highlighter-rouge">DispatcherServlet</code>、<code class="language-plaintext highlighter-rouge">HandlerMapping</code>、<code class="language-plaintext highlighter-rouge">HandlerAdapter</code>、<code class="language-plaintext highlighter-rouge">ViewResolver</code> 等）和请求处理流程。当客户端发送请求时，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 接收请求，通过 <code class="language-plaintext highlighter-rouge">HandlerMapping</code> 找到对应的处理器，然后通过 <code class="language-plaintext highlighter-rouge">HandlerAdapter</code> 调用处理器的方法，最后通过 <code class="language-plaintext highlighter-rouge">ViewResolver</code> 解析视图并返回给客户端。</li>
  <li><strong>Spring Boot 自动配置原理</strong>：了解 Spring Boot 的自动配置原理，基于 <code class="language-plaintext highlighter-rouge">@EnableAutoConfiguration</code> 注解和 <code class="language-plaintext highlighter-rouge">spring.factories</code> 文件，Spring Boot 会根据类路径下的依赖和配置自动配置 Spring 应用。掌握起步依赖（Starter）的作用，起步依赖是一组预定义的依赖集合，可以简化项目的依赖管理。</li>
  <li><strong>MyBatis 缓存</strong>：了解 MyBatis 的一级缓存和二级缓存的原理和使用场景。一级缓存是基于 SqlSession 的，同一个 SqlSession 中执行相同的查询语句会从缓存中获取结果；二级缓存是基于 Mapper 的，多个 SqlSession 可以共享二级缓存。</li>
  <li><strong>#{} vs ${}</strong>：掌握 <code class="language-plaintext highlighter-rouge">#{}</code> 和 <code class="language-plaintext highlighter-rouge">${}</code> 在 MyBatis 中的区别，<code class="language-plaintext highlighter-rouge">#{}</code> 是预编译的占位符，会防止 SQL 注入；<code class="language-plaintext highlighter-rouge">${}</code> 是字符串替换，会直接将参数值替换到 SQL 语句中，可能会导致 SQL 注入问题。</li>
</ul>

<h3 id="7-系统设计面试题">7. 系统设计面试题</h3>
<ul>
  <li><strong>设计模式应用</strong>：掌握常用设计模式的意图、结构和应用场景，如单例模式用于确保一个类只有一个实例，工厂模式用于创建对象，观察者模式用于实现对象之间的一对多依赖关系等。能够在实际项目中灵活运用设计模式来解决问题。</li>
  <li><strong>缓存策略（Redis/Memcached）</strong>：了解 Redis 和 Memcached 的特点和区别，Redis 支持多种数据结构（如字符串、哈希、列表、集合、有序集合），支持持久化，而 Memcached 只支持简单的键值对存储，不支持持久化。掌握缓存的使用场景和缓存更新策略，如缓存穿透、缓存雪崩、缓存击穿等问题的解决方案。</li>
  <li><strong>消息队列（Kafka/RabbitMQ/RocketMQ）</strong>：了解 Kafka、RabbitMQ 和 RocketMQ 的特点和适用场景，Kafka 适用于大数据场景，具有高吞吐量、分布式、持久化等特点；RabbitMQ 适用于企业级应用，支持多种消息协议和高级特性；RocketMQ 是阿里巴巴开源的消息队列，具有高性能、高可用性、分布式等特点。掌握消息队列的使用场景，如异步处理、解耦、流量削峰等。</li>
  <li><strong>分布式 ID 生成</strong>：了解分布式 ID 生成的方法和要求，如唯一性、高性能、趋势递增等。掌握常见的分布式 ID 生成算法，如 UUID、数据库自增 ID、Snowflake 算法等。</li>
  <li><strong>分布式锁</strong>：了解分布式锁的概念和使用场景，如在分布式系统中保证数据的一致性和并发控制。掌握常见的分布式锁实现方式，如基于 Redis 的分布式锁、基于 ZooKeeper 的分布式锁等。</li>
  <li><strong>限流熔断降级</strong>：了解限流、熔断和降级的概念和作用，限流用于限制系统的并发访问量，熔断用于在系统出现故障时快速失败，降级用于在系统资源不足时牺牲部分功能来保证核心功能的可用性。掌握常见的限流算法，如令牌桶算法、漏桶算法等，以及熔断和降级的实现方式，如 Hystrix、Sentinel 等。</li>
  <li><strong>CAP/BASE 理论</strong>：了解 CAP 理论（一致性、可用性、分区容错性）和 BASE 理论（基本可用、软状态、最终一致性）的概念和关系。在分布式系统中，由于网络分区的存在，无法同时满足 CAP 理论的三个特性，通常需要在一致性和可用性之间进行权衡。BASE 理论是对 CAP 理论的一种妥协，强调系统的可用性和最终一致性。</li>
  <li><strong>微服务拆分原则</strong>：掌握微服务拆分的原则，如单一职责原则、高内聚低耦合原则、业务边界清晰原则等。能够根据业务需求和系统架构合理拆分微服务，提高系统的可维护性和可扩展性。</li>
</ul>

<h3 id="8-项目经验">8. 项目经验</h3>
<ul>
  <li><strong>STAR 法则</strong>：使用 STAR 法则来描述项目，STAR 分别代表 Situation（情景）、Task（任务）、Action（行动）和 Result（结果）。在描述项目时，先介绍项目的背景和目标（Situation），然后说明自己在项目中承担的任务和职责（Task），接着阐述为完成任务采取的具体行动和措施（Action），最后说明项目取得的成果和收益（Result）。</li>
  <li><strong>突出技术难点与解决方案</strong>：在描述项目时，要突出项目中遇到的技术难点和挑战，并详细说明自己是如何解决这些问题的。例如，在处理高并发问题时，采用了哪些技术手段（如缓存、限流、异步处理等）来提高系统的性能和可用性。通过突出技术难点和解决方案，可以展示自己的技术能力和解决问题的能力。</li>
</ul>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Java学习笔记]]></summary></entry><entry><title type="html">Golang学习笔记</title><link href="http://localhost:4000/blog/golang/2025/06/03/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="Golang学习笔记" /><published>2025-06-03T00:00:00+08:00</published><updated>2025-06-03T00:00:00+08:00</updated><id>http://localhost:4000/blog/golang/2025/06/03/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/golang/2025/06/03/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="golang学习笔记">Golang学习笔记</h1>

<h3 id="一基础语法">一、基础语法</h3>
<h4 id="1-变量与常量">1. 变量与常量</h4>
<ul>
  <li><strong>变量声明</strong>：
    <ul>
      <li>标准格式：<code class="language-plaintext highlighter-rouge">var 变量名 类型</code></li>
      <li>简短格式：<code class="language-plaintext highlighter-rouge">变量名 := 值</code>（函数内使用）</li>
      <li>批量声明：<code class="language-plaintext highlighter-rouge">var (a int; b string)</code>
```go
package main</li>
    </ul>
  </li>
</ul>

<p>import “fmt”</p>

<p>func main() {
    // 标准格式
    var num int
    num = 10
    // 简短格式
    str := “Hello, Golang!”
    // 批量声明
    var (
        a int
        b string
    )
    a = 20
    b = “World”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println(num, str, a, b) } ``` - **常量**：使用 `const` 定义，支持 `iota` 实现枚举自增。 ```go package main
</code></pre></div></div>

<p>import “fmt”</p>

<p>const (
    Monday = iota + 1
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)</p>

<p>func main() {
    fmt.Println(Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **数据类型**：
    - 基本类型：整型（`int8~int64`）、浮点型（`float32/64`）、布尔型（`bool`）、字符串（`string`，不可变）。
    - 派生类型：数组、切片、Map、结构体、指针等。
```go
package main

import "fmt"

func main() {
    // 基本类型
    var num int8 = 127
    var f float32 = 3.14
    var isTrue bool = true
    var str string = "Golang"

    // 派生类型 - 数组
    var arr [3]int = [3]int{1, 2, 3}
    // 派生类型 - 切片
    slice := []int{4, 5, 6}
    // 派生类型 - Map
    m := map[string]int{"one": 1, "two": 2}
    // 派生类型 - 结构体
    type Person struct {
        Name string
        Age  int
    }
    p := Person{Name: "John", Age: 30}
    // 派生类型 - 指针
    ptr := &amp;num

    fmt.Println(num, f, isTrue, str, arr, slice, m, p, *ptr)
}
</code></pre></div></div>

<h4 id="2-流程控制">2. 流程控制</h4>
<ul>
  <li><strong>分支</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">if-else</code> 条件灵活，可前置执行语句；</li>
      <li><code class="language-plaintext highlighter-rouge">switch</code> 支持多值匹配，默认 <code class="language-plaintext highlighter-rouge">break</code>，需显式使用 <code class="language-plaintext highlighter-rouge">fallthrough</code> 继续下一分支。
```go
package main</li>
    </ul>
  </li>
</ul>

<p>import “fmt”</p>

<p>func main() {
    // if-else
    if num := 10; num &gt; 5 {
        fmt.Println(“num is greater than 5”)
    } else {
        fmt.Println(“num is less than or equal to 5”)
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// switch
day := 3
switch day {
case 1, 2, 3, 4, 5:
    fmt.Println("Weekday")
case 6, 7:
    fmt.Println("Weekend")
default:
    fmt.Println("Invalid day")
}

// fallthrough
num := 2
switch num {
case 1:
    fmt.Println("One")
case 2:
    fmt.Println("Two")
    fallthrough
case 3:
    fmt.Println("Three")
} } ``` - **循环**：仅 `for` 关键字，支持 `break`/`continue` 控制嵌套循环。 ```go package main
</code></pre></div></div>

<p>import “fmt”</p>

<p>func main() {
    // 基本 for 循环
    for i := 0; i &lt; 5; i++ {
        fmt.Print(i, “ “)
    }
    fmt.Println()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 类似 while 循环
j := 0
for j &lt; 5 {
    fmt.Print(j, " ")
    j++
}
fmt.Println()

// 无限循环
k := 0
for {
    if k &gt;= 5 {
        break
    }
    fmt.Print(k, " ")
    k++
}
fmt.Println()

// 嵌套循环
for i := 0; i &lt; 3; i++ {
    for j := 0; j &lt; 2; j++ {
        if i == 1 &amp;&amp; j == 1 {
            continue
        }
        fmt.Printf("(%d, %d) ", i, j)
    }
}
fmt.Println() } ```
</code></pre></div></div>

<h4 id="3-函数特性">3. 函数特性</h4>
<ul>
  <li><strong>多返回值</strong>：函数可返回多个值，需显式接收。
```go
package main</li>
</ul>

<p>import “fmt”</p>

<p>func swap(a, b int) (int, int) {
    return b, a
}</p>

<p>func main() {
    x, y := 10, 20
    x, y = swap(x, y)
    fmt.Println(x, y)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **闭包**：匿名函数可捕获外部变量，形成闭包。
```go
package main

import "fmt"

func getSequence() func() int {
    i := 0
    return func() int {
        i++
        return i
    }
}

func main() {
    nextNumber := getSequence()
    fmt.Println(nextNumber())
    fmt.Println(nextNumber())
    fmt.Println(nextNumber())

    newNextNumber := getSequence()
    fmt.Println(newNextNumber())
}
</code></pre></div></div>
<ul>
  <li><strong>延迟执行</strong>：<code class="language-plaintext highlighter-rouge">defer</code> 注册延迟调用，按栈顺序执行（后进先出），常用于资源释放。
```go
package main</li>
</ul>

<p>import “fmt”</p>

<p>func main() {
    defer fmt.Println(“Last”)
    defer fmt.Println(“Second”)
    fmt.Println(“First”)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### 二、并发模型（核心优势）
#### 1. Goroutine
- 轻量级协程，由 Go 运行时调度，开销极小（可创建百万级），比线程高效。
- 启动方式：`go func()`
```go
package main

import (
    "fmt"
    "time"
)

func printNumbers() {
    for i := 0; i &lt; 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Print(i, " ")
    }
}

func main() {
    go printNumbers()
    time.Sleep(1 * time.Second)
    fmt.Println("Main goroutine finished")
}
</code></pre></div></div>

<h4 id="2-channel">2. Channel</h4>
<ul>
  <li>协程间通信管道，分无缓冲（同步阻塞）和有缓冲（异步队列）。
```go
package main</li>
</ul>

<p>import (
    “fmt”
)</p>

<p>func main() {
    // 无缓冲通道
    ch := make(chan int)
    go func() {
        ch &lt;- 10
    }()
    num := &lt;-ch
    fmt.Println(num)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 有缓冲通道
bufferedCh := make(chan int, 2)
bufferedCh &lt;- 20
bufferedCh &lt;- 30
fmt.Println(&lt;-bufferedCh)
fmt.Println(&lt;-bufferedCh) } ```
</code></pre></div></div>

<h4 id="3-同步原语">3. 同步原语</h4>
<ul>
  <li><strong>互斥锁</strong>：<code class="language-plaintext highlighter-rouge">sync.Mutex</code> 保护临界区。
```go
package main</li>
</ul>

<p>import (
    “fmt”
    “sync”
)</p>

<p>var (
    counter int
    mutex   sync.Mutex
)</p>

<p>func increment() {
    mutex.Lock()
    defer mutex.Unlock()
    counter++
}</p>

<p>func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            increment()
        }()
    }
    wg.Wait()
    fmt.Println(counter)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **读写锁**：`sync.RWMutex` 允许多读单写。
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var (
    data     int
    rwMutex  sync.RWMutex
)

func readData() {
    rwMutex.RLock()
    defer rwMutex.RUnlock()
    fmt.Println("Read data:", data)
    time.Sleep(100 * time.Millisecond)
}

func writeData() {
    rwMutex.Lock()
    defer rwMutex.Unlock()
    data++
    fmt.Println("Write data:", data)
    time.Sleep(200 * time.Millisecond)
}

func main() {
    var wg sync.WaitGroup

    // 启动多个读操作
    for i := 0; i &lt; 3; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            readData()
        }()
    }

    // 启动一个写操作
    wg.Add(1)
    go func() {
        defer wg.Done()
        writeData()
    }()

    wg.Wait()
}
</code></pre></div></div>
<ul>
  <li><strong>WaitGroup</strong>：<code class="language-plaintext highlighter-rouge">sync.WaitGroup</code> 等待一组协程结束。
```go
package main</li>
</ul>

<p>import (
    “fmt”
    “sync”
    “time”
)</p>

<p>func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf(“Worker %d starting\n”, id)
    time.Sleep(time.Second)
    fmt.Printf(“Worker %d done\n”, id)
}</p>

<p>func main() {
    var wg sync.WaitGroup
    for i := 1; i &lt;= 5; i++ {
        wg.Add(1)
        go worker(i, &amp;wg)
    }
    wg.Wait()
    fmt.Println(“All workers finished”)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### 三、数据结构
#### 1. 切片（Slice）
- 动态数组，基于数组封装，含指针、长度、容量三属性。
- 操作：`make()` 创建、`append()` 追加（自动扩容）、`copy()` 深拷贝。
```go
package main

import (
    "fmt"
)

func main() {
    // 创建切片
    slice := make([]int, 0, 5)
    // 追加元素
    slice = append(slice, 1, 2, 3)
    fmt.Println(slice)

    // 深拷贝
    newSlice := make([]int, len(slice))
    copy(newSlice, slice)
    fmt.Println(newSlice)
}
</code></pre></div></div>

<h4 id="2-映射map">2. 映射（Map）</h4>
<ul>
  <li>键值对集合，无序，使用 <code class="language-plaintext highlighter-rouge">make(map[key]value)</code> 初始化。</li>
  <li>安全访问：需配合 <code class="language-plaintext highlighter-rouge">sync.Map</code> 或互斥锁应对并发。
```go
package main</li>
</ul>

<p>import (
    “fmt”
    “sync”
)</p>

<p>func main() {
    // 初始化 Map
    m := make(map[string]int)
    m[“one”] = 1
    m[“two”] = 2
    fmt.Println(m)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 并发安全的 Map
var syncMap sync.Map
syncMap.Store("three", 3)
value, ok := syncMap.Load("three")
if ok {
    fmt.Println(value)
} } ```
</code></pre></div></div>

<h4 id="3-结构体struct">3. 结构体（Struct）</h4>
<ul>
  <li>组合不同类型字段，支持匿名字段和嵌套，实现组合式“继承”。</li>
  <li>方法定义：<code class="language-plaintext highlighter-rouge">func (s Struct) method() {}</code>，接收者可为值或指针。
```go
package main</li>
</ul>

<p>import (
    “fmt”
)</p>

<p>// 定义结构体
type Animal struct {
    Name string
    Age  int
}</p>

<p>// 定义方法
func (a Animal) Speak() {
    fmt.Printf(“%s says hello!\n”, a.Name)
}</p>

<p>// 嵌套结构体
type Dog struct {
    Animal
    Breed string
}</p>

<p>func main() {
    dog := Dog{
        Animal: Animal{Name: “Buddy”, Age: 3},
        Breed:  “Golden Retriever”,
    }
    dog.Speak()
    fmt.Println(dog.Breed)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### 四、面向对象特性
#### 1. 封装
- 通过首字母大小写控制可见性：大写公有，小写私有。
```go
package main

import (
    "fmt"
)

// 公有结构体
type PublicStruct struct {
    PublicField string
    privateField string
}

// 公有方法
func (p PublicStruct) PublicMethod() {
    fmt.Println("Public method called")
}

// 私有方法
func (p PublicStruct) privateMethod() {
    fmt.Println("Private method called")
}

func main() {
    ps := PublicStruct{PublicField: "Hello"}
    ps.PublicMethod()
    // ps.privateMethod() // 无法调用私有方法
}
</code></pre></div></div>

<h4 id="2-接口interface">2. 接口（Interface）</h4>
<ul>
  <li>隐式实现：类型无需显式声明接口，只需实现全部方法（Duck Typing）。</li>
  <li>空接口 <code class="language-plaintext highlighter-rouge">interface{}</code> 可接收任意类型（类似 <code class="language-plaintext highlighter-rouge">any</code>）。
```go
package main</li>
</ul>

<p>import (
    “fmt”
)</p>

<p>// 定义接口
type Shape interface {
    Area() float64
}</p>

<p>// 定义结构体
type Circle struct {
    Radius float64
}</p>

<p>// 实现接口方法
func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}</p>

<p>func printArea(s Shape) {
    fmt.Println(“Area:”, s.Area())
}</p>

<p>func main() {
    circle := Circle{Radius: 5}
    printArea(circle)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 空接口
var anyValue interface{}
anyValue = 10
fmt.Println(anyValue)
anyValue = "Hello"
fmt.Println(anyValue) } ```
</code></pre></div></div>

<h4 id="3-多态">3. 多态</h4>
<ul>
  <li>接口变量可持有不同实现类型的实例，调用同名方法表现不同行为。
```go
package main</li>
</ul>

<p>import (
    “fmt”
)</p>

<p>// 定义接口
type Speaker interface {
    Speak()
}</p>

<p>// 定义结构体
type Dog struct{}
type Cat struct{}</p>

<p>// 实现接口方法
func (d Dog) Speak() {
    fmt.Println(“Woof!”)
}</p>

<p>func (c Cat) Speak() {
    fmt.Println(“Meow!”)
}</p>

<p>func makeSpeak(s Speaker) {
    s.Speak()
}</p>

<p>func main() {
    dog := Dog{}
    cat := Cat{}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makeSpeak(dog)
makeSpeak(cat) } ```
</code></pre></div></div>

<h3 id="五高级特性与工具">五、高级特性与工具</h3>
<h4 id="1-错误处理">1. 错误处理</h4>
<ul>
  <li>多返回值返回 <code class="language-plaintext highlighter-rouge">error</code> 对象，配合 <code class="language-plaintext highlighter-rouge">if err != nil</code> 检查。</li>
  <li>自定义错误：<code class="language-plaintext highlighter-rouge">errors.New()</code> 或实现 <code class="language-plaintext highlighter-rouge">error</code> 接口。
```go
package main</li>
</ul>

<p>import (
    “errors”
    “fmt”
)</p>

<p>func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New(“division by zero”)
    }
    return a / b, nil
}</p>

<p>func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println(“Error:”, err)
    } else {
        fmt.Println(“Result:”, result)
    }
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#### 2. 包管理
- **初始化**：`init()` 函数在包导入时自动执行。
- **依赖**：Go Modules 管理版本（`go.mod`）
```go
// main.go
package main

import (
    "fmt"
    "./mypackage"
)

func main() {
    mypackage.PrintMessage()
}

// mypackage/mypackage.go
package mypackage

import "fmt"

func init() {
    fmt.Println("Initializing mypackage")
}

func PrintMessage() {
    fmt.Println("Hello from mypackage")
}
</code></pre></div></div>

<h4 id="3-性能优化技巧">3. 性能优化技巧</h4>
<ul>
  <li><strong>内存复用</strong>：使用 <code class="language-plaintext highlighter-rouge">sync.Pool</code> 减少对象分配（如 <code class="language-plaintext highlighter-rouge">fasthttp</code> 复用 RequestCtx）。
```go
package main</li>
</ul>

<p>import (
    “fmt”
    “sync”
)</p>

<p>type MyObject struct {
    Data []int
}</p>

<p>var objectPool = sync.Pool{
    New: func() interface{} {
        return &amp;MyObject{Data: make([]int, 0, 100)}
    },
}</p>

<p>func main() {
    obj := objectPool.Get().(*MyObject)
    defer objectPool.Put(obj)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>obj.Data = append(obj.Data, 1, 2, 3)
fmt.Println(obj.Data) } ``` - **高效数据结构**：优先用 `[]byte` 替代 `string`（避免不可变性带来的内存复制）。 ```go package main
</code></pre></div></div>

<p>import (
    “fmt”
)</p>

<p>func main() {
    // 使用 []byte
    byteSlice := []byte(“Hello”)
    byteSlice = append(byteSlice, ‘ ‘, ‘W’, ‘o’, ‘r’, ‘l’, ‘d’)
    fmt.Println(string(byteSlice))
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#### 4. 常用命令
- `go build`：编译项目
- `go run`：编译并运行
- `go get`：安装依赖
- `go test`：执行测试
- `go mod init`：初始化模块管理

这些命令通常在终端中使用，例如：
```bash
# 初始化模块管理
go mod init myproject
# 安装依赖
go get github.com/some/package
# 编译项目
go build
# 编译并运行
go run main.go
# 执行测试
go test
</code></pre></div></div>]]></content><author><name></name></author><category term="Golang" /><summary type="html"><![CDATA[Golang学习笔记]]></summary></entry><entry><title type="html">数据库学习笔记</title><link href="http://localhost:4000/blog/sql/%E6%95%B0%E6%8D%AE%E5%BA%93/2025/06/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="数据库学习笔记" /><published>2025-06-01T00:00:00+08:00</published><updated>2025-06-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/sql/%E6%95%B0%E6%8D%AE%E5%BA%93/2025/06/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/sql/%E6%95%B0%E6%8D%AE%E5%BA%93/2025/06/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="数据库学习笔记">数据库学习笔记</h1>

<h3 id="一sql-基础与核心概念">一、SQL 基础与核心概念</h3>

<h4 id="1-什么是-sql">1. 什么是 SQL？</h4>
<ul>
  <li><strong>定义</strong>：结构化查询语言（Structured Query Language），用于与关系型数据库管理系统（RDBMS）如 MySQL, PostgreSQL, SQL Server, Oracle, SQLite 等进行通信。</li>
  <li><strong>主要功能</strong>：查询数据、插入数据、更新数据、删除数据、创建和管理数据库及表、设置权限等。</li>
  <li><strong>案例</strong>：假设我们使用 MySQL 数据库，要查询一个名为 <code class="language-plaintext highlighter-rouge">customers</code> 表中的所有数据，可以使用以下 SQL 语句：
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="2-核心概念">2. 核心概念</h4>

<ul>
  <li><strong>数据库</strong>：存储相关数据的容器。
    <ul>
      <li><strong>案例</strong>：在 MySQL 中创建一个名为 <code class="language-plaintext highlighter-rouge">ecommerce</code> 的数据库：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">ecommerce</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>表</strong>：数据库中的基本结构，由行（记录）和列（字段/属性）组成。每张表通常代表一个实体（如 <code class="language-plaintext highlighter-rouge">Customers</code>, <code class="language-plaintext highlighter-rouge">Orders</code>, <code class="language-plaintext highlighter-rouge">Products</code>）。
    <ul>
      <li><strong>案例</strong>：在 <code class="language-plaintext highlighter-rouge">ecommerce</code> 数据库中创建一个名为 <code class="language-plaintext highlighter-rouge">products</code> 的表：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">USE</span> <span class="n">ecommerce</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">products</span> <span class="p">(</span>
  <span class="n">product_id</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="n">product_name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
  <span class="n">price</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>列</strong>：表中的一个属性，定义了数据的类型（如 <code class="language-plaintext highlighter-rouge">INTEGER</code>, <code class="language-plaintext highlighter-rouge">VARCHAR(50)</code>, <code class="language-plaintext highlighter-rouge">DATE</code>, <code class="language-plaintext highlighter-rouge">BOOLEAN</code>）。
    <ul>
      <li><strong>案例</strong>：在 <code class="language-plaintext highlighter-rouge">products</code> 表中，<code class="language-plaintext highlighter-rouge">product_id</code> 列的数据类型为 <code class="language-plaintext highlighter-rouge">INT</code>，<code class="language-plaintext highlighter-rouge">product_name</code> 列的数据类型为 <code class="language-plaintext highlighter-rouge">VARCHAR(100)</code>，<code class="language-plaintext highlighter-rouge">price</code> 列的数据类型为 <code class="language-plaintext highlighter-rouge">DECIMAL(10, 2)</code>。</li>
    </ul>
  </li>
  <li><strong>行</strong>：表中的一个具体记录，包含各个列的值。
    <ul>
      <li><strong>案例</strong>：向 <code class="language-plaintext highlighter-rouge">products</code> 表中插入一行数据：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">products</span> <span class="p">(</span><span class="n">product_id</span><span class="p">,</span> <span class="n">product_name</span><span class="p">,</span> <span class="n">price</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'iPhone 14'</span><span class="p">,</span> <span class="mi">999</span><span class="p">.</span><span class="mi">99</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>主键</strong>：唯一标识表中每一行的列（或列组合）。值不能为 NULL 且必须唯一（如 <code class="language-plaintext highlighter-rouge">CustomerID</code>, <code class="language-plaintext highlighter-rouge">OrderID</code>）。
    <ul>
      <li><strong>案例</strong>：在创建 <code class="language-plaintext highlighter-rouge">customers</code> 表时，将 <code class="language-plaintext highlighter-rouge">customer_id</code> 列设置为主键：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">customers</span> <span class="p">(</span>
  <span class="n">customer_id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">customer_name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
  <span class="n">email</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>外键</strong>：一个表中的列（或列组合），其值引用另一个表的主键。用于建立表之间的关系（如 <code class="language-plaintext highlighter-rouge">Orders</code> 表中的 <code class="language-plaintext highlighter-rouge">CustomerID</code> 引用 <code class="language-plaintext highlighter-rouge">Customers</code> 表的主键）。
    <ul>
      <li><strong>案例</strong>：创建 <code class="language-plaintext highlighter-rouge">orders</code> 表，其中 <code class="language-plaintext highlighter-rouge">customer_id</code> 列作为外键引用 <code class="language-plaintext highlighter-rouge">customers</code> 表的 <code class="language-plaintext highlighter-rouge">customer_id</code> 列：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">orders</span> <span class="p">(</span>
  <span class="n">order_id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">order_date</span> <span class="nb">DATE</span><span class="p">,</span>
  <span class="n">customer_id</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">customer_id</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">customers</span><span class="p">(</span><span class="n">customer_id</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>模式</strong>：数据库的结构定义，包括表、列、数据类型、关系（外键）、约束等。
    <ul>
      <li><strong>案例</strong>：上述创建的 <code class="language-plaintext highlighter-rouge">ecommerce</code> 数据库中的 <code class="language-plaintext highlighter-rouge">customers</code> 表和 <code class="language-plaintext highlighter-rouge">orders</code> 表以及它们之间的关系就构成了一个简单的模式。</li>
    </ul>
  </li>
  <li><strong>约束</strong>：施加在列或表上的规则，确保数据的完整性和准确性。
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">PRIMARY KEY</code></strong>：主键约束。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">FOREIGN KEY</code></strong>：外键约束。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">NOT NULL</code></strong>：列值不能为空。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">UNIQUE</code></strong>：列值必须唯一（允许 NULL）。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">CHECK</code></strong>：确保列值满足特定条件（如 <code class="language-plaintext highlighter-rouge">Age &gt;= 18</code>）。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">DEFAULT</code></strong>：为列设置默认值。</li>
      <li><strong>案例</strong>：创建一个 <code class="language-plaintext highlighter-rouge">employees</code> 表，使用多种约束：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">employees</span> <span class="p">(</span>
  <span class="n">employee_id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">employee_name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">email</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">UNIQUE</span><span class="p">,</span>
  <span class="n">age</span> <span class="nb">INT</span> <span class="k">CHECK</span> <span class="p">(</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">),</span>
  <span class="n">department</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">'Unknown'</span>
<span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>索引</strong>：一种数据结构，用于加快对表中特定数据的查询速度（尤其是 <code class="language-plaintext highlighter-rouge">WHERE</code> 和 <code class="language-plaintext highlighter-rouge">JOIN</code>）。会占用额外空间并可能降低写入（<code class="language-plaintext highlighter-rouge">INSERT/UPDATE/DELETE</code>）速度。常见类型：B - Tree（最常用）、Hash 等。
    <ul>
      <li><strong>案例</strong>：在 <code class="language-plaintext highlighter-rouge">products</code> 表的 <code class="language-plaintext highlighter-rouge">product_name</code> 列上创建一个索引：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_product_name</span> <span class="k">ON</span> <span class="n">products</span> <span class="p">(</span><span class="n">product_name</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="二sql-语句分类ddl-dml-dql-dcl-tcl">二、SQL 语句分类（DDL, DML, DQL, DCL, TCL）</h3>

<h4 id="1-ddl-data-definition-language---数据定义语言用于定义和修改数据库结构">1. DDL (Data Definition Language) - 数据定义语言：用于定义和修改数据库结构。</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CREATE</code></strong>：创建数据库、表、索引、视图等对象。
    <ul>
      <li><strong>案例</strong>：创建一个新的数据库 <code class="language-plaintext highlighter-rouge">library</code> 和一个名为 <code class="language-plaintext highlighter-rouge">books</code> 的表，并在 <code class="language-plaintext highlighter-rouge">title</code> 列上创建索引：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">library</span><span class="p">;</span>
<span class="n">USE</span> <span class="n">library</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">books</span> <span class="p">(</span>
  <span class="n">book_id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">title</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span>
  <span class="n">author</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_title</span> <span class="k">ON</span> <span class="n">books</span> <span class="p">(</span><span class="n">title</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ALTER</code></strong>：修改现有数据库对象的结构。
    <ul>
      <li><strong>案例</strong>：在 <code class="language-plaintext highlighter-rouge">books</code> 表中添加一个新的列 <code class="language-plaintext highlighter-rouge">publication_date</code>：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">books</span> <span class="k">ADD</span> <span class="n">publication_date</span> <span class="nb">DATE</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">DROP</code></strong>：删除数据库、表、索引、视图等对象。
    <ul>
      <li><strong>案例</strong>：删除 <code class="language-plaintext highlighter-rouge">books</code> 表的索引 <code class="language-plaintext highlighter-rouge">idx_title</code> 和 <code class="language-plaintext highlighter-rouge">books</code> 表本身：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">INDEX</span> <span class="n">idx_title</span> <span class="k">ON</span> <span class="n">books</span><span class="p">;</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">books</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">TRUNCATE</code></strong>：快速删除表中的所有数据（比 <code class="language-plaintext highlighter-rouge">DELETE</code> 快，不记录日志，重置自增 ID），但保留表结构。<strong>不可回滚！</strong>
    <ul>
      <li><strong>案例</strong>：假设 <code class="language-plaintext highlighter-rouge">products</code> 表中有数据，使用 <code class="language-plaintext highlighter-rouge">TRUNCATE</code> 删除所有数据：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="n">products</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">RENAME</code></strong>：重命名表（具体语法可能因数据库而异）。
    <ul>
      <li><strong>案例</strong>：在 MySQL 中，将 <code class="language-plaintext highlighter-rouge">products</code> 表重命名为 <code class="language-plaintext highlighter-rouge">goods</code>：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RENAME</span> <span class="k">TABLE</span> <span class="n">products</span> <span class="k">TO</span> <span class="n">goods</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="2-dml-data-manipulation-language---数据操作语言用于操作表中的数据增删改">2. DML (Data Manipulation Language) - 数据操作语言：用于操作表中的数据（增删改）。</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">INSERT</code></strong>：向表中插入新行。
    <ul>
      <li><strong>案例</strong>：向 <code class="language-plaintext highlighter-rouge">goods</code> 表中插入一行数据：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">goods</span> <span class="p">(</span><span class="n">product_id</span><span class="p">,</span> <span class="n">product_name</span><span class="p">,</span> <span class="n">price</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Laptop'</span><span class="p">,</span> <span class="mi">1299</span><span class="p">.</span><span class="mi">99</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">UPDATE</code></strong>：修改表中现有的行。
    <ul>
      <li><strong>案例</strong>：将 <code class="language-plaintext highlighter-rouge">goods</code> 表中 <code class="language-plaintext highlighter-rouge">product_id</code> 为 1 的产品价格更新为 1399.99：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">goods</span> <span class="k">SET</span> <span class="n">price</span> <span class="o">=</span> <span class="mi">1399</span><span class="p">.</span><span class="mi">99</span> <span class="k">WHERE</span> <span class="n">product_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">DELETE</code></strong>：从表中删除行。
    <ul>
      <li><strong>案例</strong>：删除 <code class="language-plaintext highlighter-rouge">goods</code> 表中 <code class="language-plaintext highlighter-rouge">product_id</code> 为 1 的产品记录：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">goods</span> <span class="k">WHERE</span> <span class="n">product_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="3-dql-data-query-language---数据查询语言用于查询数据库中的数据核心是-select-语句">3. DQL (Data Query Language) - 数据查询语言：用于查询数据库中的数据。核心是 <code class="language-plaintext highlighter-rouge">SELECT</code> 语句。</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">SELECT</code></strong>：从一个或多个表中检索数据。
    <ul>
      <li><strong>案例</strong>：从 <code class="language-plaintext highlighter-rouge">customers</code> 表中选择 <code class="language-plaintext highlighter-rouge">customer_name</code> 和 <code class="language-plaintext highlighter-rouge">email</code> 列：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customer_name</span><span class="p">,</span> <span class="n">email</span> <span class="k">FROM</span> <span class="n">customers</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">SELECT</code> 语句核心子句详解</strong>：
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">SELECT</code></strong>：指定要返回的列或计算表达式。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">FROM</code></strong>：指定数据来源的表（或视图）。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">WHERE</code></strong>：<strong>过滤行</strong>，基于指定的条件 (<code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">&lt;&gt;</code>/<code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">BETWEEN</code>, <code class="language-plaintext highlighter-rouge">LIKE</code>, <code class="language-plaintext highlighter-rouge">IN</code>, <code class="language-plaintext highlighter-rouge">IS NULL</code>, <code class="language-plaintext highlighter-rouge">IS NOT NULL</code>, <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code>, <code class="language-plaintext highlighter-rouge">NOT</code>)。在分组和聚合<strong>之前</strong>应用。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">GROUP BY</code></strong>：将结果集按一个或多个列<strong>分组</strong>。通常与聚合函数 (<code class="language-plaintext highlighter-rouge">SUM</code>, <code class="language-plaintext highlighter-rouge">AVG</code>, <code class="language-plaintext highlighter-rouge">COUNT</code>, <code class="language-plaintext highlighter-rouge">MAX</code>, <code class="language-plaintext highlighter-rouge">MIN</code>) 一起使用。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">HAVING</code></strong>：<strong>过滤分组</strong>，基于聚合结果的条件。在 <code class="language-plaintext highlighter-rouge">GROUP BY</code> <strong>之后</strong>应用。类似于 <code class="language-plaintext highlighter-rouge">WHERE</code>，但作用于分组结果。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">ORDER BY</code></strong>：对结果集按一个或多个列<strong>排序</strong> (<code class="language-plaintext highlighter-rouge">ASC</code> 升序 - 默认, <code class="language-plaintext highlighter-rouge">DESC</code> 降序)。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">LIMIT</code> / <code class="language-plaintext highlighter-rouge">OFFSET</code></strong> (或 <code class="language-plaintext highlighter-rouge">TOP</code> / <code class="language-plaintext highlighter-rouge">FETCH</code> 等，具体语法因数据库而异)：限制返回的行数和跳过指定的行数（用于分页）。</li>
      <li><strong>执行顺序</strong>：<code class="language-plaintext highlighter-rouge">FROM</code> -&gt; <code class="language-plaintext highlighter-rouge">WHERE</code> -&gt; <code class="language-plaintext highlighter-rouge">GROUP BY</code> -&gt; <code class="language-plaintext highlighter-rouge">HAVING</code> -&gt; <code class="language-plaintext highlighter-rouge">SELECT</code> -&gt; <code class="language-plaintext highlighter-rouge">ORDER BY</code> -&gt; <code class="language-plaintext highlighter-rouge">LIMIT/OFFSET</code></li>
      <li><strong>案例</strong>：假设 <code class="language-plaintext highlighter-rouge">orders</code> 表中有 <code class="language-plaintext highlighter-rouge">order_id</code>、<code class="language-plaintext highlighter-rouge">customer_id</code> 和 <code class="language-plaintext highlighter-rouge">order_amount</code> 列，查询每个客户的订单总金额，只显示总金额大于 1000 的客户，并按总金额降序排序，取前 5 条记录：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customer_id</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">order_amount</span><span class="p">)</span> <span class="k">AS</span> <span class="n">total_amount</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">customer_id</span>
<span class="k">HAVING</span> <span class="k">SUM</span><span class="p">(</span><span class="n">order_amount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">total_amount</span> <span class="k">DESC</span>
<span class="k">LIMIT</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="4-dcl-data-control-language---数据控制语言用于控制数据库访问权限和安全">4. DCL (Data Control Language) - 数据控制语言：用于控制数据库访问权限和安全。</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">GRANT</code></strong>：授予用户或角色访问权限（如 <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>, <code class="language-plaintext highlighter-rouge">ALL PRIVILEGES</code>）。
    <ul>
      <li><strong>案例</strong>：授予用户 <code class="language-plaintext highlighter-rouge">user1</code> 对 <code class="language-plaintext highlighter-rouge">customers</code> 表的 <code class="language-plaintext highlighter-rouge">SELECT</code> 和 <code class="language-plaintext highlighter-rouge">INSERT</code> 权限：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">GRANT</span> <span class="k">SELECT</span><span class="p">,</span> <span class="k">INSERT</span> <span class="k">ON</span> <span class="n">customers</span> <span class="k">TO</span> <span class="s1">'user1'</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">REVOKE</code></strong>：撤销之前授予的权限。
    <ul>
      <li><strong>案例</strong>：撤销用户 <code class="language-plaintext highlighter-rouge">user1</code> 对 <code class="language-plaintext highlighter-rouge">customers</code> 表的 <code class="language-plaintext highlighter-rouge">INSERT</code> 权限：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">REVOKE</span> <span class="k">INSERT</span> <span class="k">ON</span> <span class="n">customers</span> <span class="k">FROM</span> <span class="s1">'user1'</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="5-tcl-transaction-control-language---事务控制语言用于管理数据库事务">5. TCL (Transaction Control Language) - 事务控制语言：用于管理数据库事务。</h4>

<ul>
  <li><strong>事务</strong>：作为单个逻辑工作单元执行的一系列操作，遵循 ACID 原则：
    <ul>
      <li><strong>A</strong>tomicity (原子性)：事务中的所有操作要么全部完成，要么全部不完成。</li>
      <li><strong>C</strong>onsistency (一致性)：事务必须使数据库从一个一致状态变换到另一个一致状态。</li>
      <li><strong>I</strong>solation (隔离性)：多个并发事务的执行互不干扰。</li>
      <li><strong>D</strong>urability (持久性)：一旦事务提交，其结果就是永久性的。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">BEGIN TRANSACTION</code> / <code class="language-plaintext highlighter-rouge">START TRANSACTION</code></strong>：显式开始一个事务。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">COMMIT</code></strong>：提交事务，使所有更改永久生效。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ROLLBACK</code></strong>：回滚事务，撤销所有未提交的更改。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">SAVEPOINT</code></strong>：在事务内设置保存点，允许部分回滚。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ROLLBACK TO SAVEPOINT</code></strong>：回滚到指定的保存点。
    <ul>
      <li><strong>案例</strong>：假设我们要进行一个转账操作，从账户 A 向账户 B 转账 100 元：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">accounts</span> <span class="k">SET</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">-</span> <span class="mi">100</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="s1">'A'</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">accounts</span> <span class="k">SET</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">100</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="s1">'B'</span><span class="p">;</span>
<span class="c1">-- 检查是否有错误，如果有则回滚</span>
<span class="n">IF</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">balance</span> <span class="k">FROM</span> <span class="n">accounts</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="s1">'A'</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">THEN</span>
  <span class="k">ROLLBACK</span><span class="p">;</span>
<span class="k">ELSE</span>
  <span class="k">COMMIT</span><span class="p">;</span>
<span class="k">END</span> <span class="n">IF</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="三高级查询与操作">三、高级查询与操作</h3>

<h4 id="1-表连接-join从多个相关表中检索数据">1. 表连接 (<code class="language-plaintext highlighter-rouge">JOIN</code>)：从多个相关表中检索数据。</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">INNER JOIN</code> (或 <code class="language-plaintext highlighter-rouge">JOIN</code>)</strong>：返回两个表中<strong>匹配</strong>的行。
    <ul>
      <li><strong>案例</strong>：假设 <code class="language-plaintext highlighter-rouge">customers</code> 表和 <code class="language-plaintext highlighter-rouge">orders</code> 表通过 <code class="language-plaintext highlighter-rouge">customer_id</code> 关联，查询每个客户的订单信息：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_name</span><span class="p">,</span> <span class="n">orders</span><span class="p">.</span><span class="n">order_id</span>
<span class="k">FROM</span> <span class="n">customers</span>
<span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">LEFT JOIN</code> (或 <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code>)</strong>：返回左表的所有行，以及右表中<strong>匹配</strong>的行（无匹配则为 NULL）。
    <ul>
      <li><strong>案例</strong>：查询所有客户及其订单信息，如果客户没有订单，订单信息显示为 NULL：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_name</span><span class="p">,</span> <span class="n">orders</span><span class="p">.</span><span class="n">order_id</span>
<span class="k">FROM</span> <span class="n">customers</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">RIGHT JOIN</code> (或 <code class="language-plaintext highlighter-rouge">RIGHT OUTER JOIN</code>)</strong>：返回右表的所有行，以及左表中<strong>匹配</strong>的行（无匹配则为 NULL）。(较少使用，通常可以用 <code class="language-plaintext highlighter-rouge">LEFT JOIN</code> 重写)。
    <ul>
      <li><strong>案例</strong>：查询所有订单及其对应的客户信息，如果订单没有对应的客户，客户信息显示为 NULL：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_name</span><span class="p">,</span> <span class="n">orders</span><span class="p">.</span><span class="n">order_id</span>
<span class="k">FROM</span> <span class="n">customers</span>
<span class="k">RIGHT</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">FULL JOIN</code> (或 <code class="language-plaintext highlighter-rouge">FULL OUTER JOIN</code>)</strong>：返回两个表中所有的行，匹配的行连接，无匹配的部分用 NULL 填充。
    <ul>
      <li><strong>案例</strong>：查询所有客户和订单信息，无论是否匹配：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_name</span><span class="p">,</span> <span class="n">orders</span><span class="p">.</span><span class="n">order_id</span>
<span class="k">FROM</span> <span class="n">customers</span>
<span class="k">FULL</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">CROSS JOIN</code></strong>：返回两个表的笛卡尔积（所有可能的行组合）。通常需要 <code class="language-plaintext highlighter-rouge">WHERE</code> 或 <code class="language-plaintext highlighter-rouge">ON</code> 来过滤。
    <ul>
      <li><strong>案例</strong>：假设 <code class="language-plaintext highlighter-rouge">products</code> 表和 <code class="language-plaintext highlighter-rouge">categories</code> 表，生成它们的笛卡尔积：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">products</span><span class="p">.</span><span class="n">product_name</span><span class="p">,</span> <span class="n">categories</span><span class="p">.</span><span class="n">category_name</span>
<span class="k">FROM</span> <span class="n">products</span>
<span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">categories</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ON</code> vs <code class="language-plaintext highlighter-rouge">WHERE</code></strong>：<code class="language-plaintext highlighter-rouge">ON</code> 指定连接条件（连接哪部分数据），<code class="language-plaintext highlighter-rouge">WHERE</code> 指定连接后结果的过滤条件。
    <ul>
      <li><strong>案例</strong>：查询 <code class="language-plaintext highlighter-rouge">customers</code> 表和 <code class="language-plaintext highlighter-rouge">orders</code> 表中订单金额大于 100 的记录：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_name</span><span class="p">,</span> <span class="n">orders</span><span class="p">.</span><span class="n">order_amount</span>
<span class="k">FROM</span> <span class="n">customers</span>
<span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span>
<span class="k">WHERE</span> <span class="n">orders</span><span class="p">.</span><span class="n">order_amount</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="2-聚合函数对一组值进行计算并返回单个值">2. 聚合函数：对一组值进行计算并返回单个值。</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">COUNT()</code></strong>：计算行数（<code class="language-plaintext highlighter-rouge">COUNT(*)</code> 或 <code class="language-plaintext highlighter-rouge">COUNT(column_name)</code> - 后者忽略 NULL）。
    <ul>
      <li><strong>案例</strong>：计算 <code class="language-plaintext highlighter-rouge">customers</code> 表中的客户数量：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">customers</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">SUM()</code></strong>：计算数值列的总和。
    <ul>
      <li><strong>案例</strong>：计算 <code class="language-plaintext highlighter-rouge">orders</code> 表中所有订单的总金额：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">order_amount</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">orders</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">AVG()</code></strong>：计算数值列的平均值。
    <ul>
      <li><strong>案例</strong>：计算 <code class="language-plaintext highlighter-rouge">products</code> 表中产品的平均价格：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">AVG</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">products</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">MAX()</code></strong>：返回列的最大值。
    <ul>
      <li><strong>案例</strong>：查询 <code class="language-plaintext highlighter-rouge">products</code> 表中价格最高的产品价格：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">products</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">MIN()</code></strong>：返回列的最小值。
    <ul>
      <li><strong>案例</strong>：查询 <code class="language-plaintext highlighter-rouge">products</code> 表中价格最低的产品价格：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">MIN</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">products</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">GROUP_CONCAT()</code> (MySQL) / <code class="language-plaintext highlighter-rouge">STRING_AGG()</code> (SQL Server, PostgreSQL)</strong>：将分组中的字符串连接成一个字符串。
    <ul>
      <li><strong>案例</strong>：在 MySQL 中，将 <code class="language-plaintext highlighter-rouge">products</code> 表中每个类别下的产品名称连接成一个字符串：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">category</span><span class="p">,</span> <span class="n">GROUP_CONCAT</span><span class="p">(</span><span class="n">product_name</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">products</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">category</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="3-子查询嵌套在其他查询select-insert-update-delete-where-from-having内部的查询">3. 子查询：嵌套在其他查询（<code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>, <code class="language-plaintext highlighter-rouge">WHERE</code>, <code class="language-plaintext highlighter-rouge">FROM</code>, <code class="language-plaintext highlighter-rouge">HAVING</code>）内部的查询。</h4>

<ul>
  <li><strong>标量子查询</strong>：返回单个值（一行一列），可以像常量一样用在表达式中（如 <code class="language-plaintext highlighter-rouge">SELECT ... WHERE col = (SELECT ...)</code>）。
    <ul>
      <li><strong>案例</strong>：查询价格等于平均价格的产品：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">products</span>
<span class="k">WHERE</span> <span class="n">price</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">AVG</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">products</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>行子查询</strong>：返回单行（多列）。
    <ul>
      <li><strong>案例</strong>：假设 <code class="language-plaintext highlighter-rouge">customers</code> 表和 <code class="language-plaintext highlighter-rouge">orders</code> 表，查询与客户 ID 为 1 的客户具有相同姓名和邮箱的客户的订单信息：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">orders</span>
<span class="k">WHERE</span> <span class="n">customer_id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">customer_id</span> <span class="k">FROM</span> <span class="n">customers</span>
                <span class="k">WHERE</span> <span class="p">(</span><span class="n">customer_name</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">customer_name</span><span class="p">,</span> <span class="n">email</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="n">customer_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">));</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>列子查询</strong>：返回单列（多行），常与 <code class="language-plaintext highlighter-rouge">IN</code>, <code class="language-plaintext highlighter-rouge">ANY</code>, <code class="language-plaintext highlighter-rouge">ALL</code> 等运算符一起用。
    <ul>
      <li><strong>案例</strong>：查询购买了产品 ID 为 1 的产品的客户信息：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">WHERE</span> <span class="n">customer_id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">customer_id</span> <span class="k">FROM</span> <span class="n">orders</span> <span class="k">WHERE</span> <span class="n">product_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>表子查询</strong>：返回一个结果集（多行多列），通常用在 <code class="language-plaintext highlighter-rouge">FROM</code> 子句中（派生表）。
    <ul>
      <li><strong>案例</strong>：查询每个类别下产品的平均价格：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">category</span><span class="p">,</span> <span class="n">avg_price</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">category</span><span class="p">,</span> <span class="k">AVG</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">AS</span> <span class="n">avg_price</span> <span class="k">FROM</span> <span class="n">products</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">category</span><span class="p">)</span> <span class="k">AS</span> <span class="n">subquery</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>相关子查询</strong>：子查询的执行依赖于外部查询的当前行值。
    <ul>
      <li><strong>案例</strong>：查询每个客户的最新订单信息：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customer_id</span><span class="p">,</span> <span class="n">order_id</span><span class="p">,</span> <span class="n">order_date</span>
<span class="k">FROM</span> <span class="n">orders</span> <span class="n">o1</span>
<span class="k">WHERE</span> <span class="n">order_date</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">order_date</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">orders</span> <span class="n">o2</span> <span class="k">WHERE</span> <span class="n">o2</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">o1</span><span class="p">.</span><span class="n">customer_id</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="4-集合操作合并两个或多个-select-语句的结果集列数和数据类型必须兼容">4. 集合操作：合并两个或多个 <code class="language-plaintext highlighter-rouge">SELECT</code> 语句的结果集（列数和数据类型必须兼容）。</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">UNION</code></strong>：返回<strong>不重复</strong>的结果（自动去重）。
    <ul>
      <li><strong>案例</strong>：假设 <code class="language-plaintext highlighter-rouge">table1</code> 和 <code class="language-plaintext highlighter-rouge">table2</code> 结构相同，合并它们的结果集并去重：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">column1</span> <span class="k">FROM</span> <span class="n">table1</span>
<span class="k">UNION</span>
<span class="k">SELECT</span> <span class="n">column1</span> <span class="k">FROM</span> <span class="n">table2</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">UNION ALL</code></strong>：返回<strong>所有</strong>结果（包括重复）。
    <ul>
      <li><strong>案例</strong>：合并 <code class="language-plaintext highlighter-rouge">table1</code> 和 <code class="language-plaintext highlighter-rouge">table2</code> 的结果集，包括重复记录：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">column1</span> <span class="k">FROM</span> <span class="n">table1</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="n">column1</span> <span class="k">FROM</span> <span class="n">table2</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">INTERSECT</code></strong>：返回两个查询结果集的<strong>交集</strong>（共同存在的行）。
    <ul>
      <li><strong>案例</strong>：查询 <code class="language-plaintext highlighter-rouge">table1</code> 和 <code class="language-plaintext highlighter-rouge">table2</code> 中共同的记录：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">column1</span> <span class="k">FROM</span> <span class="n">table1</span>
<span class="k">INTERSECT</span>
<span class="k">SELECT</span> <span class="n">column1</span> <span class="k">FROM</span> <span class="n">table2</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">EXCEPT</code> (或 <code class="language-plaintext highlighter-rouge">MINUS</code>)</strong>：返回第一个查询结果集<strong>减去</strong>第二个查询结果集中也存在的行（差集）。
    <ul>
      <li><strong>案例</strong>：查询 <code class="language-plaintext highlighter-rouge">table1</code> 中存在但 <code class="language-plaintext highlighter-rouge">table2</code> 中不存在的记录：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">column1</span> <span class="k">FROM</span> <span class="n">table1</span>
<span class="k">EXCEPT</span>
<span class="k">SELECT</span> <span class="n">column1</span> <span class="k">FROM</span> <span class="n">table2</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="5-窗口函数对一组相关的行称为窗口进行计算并为查询结果集中的每一行返回一个值不会减少行数">5. 窗口函数：对一组相关的行（称为“窗口”）进行计算，并为查询结果集中的每一行返回一个值。不会减少行数。</h4>

<ul>
  <li><strong>语法</strong>：<code class="language-plaintext highlighter-rouge">function_name(expression) OVER ([PARTITION BY partition_columns] [ORDER BY order_columns [ASC|DESC]] [frame_clause])</code></li>
  <li><strong>常用函数</strong>：
    <ul>
      <li><strong>排名函数</strong>：<code class="language-plaintext highlighter-rouge">ROW_NUMBER()</code>, <code class="language-plaintext highlighter-rouge">RANK()</code>, <code class="language-plaintext highlighter-rouge">DENSE_RANK()</code>, <code class="language-plaintext highlighter-rouge">NTILE(n)</code></li>
      <li><strong>聚合函数</strong>：<code class="language-plaintext highlighter-rouge">SUM()</code>, <code class="language-plaintext highlighter-rouge">AVG()</code>, <code class="language-plaintext highlighter-rouge">COUNT()</code>, <code class="language-plaintext highlighter-rouge">MAX()</code>, <code class="language-plaintext highlighter-rouge">MIN()</code> (作为窗口函数使用)</li>
      <li><strong>取值函数</strong>：<code class="language-plaintext highlighter-rouge">LAG(column, offset)</code>, <code class="language-plaintext highlighter-rouge">LEAD(column, offset)</code>, <code class="language-plaintext highlighter-rouge">FIRST_VALUE(column)</code>, <code class="language-plaintext highlighter-rouge">LAST_VALUE(column)</code></li>
      <li><strong>案例</strong>：使用 <code class="language-plaintext highlighter-rouge">ROW_NUMBER()</code> 函数为 <code class="language-plaintext highlighter-rouge">orders</code> 表中的每条记录按订单日期排序并编号：
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">order_id</span><span class="p">,</span> <span class="n">order_date</span><span class="p">,</span>
 <span class="n">ROW_NUMBER</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">order_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">row_num</span>
<span class="k">FROM</span> <span class="n">orders</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="6-视图-view基于-sql-语句结果集的虚拟表简化复杂查询提供安全访问层">6. 视图 (<code class="language-plaintext highlighter-rouge">VIEW</code>)：基于 SQL 语句结果集的虚拟表。简化复杂查询、提供安全访问层。</h4>

<ul>
  <li><strong>案例</strong>：创建一个视图 <code class="language-plaintext highlighter-rouge">customer_orders</code>，显示每个客户的订单信息：
```sql
CREATE VIEW customer_orders AS
SELECT customers.customer_name, orders.order_id, orders.order_date
FROM customers
JOIN orders ON customers.customer_id = orders.customer_id;</li>
</ul>

<p>SELECT * FROM customer_orders;</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#### 7. 存储过程 (`PROCEDURE`)：存储在数据库中的一组预编译的 SQL 语句。可接受参数、执行复杂逻辑、提高性能（减少网络传输）、增强安全性。

- **案例**：创建一个存储过程 `get_customer_orders`，根据客户 ID 查询该客户的订单信息：
```sql
DELIMITER //
CREATE PROCEDURE get_customer_orders(IN customer_id_param INT)
BEGIN
    SELECT order_id, order_date
    FROM orders
    WHERE customer_id = customer_id_param;
END //
DELIMITER ;

CALL get_customer_orders(1);
</code></pre></div></div>

<h4 id="8-函数-function存储在数据库中的可重用代码块接受参数执行计算并返回一个值">8. 函数 (<code class="language-plaintext highlighter-rouge">FUNCTION</code>)：存储在数据库中的可重用代码块，接受参数、执行计算并<strong>返回一个值</strong>。</h4>

<ul>
  <li><strong>案例</strong>：创建一个函数 <code class="language-plaintext highlighter-rouge">calculate_total_amount</code>，根据订单 ID 计算该订单的总金额：
```sql
DELIMITER //
CREATE FUNCTION calculate_total_amount(order_id_param INT)
RETURNS DECIMAL(10, 2)
DETERMINISTIC
BEGIN
  DECLARE total_amount DECIMAL(10, 2);
  SELECT SUM(quantity * price) INTO total_amount
  FROM order_items
  WHERE order_id = order_id_param;
  RETURN total_amount;
END //
DELIMITER ;</li>
</ul>

<p>SELECT calculate_total_amount(1);</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#### 9. 触发器 (`TRIGGER`)：在表上发生特定事件（`INSERT`, `UPDATE`, `DELETE`）之前或之后自动执行的一段代码。用于强制业务规则、审计、维护衍生数据等。

- **案例**：创建一个触发器 `before_insert_order`，在向 `orders` 表插入记录之前，检查订单日期是否为未来日期，如果是则抛出错误：
```sql
DELIMITER //
CREATE TRIGGER before_insert_order
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    IF NEW.order_date &gt; CURDATE() THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Order date cannot be in the future';
    END IF;
END //
DELIMITER ;
</code></pre></div></div>

<h4 id="10-正则表达式使用-regexp-或-rlike-运算符进行更复杂的模式匹配数据库支持程度不同">10. 正则表达式：使用 <code class="language-plaintext highlighter-rouge">REGEXP</code> 或 <code class="language-plaintext highlighter-rouge">RLIKE</code> 运算符进行更复杂的模式匹配（数据库支持程度不同）。</h4>

<ul>
  <li><strong>案例</strong>：查询 <code class="language-plaintext highlighter-rouge">customers</code> 表中邮箱以 <code class="language-plaintext highlighter-rouge">.com</code> 结尾的客户信息：
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">WHERE</span> <span class="n">email</span> <span class="n">REGEXP</span> <span class="s1">'.com$'</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="四关键注意事项与最佳实践">四、关键注意事项与最佳实践</h3>

<h4 id="1-null-处理">1. <code class="language-plaintext highlighter-rouge">NULL</code> 处理</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">NULL</code> 表示未知或缺失的值。</li>
  <li>任何值与 <code class="language-plaintext highlighter-rouge">NULL</code> 比较（使用 <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">&lt;&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code> 等）结果都是 <code class="language-plaintext highlighter-rouge">NULL</code> (相当于 <code class="language-plaintext highlighter-rouge">FALSE</code> 在 <code class="language-plaintext highlighter-rouge">WHERE</code> 中)。</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">IS NULL</code> 或 <code class="language-plaintext highlighter-rouge">IS NOT NULL</code> 来检查 <code class="language-plaintext highlighter-rouge">NULL</code>。</li>
  <li>聚合函数（如 <code class="language-plaintext highlighter-rouge">COUNT(column)</code>）通常忽略 <code class="language-plaintext highlighter-rouge">NULL</code>。</li>
  <li>连接操作中，<code class="language-plaintext highlighter-rouge">NULL</code> 不等于 <code class="language-plaintext highlighter-rouge">NULL</code>（不会匹配）。</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">COALESCE(expr1, expr2, ...)</code> 返回参数列表中第一个非 <code class="language-plaintext highlighter-rouge">NULL</code> 的值。使用 <code class="language-plaintext highlighter-rouge">NULLIF(expr1, expr2)</code> 如果两个表达式相等则返回 <code class="language-plaintext highlighter-rouge">NULL</code>。</li>
  <li><strong>案例</strong>：查询 <code class="language-plaintext highlighter-rouge">customers</code> 表中邮箱为空的客户信息：
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">WHERE</span> <span class="n">email</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="2-性能优化">2. 性能优化</h4>

<ul>
  <li><strong>合理使用索引</strong>：在经常用于 <code class="language-plaintext highlighter-rouge">WHERE</code>, <code class="language-plaintext highlighter-rouge">JOIN</code>, <code class="language-plaintext highlighter-rouge">ORDER BY</code> 的列上创建索引。避免在频繁更新的列上过多索引。</li>
  <li><strong>避免 <code class="language-plaintext highlighter-rouge">SELECT *</code></strong>：只选择需要的列，减少数据传输量和 I/O。</li>
  <li><strong>优化 <code class="language-plaintext highlighter-rouge">WHERE</code> 子句</strong>：避免在索引列上使用函数或计算（如 <code class="language-plaintext highlighter-rouge">WHERE YEAR(date_column) = 2023</code> 不如 <code class="language-plaintext highlighter-rouge">WHERE date_column BETWEEN '2023-01-01' AND '2023-12-31'</code> 高效）。</li>
  <li><strong>使用 <code class="language-plaintext highlighter-rouge">EXPLAIN</code> / <code class="language-plaintext highlighter-rouge">EXPLAIN ANALYZE</code></strong>：分析查询执行计划，了解数据库如何执行你的查询，找出性能瓶颈（如全表扫描）。</li>
  <li><strong>关注 <code class="language-plaintext highlighter-rouge">JOIN</code> 效率</strong>：确保连接条件有索引。避免不必要的笛卡尔积。</li>
  <li><strong>批处理操作</strong>：减少频繁的单条 <code class="language-plaintext highlighter-rouge">INSERT/UPDATE/DELETE</code>，考虑批量操作。</li>
  <li><strong>数据库特定优化</strong>：了解你所使用的数据库（MySQL, PostgreSQL 等）的特定优化技巧和配置参数。</li>
  <li><strong>案例</strong>：分析一个查询的执行计划：
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">orders</span> <span class="k">WHERE</span> <span class="n">order_date</span> <span class="k">BETWEEN</span> <span class="s1">'2023-01-01'</span> <span class="k">AND</span> <span class="s1">'2023-12-31'</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="3-sql-注入防御">3. SQL 注入防御</h4>

<ul>
  <li><strong>永远不要</strong>直接将用户输入拼接到 SQL 语句中！</li>
  <li><strong>使用参数化查询（Prepared Statements）或存储过程</strong>：这是最有效、最安全的防御手段。数据库引擎会将输入视为数据而非可执行代码。</li>
  <li><strong>使用 ORM 框架</strong>：Object - Relational Mapping 框架通常内置了参数化查询。</li>
  <li><strong>转义用户输入</strong>：如果必须拼接（不推荐），务必使用数据库提供的转义函数（如 <code class="language-plaintext highlighter-rouge">mysqli_real_escape_string</code> for PHP/MySQL），但这只是最后一道防线且不够可靠。</li>
  <li><strong>最小权限原则</strong>：数据库连接账户只赋予其完成任务所需的最小权限（避免使用 <code class="language-plaintext highlighter-rouge">root</code>/<code class="language-plaintext highlighter-rouge">sa</code> 账户连接应用）。</li>
  <li><strong>案例</strong>：在 PHP 中使用参数化查询：
```php
&lt;?php
$servername = “localhost”;
$username = “username”;
$password = “password”;
$dbname = “myDB”;</li>
</ul>

<p>// 创建连接
$conn = new mysqli($servername, $username, $password, $dbname);</p>

<p>// 检查连接
if ($conn-&gt;connect_error) {
    die(“连接失败: “ . $conn-&gt;connect_error);
}</p>

<p>// 预处理语句
$stmt = $conn-&gt;prepare(“SELECT * FROM customers WHERE customer_name = ?”);
$stmt-&gt;bind_param(“s”, $customer_name);</p>

<p>// 设置参数并执行
$customer_name = $_GET[‘customer_name’];
$stmt-&gt;execute();</p>

<p>$result = $stmt-&gt;get_result();
if ($result-&gt;num_rows &gt; 0) {
    while($row = $result-&gt;fetch_assoc()) {
        echo “ID: “ . $row[“customer_id”]. “ - Name: “ . $row[“customer_name”]. “<br />”;
    }
} else {
    echo “0 结果”;
}
$stmt-&gt;close();
$conn-&gt;close();
?&gt;
```</p>]]></content><author><name></name></author><category term="SQL" /><category term="数据库" /><summary type="html"><![CDATA[数据库学习笔记]]></summary></entry><entry><title type="html">Matlab学习笔记</title><link href="http://localhost:4000/blog/matlab/2025/05/31/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="Matlab学习笔记" /><published>2025-05-31T00:00:00+08:00</published><updated>2025-05-31T00:00:00+08:00</updated><id>http://localhost:4000/blog/matlab/2025/05/31/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/matlab/2025/05/31/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="matlab学习笔记">MATLAB学习笔记</h1>

<h2 id="一matlab基础">一、MATLAB基础</h2>
<h3 id="11-界面介绍">1.1 界面介绍</h3>
<p>MATLAB界面主要包含命令窗口（Command Window）、工作区（Workspace）、当前文件夹窗口（Current Folder）、编辑器（Editor）和图形窗口（Figure Window）等部分。</p>
<ul>
  <li><strong>命令窗口</strong>：用于输入命令并即时显示结果。例如，在命令窗口输入 <code class="language-plaintext highlighter-rouge">2 + 3</code>，回车后会显示 <code class="language-plaintext highlighter-rouge">ans = 5</code>，这里 <code class="language-plaintext highlighter-rouge">ans</code> 是默认的结果存储变量。</li>
  <li><strong>工作区</strong>：展示当前创建或导入的所有变量及其属性，如变量名、数据类型、大小等。</li>
  <li><strong>当前文件夹窗口</strong>：管理MATLAB的工作路径，方便查找和调用相关文件。</li>
  <li><strong>编辑器</strong>：用于创建、编辑和保存 <code class="language-plaintext highlighter-rouge">.m</code> 脚本文件和函数文件。</li>
  <li><strong>图形窗口</strong>：显示绘制的各类图形，如二维图、三维图等。</li>
</ul>

<h3 id="12-基本操作">1.2 基本操作</h3>
<ul>
  <li><strong>启动MATLAB</strong>：通过快捷方式或开始菜单找到MATLAB程序并启动。</li>
  <li><strong>执行命令</strong>：在命令窗口直接输入命令，如数学运算、函数调用等。例如 <code class="language-plaintext highlighter-rouge">sqrt(16)</code> 会返回 <code class="language-plaintext highlighter-rouge">4</code>。</li>
  <li><strong>查看帮助文档</strong>：使用 <code class="language-plaintext highlighter-rouge">help</code> 命令，如 <code class="language-plaintext highlighter-rouge">help plot</code> 可以查看 <code class="language-plaintext highlighter-rouge">plot</code> 函数的详细用法和示例。</li>
  <li><strong>管理文件路径</strong>：通过 <code class="language-plaintext highlighter-rouge">pathtool</code> 命令打开路径管理器，添加、删除或调整MATLAB搜索文件的路径。</li>
</ul>

<h2 id="二变量与数据类型">二、变量与数据类型</h2>
<h3 id="21-变量定义">2.1 变量定义</h3>
<ul>
  <li>变量名区分大小写，且必须以字母开头，可以包含字母、数字和下划线。例如 <code class="language-plaintext highlighter-rouge">myVariable1</code> 是合法的变量名，而 <code class="language-plaintext highlighter-rouge">1myVariable</code> 是非法的。</li>
  <li>在MATLAB中，不需要预先声明变量类型，直接赋值即可创建变量。如 <code class="language-plaintext highlighter-rouge">a = 5;</code> 就创建了一个名为 <code class="language-plaintext highlighter-rouge">a</code> 的变量并赋值为 <code class="language-plaintext highlighter-rouge">5</code>。</li>
</ul>

<h3 id="22-数据类型">2.2 数据类型</h3>
<h4 id="221-数值型">2.2.1 数值型</h4>
<ul>
  <li><strong>整数</strong>：包括有符号整数（如 <code class="language-plaintext highlighter-rouge">int8</code>、<code class="language-plaintext highlighter-rouge">int16</code>、<code class="language-plaintext highlighter-rouge">int32</code>、<code class="language-plaintext highlighter-rouge">int64</code>）和无符号整数（如 <code class="language-plaintext highlighter-rouge">uint8</code>、<code class="language-plaintext highlighter-rouge">uint16</code>、<code class="language-plaintext highlighter-rouge">uint32</code>、<code class="language-plaintext highlighter-rouge">uint64</code>）。不同类型表示的数值范围不同，例如 <code class="language-plaintext highlighter-rouge">int8</code> 能表示的范围是 <code class="language-plaintext highlighter-rouge">-128</code> 到 <code class="language-plaintext highlighter-rouge">127</code>，<code class="language-plaintext highlighter-rouge">uint8</code> 能表示的范围是 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">255</code>。</li>
  <li><strong>浮点数</strong>：分为单精度浮点数（<code class="language-plaintext highlighter-rouge">single</code>）和双精度浮点数（<code class="language-plaintext highlighter-rouge">double</code>）。双精度是MATLAB默认的数值类型，能提供更高的精度。例如 <code class="language-plaintext highlighter-rouge">x = 3.14159;</code> 这里 <code class="language-plaintext highlighter-rouge">x</code> 就是双精度浮点数。
案例：创建一个 <code class="language-plaintext highlighter-rouge">int16</code> 类型的变量并进行简单运算。
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="nb">int16</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int16</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">% c 也是 int16 类型</span>
</code></pre></div>    </div>
    <h4 id="222-字符型与字符串">2.2.2 字符型与字符串</h4>
  </li>
  <li><strong>字符</strong>：用单引号括起来表示，如 <code class="language-plaintext highlighter-rouge">'a'</code>。</li>
  <li><strong>字符串</strong>：由多个字符组成，用双引号括起来。在MATLAB中，字符串本质上是字符数组。例如 <code class="language-plaintext highlighter-rouge">str = "Hello, MATLAB!";</code>
案例：获取字符串的长度。
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">str</span> <span class="o">=</span> <span class="s2">"Hello, MATLAB!"</span><span class="p">;</span>
<span class="n">len</span> <span class="o">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="c1">% len 的值为 14</span>
</code></pre></div>    </div>
    <h4 id="223-逻辑型">2.2.3 逻辑型</h4>
    <p>逻辑型数据只有两个取值：<code class="language-plaintext highlighter-rouge">true</code>（对应数值 <code class="language-plaintext highlighter-rouge">1</code>）和 <code class="language-plaintext highlighter-rouge">false</code>（对应数值 <code class="language-plaintext highlighter-rouge">0</code>）。常用于条件判断和逻辑运算。
案例：判断一个数是否大于 <code class="language-plaintext highlighter-rouge">10</code>。</p>
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="nb">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">% result 为 true</span>
</code></pre></div>    </div>
    <h4 id="224-数组与矩阵">2.2.4 数组与矩阵</h4>
  </li>
  <li><strong>数组</strong>：可以是一维、二维或多维的。一维数组类似向量，二维数组类似矩阵，多维数组则用于更复杂的数据结构。例如创建一个一维数组 <code class="language-plaintext highlighter-rouge">arr = [1, 2, 3, 4];</code></li>
  <li><strong>矩阵</strong>：是二维数组的一种特殊形式，常用于线性代数运算。创建矩阵时，元素之间用空格或逗号分隔行内元素，用分号分隔不同行。例如 <code class="language-plaintext highlighter-rouge">mat = [1 2 3; 4 5 6; 7 8 9];</code>
案例：创建一个3x3的单位矩阵。
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div>    </div>
    <h4 id="225-结构体">2.2.5 结构体</h4>
    <p>结构体是一种可以包含不同数据类型的复合数据类型。通过字段名来访问其中的数据。
案例：创建一个包含学生信息的结构体。</p>
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">student</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"John"</span><span class="p">;</span>
<span class="n">student</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">student</span><span class="o">.</span><span class="n">gpa</span> <span class="o">=</span> <span class="mf">3.5</span><span class="p">;</span>
</code></pre></div>    </div>
    <h4 id="226-元胞数组">2.2.6 元胞数组</h4>
    <p>元胞数组可以存储不同类型的数据，与结构体不同的是，元胞数组通过索引来访问元素，而结构体通过字段名访问。
案例：创建一个包含字符串、数值和矩阵的元胞数组。</p>
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cellArray</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"string"</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span> <span class="p">};</span>
</code></pre></div>    </div>
    <h3 id="23-数据类型转换">2.3 数据类型转换</h3>
    <p>可以使用函数进行数据类型转换，如 <code class="language-plaintext highlighter-rouge">double()</code>、<code class="language-plaintext highlighter-rouge">int()</code>、<code class="language-plaintext highlighter-rouge">char()</code>、<code class="language-plaintext highlighter-rouge">logical()</code> 等。
案例：将一个整数转换为双精度浮点数。</p>
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">double</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">% b 现在是双精度浮点数</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="三矩阵与数组操作">三、矩阵与数组操作</h2>
<h3 id="31-矩阵创建">3.1 矩阵创建</h3>
<ul>
  <li><strong>直接输入法</strong>：如前面提到的 <code class="language-plaintext highlighter-rouge">mat = [1 2 3; 4 5 6; 7 8 9];</code></li>
  <li><strong>函数创建法</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">zeros(m, n)</code> 创建一个 <code class="language-plaintext highlighter-rouge">m</code> 行 <code class="language-plaintext highlighter-rouge">n</code> 列的全零矩阵。例如 <code class="language-plaintext highlighter-rouge">zeros(2, 3)</code> 创建一个2行3列的全零矩阵。</li>
      <li><code class="language-plaintext highlighter-rouge">ones(m, n)</code> 创建一个 <code class="language-plaintext highlighter-rouge">m</code> 行 <code class="language-plaintext highlighter-rouge">n</code> 列的全一矩阵。</li>
      <li><code class="language-plaintext highlighter-rouge">eye(n)</code> 创建一个 <code class="language-plaintext highlighter-rouge">n</code> 阶单位矩阵。</li>
      <li><code class="language-plaintext highlighter-rouge">rand(m, n)</code> 创建一个 <code class="language-plaintext highlighter-rouge">m</code> 行 <code class="language-plaintext highlighter-rouge">n</code> 列的随机矩阵，元素取值在 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">1</code> 之间。例如 <code class="language-plaintext highlighter-rouge">rand(3, 3)</code> 创建一个3x3的随机矩阵。</li>
      <li><code class="language-plaintext highlighter-rouge">randn(m, n)</code> 创建一个 <code class="language-plaintext highlighter-rouge">m</code> 行 <code class="language-plaintext highlighter-rouge">n</code> 列的服从标准正态分布的随机矩阵。</li>
    </ul>
  </li>
</ul>

<h3 id="32-矩阵运算">3.2 矩阵运算</h3>
<ul>
  <li><strong>算术运算</strong>：
    <ul>
      <li><strong>加法</strong>：<code class="language-plaintext highlighter-rouge">A + B</code>，要求 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 矩阵的大小相同。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; B = [5 6; 7 8]; C = A + B;</code> 则 <code class="language-plaintext highlighter-rouge">C = [6 8; 10 12]</code>。</li>
      <li><strong>减法</strong>：<code class="language-plaintext highlighter-rouge">A - B</code>，规则同加法。</li>
      <li><strong>乘法</strong>：
        <ul>
          <li><strong>矩阵乘法</strong>：<code class="language-plaintext highlighter-rouge">A * B</code>，要求 <code class="language-plaintext highlighter-rouge">A</code> 的列数等于 <code class="language-plaintext highlighter-rouge">B</code> 的行数。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; B = [5 6; 7 8]; C = A * B;</code> 计算结果 <code class="language-plaintext highlighter-rouge">C = [19 22; 43 50]</code>。</li>
          <li><strong>点乘（对应元素相乘）</strong>：<code class="language-plaintext highlighter-rouge">A .* B</code>，要求 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 矩阵大小相同。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; B = [5 6; 7 8]; C = A .* B;</code> 则 <code class="language-plaintext highlighter-rouge">C = [5 12; 21 32]</code>。</li>
        </ul>
      </li>
      <li><strong>除法</strong>：
        <ul>
          <li><strong>左除</strong>：<code class="language-plaintext highlighter-rouge">A \ B</code>，可用于求解线性方程组 <code class="language-plaintext highlighter-rouge">Ax = B</code>。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; B = [5; 6]; x = A \ B;</code> 可以求解出 <code class="language-plaintext highlighter-rouge">x</code>。</li>
          <li><strong>右除</strong>：<code class="language-plaintext highlighter-rouge">A / B</code>，相当于 <code class="language-plaintext highlighter-rouge">A * inv(B)</code>，<code class="language-plaintext highlighter-rouge">inv</code> 是求逆矩阵函数。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; B = [5 6; 7 8]; C = A / B;</code> 这里先求 <code class="language-plaintext highlighter-rouge">B</code> 的逆矩阵再与 <code class="language-plaintext highlighter-rouge">A</code> 相乘。</li>
        </ul>
      </li>
      <li><strong>转置</strong>：<code class="language-plaintext highlighter-rouge">A'</code> 用于求矩阵 <code class="language-plaintext highlighter-rouge">A</code> 的转置。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; B = A';</code> 则 <code class="language-plaintext highlighter-rouge">B = [1 3; 2 4]</code>。</li>
    </ul>
  </li>
  <li><strong>特殊矩阵运算</strong>：
    <ul>
      <li><strong>求逆矩阵</strong>：<code class="language-plaintext highlighter-rouge">inv(A)</code> 计算矩阵 <code class="language-plaintext highlighter-rouge">A</code> 的逆矩阵，要求 <code class="language-plaintext highlighter-rouge">A</code> 是方阵且可逆。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; B = inv(A);</code></li>
      <li><strong>行列式</strong>：<code class="language-plaintext highlighter-rouge">det(A)</code> 计算方阵 <code class="language-plaintext highlighter-rouge">A</code> 的行列式。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; det_A = det(A);</code> 结果 <code class="language-plaintext highlighter-rouge">det_A = -2</code>。</li>
      <li><strong>特征值和特征向量</strong>：<code class="language-plaintext highlighter-rouge">[V, D] = eig(A)</code>，<code class="language-plaintext highlighter-rouge">V</code> 是特征向量矩阵，<code class="language-plaintext highlighter-rouge">D</code> 是特征值对角矩阵。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; [V, D] = eig(A);</code></li>
    </ul>
  </li>
</ul>

<h3 id="33-数组操作">3.3 数组操作</h3>
<ul>
  <li><strong>索引</strong>：通过索引来访问数组中的元素。对于一维数组 <code class="language-plaintext highlighter-rouge">arr = [1, 2, 3, 4];</code>，<code class="language-plaintext highlighter-rouge">arr(3)</code> 可以获取第三个元素 <code class="language-plaintext highlighter-rouge">3</code>。对于二维数组 <code class="language-plaintext highlighter-rouge">mat = [1 2 3; 4 5 6; 7 8 9];</code>，<code class="language-plaintext highlighter-rouge">mat(2, 3)</code> 可以获取第二行第三列的元素 <code class="language-plaintext highlighter-rouge">6</code>。</li>
  <li><strong>切片</strong>：可以提取数组的一部分。例如对于一维数组 <code class="language-plaintext highlighter-rouge">arr = [1, 2, 3, 4, 5];</code>，<code class="language-plaintext highlighter-rouge">arr(2:4)</code> 可以获取从第二个元素到第四个元素的子数组 <code class="language-plaintext highlighter-rouge">[2 3 4]</code>。对于二维数组 <code class="language-plaintext highlighter-rouge">mat = [1 2 3; 4 5 6; 7 8 9];</code>，<code class="language-plaintext highlighter-rouge">mat(1:2, 2:3)</code> 可以获取第一行到第二行，第二列到第三列的子矩阵 <code class="language-plaintext highlighter-rouge">[2 3; 5 6]</code>。</li>
  <li><strong>重塑</strong>：使用 <code class="language-plaintext highlighter-rouge">reshape</code> 函数改变数组的形状。例如 <code class="language-plaintext highlighter-rouge">arr = [1 2 3 4 5 6]; new_arr = reshape(arr, 2, 3);</code> 会将 <code class="language-plaintext highlighter-rouge">arr</code> 重塑为一个2行3列的矩阵 <code class="language-plaintext highlighter-rouge">[1 3 5; 2 4 6]</code>。</li>
  <li><strong>连接</strong>：使用 <code class="language-plaintext highlighter-rouge">cat</code> 函数连接数组。例如 <code class="language-plaintext highlighter-rouge">A = [1 2; 3 4]; B = [5 6; 7 8]; C = cat(1, A, B);</code> 会将 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 按行连接成一个新矩阵 <code class="language-plaintext highlighter-rouge">C = [1 2; 3 4; 5 6; 7 8]</code>，这里 <code class="language-plaintext highlighter-rouge">1</code> 表示按行连接，若为 <code class="language-plaintext highlighter-rouge">2</code> 则表示按列连接。</li>
</ul>

<h2 id="四基本数学运算与函数">四、基本数学运算与函数</h2>
<h3 id="41-基本数学运算">4.1 基本数学运算</h3>
<p>包括加法（<code class="language-plaintext highlighter-rouge">+</code>）、减法（<code class="language-plaintext highlighter-rouge">-</code>）、乘法（<code class="language-plaintext highlighter-rouge">*</code>）、除法（<code class="language-plaintext highlighter-rouge">/</code>）、幂运算（<code class="language-plaintext highlighter-rouge">^</code>）等。这些运算可以对数值、数组和矩阵进行操作，遵循相应的运算规则，如矩阵乘法的维度匹配规则等。
案例：计算 <code class="language-plaintext highlighter-rouge">3^4 + 5 * 2 - 8 / 2</code>。</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">result</span> <span class="o">=</span> <span class="mi">3</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span> <span class="p">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">% result 的值为 81 + 10 - 4 = 87</span>
</code></pre></div></div>
<h3 id="42-三角函数">4.2 三角函数</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">sin(x)</code>：计算 <code class="language-plaintext highlighter-rouge">x</code> 的正弦值，<code class="language-plaintext highlighter-rouge">x</code> 的单位为弧度。例如 <code class="language-plaintext highlighter-rouge">sin(pi/2)</code> 返回 <code class="language-plaintext highlighter-rouge">1</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">cos(x)</code>：计算 <code class="language-plaintext highlighter-rouge">x</code> 的余弦值。</li>
  <li><code class="language-plaintext highlighter-rouge">tan(x)</code>：计算 <code class="language-plaintext highlighter-rouge">x</code> 的正切值。</li>
  <li>还有对应的反三角函数 <code class="language-plaintext highlighter-rouge">asin(x)</code>、<code class="language-plaintext highlighter-rouge">acos(x)</code>、<code class="language-plaintext highlighter-rouge">atan(x)</code> 等。
案例：计算 <code class="language-plaintext highlighter-rouge">45</code> 度角的正弦值（需将角度转换为弧度）。
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">angle</span> <span class="o">=</span> <span class="mi">45</span> <span class="o">*</span> <span class="nb">pi</span> <span class="p">/</span> <span class="mi">180</span><span class="p">;</span> <span class="c1">% 将 45 度转换为弧度</span>
<span class="n">sin_value</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="nb">angle</span><span class="p">);</span> <span class="c1">% sin_value 的值约为 0.7071</span>
</code></pre></div>    </div>
    <h3 id="43-指数与对数函数">4.3 指数与对数函数</h3>
  </li>
  <li><code class="language-plaintext highlighter-rouge">exp(x)</code>：计算 <code class="language-plaintext highlighter-rouge">e</code> 的 <code class="language-plaintext highlighter-rouge">x</code> 次幂。例如 <code class="language-plaintext highlighter-rouge">exp(1)</code> 返回自然常数 <code class="language-plaintext highlighter-rouge">e</code> 的近似值 <code class="language-plaintext highlighter-rouge">2.7183</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">log(x)</code>：计算以 <code class="language-plaintext highlighter-rouge">e</code> 为底 <code class="language-plaintext highlighter-rouge">x</code> 的对数。例如 <code class="language-plaintext highlighter-rouge">log(exp(3))</code> 返回 <code class="language-plaintext highlighter-rouge">3</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">log10(x)</code>：计算以 <code class="language-plaintext highlighter-rouge">10</code> 为底 <code class="language-plaintext highlighter-rouge">x</code> 的对数。
案例：计算 <code class="language-plaintext highlighter-rouge">100</code> 的以 <code class="language-plaintext highlighter-rouge">10</code> 为底的对数。
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">log_value</span> <span class="o">=</span> <span class="nb">log10</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">% log_value 的值为 2</span>
</code></pre></div>    </div>
    <h3 id="44-随机数生成">4.4 随机数生成</h3>
  </li>
  <li><code class="language-plaintext highlighter-rouge">rand()</code>：生成一个在 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">1</code> 之间的随机小数。</li>
  <li><code class="language-plaintext highlighter-rouge">rand(n)</code>：生成一个 <code class="language-plaintext highlighter-rouge">n</code> x <code class="language-plaintext highlighter-rouge">n</code> 的随机矩阵，元素取值在 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">1</code> 之间。</li>
  <li><code class="language-plaintext highlighter-rouge">randn()</code>：生成一个服从标准正态分布的随机小数。</li>
  <li><code class="language-plaintext highlighter-rouge">randn(n)</code>：生成一个 <code class="language-plaintext highlighter-rouge">n</code> x <code class="language-plaintext highlighter-rouge">n</code> 的服从标准正态分布的随机矩阵。
案例：生成一个包含10个随机整数（范围在1到100）的数组。
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">random_array</span> <span class="o">=</span> <span class="nb">randi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">% 生成1x10的随机整数数组</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="五图形绘制与数据可视化">五、图形绘制与数据可视化</h2>
<h3 id="51-二维图形绘制">5.1 二维图形绘制</h3>
<ul>
  <li><strong>折线图</strong>：<code class="language-plaintext highlighter-rouge">plot(x, y)</code>，<code class="language-plaintext highlighter-rouge">x</code> 和 <code class="language-plaintext highlighter-rouge">y</code> 分别为横坐标和纵坐标的数据。例如 <code class="language-plaintext highlighter-rouge">x = 1:10; y = x.^2; plot(x, y);</code> 会绘制出 <code class="language-plaintext highlighter-rouge">y = x^2</code> 在 <code class="language-plaintext highlighter-rouge">x</code> 从 <code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">10</code> 时的折线图。</li>
  <li><strong>散点图</strong>：<code class="language-plaintext highlighter-rouge">scatter(x, y)</code>，用于展示数据点的分布情况。例如 <code class="language-plaintext highlighter-rouge">x = randn(1, 50); y = randn(1, 50); scatter(x, y);</code> 会生成50个随机分布的散点。</li>
  <li><strong>柱状图</strong>：<code class="language-plaintext highlighter-rouge">bar(x, y)</code>，<code class="language-plaintext highlighter-rouge">x</code> 通常为类别标签，<code class="language-plaintext highlighter-rouge">y</code> 为对应类别的数值。例如 <code class="language-plaintext highlighter-rouge">x = {'A', 'B', 'C'}; y = [10, 20, 15]; bar(x, y);</code> 会绘制出一个包含三个柱子的柱状图。
    <h3 id="52-三维图形绘制">5.2 三维图形绘制</h3>
  </li>
  <li><strong>曲面图</strong>：<code class="language-plaintext highlighter-rouge">surf(X, Y, Z)</code>，<code class="language-plaintext highlighter-rouge">X</code>、<code class="language-plaintext highlighter-rouge">Y</code> 为网格坐标矩阵，<code class="language-plaintext highlighter-rouge">Z</code> 为对应的函数值矩阵。例如 <code class="language-plaintext highlighter-rouge">[X, Y] = meshgrid(-2:0.2:2); Z = X.^2 + Y.^2; surf(X, Y, Z);</code> 会绘制出 <code class="language-plaintext highlighter-rouge">z = x^2 + y^2</code> 的三维曲面图。</li>
  <li><strong>网格图</strong>：<code class="language-plaintext highlighter-rouge">mesh(X, Y, Z)</code>，与曲面图类似，但只绘制网格线。例如 <code class="language-plaintext highlighter-rouge">[X, Y] = meshgrid(-2:0.2:2); Z = X.^2 + Y.^2; mesh(X, Y, Z);</code></li>
  <li><strong>三维散点图</strong>：<code class="language-plaintext highlighter-rouge">scatter3(x, y, z)</code>，用于展示三维空间中的数据点分布。例如 <code class="language-plaintext highlighter-rouge">x = randn(1, 30); y = randn(1, 30); z = randn(1, 30); scatter3(x, y, z);</code></li>
</ul>

<h3 id="53-图形属性设置">5.3 图形属性设置</h3>
<ul>
  <li><strong>标题</strong>：<code class="language-plaintext highlighter-rouge">title('图形标题')</code>，用于设置图形的标题。例如 <code class="language-plaintext highlighter-rouge">plot(x, y); title('y = x^2 图形');</code></li>
  <li><strong>坐标轴标签</strong>：<code class="language-plaintext highlighter-rouge">xlabel('x 轴标签')</code>，<code class="language-plaintext highlighter-rouge">ylabel('y 轴标签')</code>，<code class="language-plaintext highlighter-rouge">zlabel('z 轴标签')</code> 分别用于设置 <code class="language-plaintext highlighter-rouge">x</code> 轴、<code class="language-plaintext highlighter-rouge">y</code> 轴和 <code class="language-plaintext highlighter-rouge">z</code> 轴的标签。例如 <code class="language-plaintext highlighter-rouge">plot(x, y); xlabel('x'); ylabel('y = x^2');</code></li>
  <li><strong>图例</strong>：<code class="language-plaintext highlighter-rouge">legend('曲线1', '曲线2', ...)</code>，用于标注图形中不同曲线或数据的含义。例如 `x = 1:10; y1 = x; y2 = x.^2; plot(x, y1, ‘r -‘, x以下是基于MATLAB教程免费中文版整理的详细笔记，涵盖主要知识点并附案例说明：</li>
</ul>

<h3 id="1-matlab基础"><strong>1. MATLAB基础</strong></h3>
<h4 id="11-基本数据类型"><strong>1.1 基本数据类型</strong></h4>
<ul>
  <li><strong>数值类型</strong>：<code class="language-plaintext highlighter-rouge">double</code>（默认）、<code class="language-plaintext highlighter-rouge">single</code>、<code class="language-plaintext highlighter-rouge">int8/16/32/64</code>、<code class="language-plaintext highlighter-rouge">uint8/16/32/64</code></li>
  <li><strong>逻辑类型</strong>：<code class="language-plaintext highlighter-rouge">true</code>/<code class="language-plaintext highlighter-rouge">false</code></li>
  <li><strong>字符类型</strong>：<code class="language-plaintext highlighter-rouge">'hello'</code>（字符数组）或<code class="language-plaintext highlighter-rouge">string</code>（字符串对象）</li>
  <li><strong>单元数组</strong>：<code class="language-plaintext highlighter-rouge">C = {1, 'text', [1 2 3]}</code></li>
  <li><strong>结构体</strong>：<code class="language-plaintext highlighter-rouge">S.name = 'John'; S.age = 30</code></li>
</ul>

<p><strong>案例</strong>：创建不同类型变量</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>               <span class="c1">% double</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int8</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>          <span class="c1">% 有符号8位整数</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>               <span class="c1">% 逻辑值</span>
<span class="n">d</span> <span class="o">=</span> <span class="s1">'MATLAB'</span><span class="p">;</span>           <span class="c1">% 字符数组</span>
<span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Hello"</span><span class="p">,</span> <span class="s2">"World"</span><span class="p">];</span> <span class="c1">% 字符串数组</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">i</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]};</span> <span class="c1">% 单元数组</span>
<span class="n">g</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">g</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">];</span>  <span class="c1">% 结构体</span>
</code></pre></div></div>

<h4 id="12-变量与赋值"><strong>1.2 变量与赋值</strong></h4>
<ul>
  <li>变量名区分大小写，以字母开头</li>
  <li>赋值语句：<code class="language-plaintext highlighter-rouge">x = 5; y = sin(x)</code></li>
  <li>特殊变量：<code class="language-plaintext highlighter-rouge">ans</code>（临时结果）、<code class="language-plaintext highlighter-rouge">pi</code>、<code class="language-plaintext highlighter-rouge">inf</code>、<code class="language-plaintext highlighter-rouge">NaN</code></li>
</ul>

<p><strong>案例</strong>：计算圆面积</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">radius</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nb">area</span> <span class="o">=</span> <span class="nb">pi</span> <span class="o">*</span> <span class="n">radius</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'半径为%d的圆面积为%.2f\n'</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="nb">area</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="2-矩阵与数组操作"><strong>2. 矩阵与数组操作</strong></h3>
<h4 id="21-矩阵创建"><strong>2.1 矩阵创建</strong></h4>
<ul>
  <li>直接创建：<code class="language-plaintext highlighter-rouge">A = [1 2 3; 4 5 6; 7 8 9]</code></li>
  <li>函数创建：<code class="language-plaintext highlighter-rouge">zeros(3,4)</code>、<code class="language-plaintext highlighter-rouge">ones(2)</code>、<code class="language-plaintext highlighter-rouge">eye(3)</code>、<code class="language-plaintext highlighter-rouge">rand(3)</code></li>
  <li>冒号表达式：<code class="language-plaintext highlighter-rouge">v = 1:2:10</code>（从1到10，步长2）</li>
</ul>

<p><strong>案例</strong>：创建希尔伯特矩阵</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">H</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span>
        <span class="n">H</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">/(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="nb">disp</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="22-矩阵运算"><strong>2.2 矩阵运算</strong></h4>
<ul>
  <li>算术运算：<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">^</code></li>
  <li>点运算：<code class="language-plaintext highlighter-rouge">.*</code>、<code class="language-plaintext highlighter-rouge">./</code>、<code class="language-plaintext highlighter-rouge">.^</code>（元素级运算）</li>
  <li>转置：<code class="language-plaintext highlighter-rouge">A'</code></li>
  <li>逆矩阵：<code class="language-plaintext highlighter-rouge">inv(A)</code></li>
  <li>行列式：<code class="language-plaintext highlighter-rouge">det(A)</code></li>
</ul>

<p><strong>案例</strong>：解线性方程组 <code class="language-plaintext highlighter-rouge">Ax = b</code></p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">];</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">;</span> <span class="mi">13</span><span class="p">];</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="p">\</span><span class="n">b</span><span class="p">;</span> <span class="c1">% 等价于 inv(A)*b</span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'解为 x=%.2f, y=%.2f\n'</span><span class="p">,</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</code></pre></div></div>

<h3 id="3-流程控制"><strong>3. 流程控制</strong></h3>
<h4 id="31-条件语句"><strong>3.1 条件语句</strong></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">if-elseif-else</code></li>
  <li><code class="language-plaintext highlighter-rouge">switch-case</code></li>
</ul>

<p><strong>案例</strong>：判断成绩等级</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">score</span> <span class="o">=</span> <span class="mi">85</span><span class="p">;</span>
<span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">90</span>
    <span class="n">grade</span> <span class="o">=</span> <span class="s1">'A'</span><span class="p">;</span>
<span class="k">elseif</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">80</span>
    <span class="n">grade</span> <span class="o">=</span> <span class="s1">'B'</span><span class="p">;</span>
<span class="k">elseif</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="mi">70</span>
    <span class="n">grade</span> <span class="o">=</span> <span class="s1">'C'</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">grade</span> <span class="o">=</span> <span class="s1">'D'</span><span class="p">;</span>
<span class="k">end</span>
<span class="nb">disp</span><span class="p">([</span><span class="s1">'成绩等级：'</span> <span class="n">grade</span><span class="p">]);</span>
</code></pre></div></div>

<h4 id="32-循环语句"><strong>3.2 循环语句</strong></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">for</code> 循环：<code class="language-plaintext highlighter-rouge">for i = 1:n</code></li>
  <li><code class="language-plaintext highlighter-rouge">while</code> 循环：<code class="language-plaintext highlighter-rouge">while condition</code></li>
  <li>循环控制：<code class="language-plaintext highlighter-rouge">break</code>、<code class="language-plaintext highlighter-rouge">continue</code></li>
</ul>

<p><strong>案例</strong>：计算斐波那契数列</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">fib</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="n">fib</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fib</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">:</span><span class="n">n</span>
    <span class="n">fib</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="k">end</span>
<span class="nb">disp</span><span class="p">(</span><span class="n">fib</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="4-函数编写"><strong>4. 函数编写</strong></h3>
<h4 id="41-脚本文件与函数文件"><strong>4.1 脚本文件与函数文件</strong></h4>
<ul>
  <li>脚本：无输入输出，直接执行命令</li>
  <li>函数：有输入输出参数，格式为：
    <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="p">[</span><span class="n">outputs</span><span class="p">]</span> <span class="o">=</span> <span class="n">functionName</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="c1">% 函数体</span>
<span class="k">end</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>案例</strong>：计算阶乘的函数</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="nb">result</span> <span class="o">=</span> <span class="nb">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="nb">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="nb">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="nb">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">% 递归调用</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="42-匿名函数"><strong>4.2 匿名函数</strong></h4>
<ul>
  <li>轻量级函数：<code class="language-plaintext highlighter-rouge">f = @(x) x^2 + 2*x + 1</code></li>
</ul>

<p><strong>案例</strong>：计算积分</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">.^</span><span class="mi">2</span><span class="p">);</span>
<span class="n">integral_value</span> <span class="o">=</span> <span class="nb">integral</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nb">disp</span><span class="p">([</span><span class="s1">'积分结果：'</span> <span class="nb">num2str</span><span class="p">(</span><span class="n">integral_value</span><span class="p">)]);</span>
</code></pre></div></div>

<h3 id="5-数据可视化"><strong>5. 数据可视化</strong></h3>
<h4 id="51-二维绘图"><strong>5.1 二维绘图</strong></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">plot(x, y)</code>：绘制折线图</li>
  <li>绘图参数：<code class="language-plaintext highlighter-rouge">'r--'</code>（红色虚线）、<code class="language-plaintext highlighter-rouge">'LineWidth', 2</code></li>
  <li>坐标轴设置：<code class="language-plaintext highlighter-rouge">xlabel</code>、<code class="language-plaintext highlighter-rouge">ylabel</code>、<code class="language-plaintext highlighter-rouge">title</code>、<code class="language-plaintext highlighter-rouge">legend</code></li>
</ul>

<p><strong>案例</strong>：绘制正弦和余弦曲线</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">:</span><span class="mf">0.1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">;</span>
<span class="n">y1</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">y2</span> <span class="o">=</span> <span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="s1">'b-'</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="s1">'r--'</span><span class="p">,</span> <span class="s1">'LineWidth'</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span> <span class="nb">ylabel</span><span class="p">(</span><span class="s1">'y'</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'正弦和余弦曲线'</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'sin(x)'</span><span class="p">,</span> <span class="s1">'cos(x)'</span><span class="p">);</span>
<span class="nb">grid</span> <span class="n">on</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="52-三维绘图"><strong>5.2 三维绘图</strong></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">plot3(x, y, z)</code>：三维曲线</li>
  <li><code class="language-plaintext highlighter-rouge">mesh(X, Y, Z)</code>：网格图</li>
  <li><code class="language-plaintext highlighter-rouge">surf(X, Y, Z)</code>：曲面图</li>
</ul>

<p><strong>案例</strong>：绘制三维曲面</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mf">0.1</span><span class="p">:</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Y</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
<span class="nb">surf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">);</span>
<span class="nb">shading</span> <span class="n">interp</span><span class="p">;</span> <span class="c1">% 平滑着色</span>
<span class="nb">colorbar</span><span class="p">;</span> <span class="c1">% 显示颜色条</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'抛物面 z = x² + y²'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="6-文件操作"><strong>6. 文件操作</strong></h3>
<h4 id="61-文件读写"><strong>6.1 文件读写</strong></h4>
<ul>
  <li>文本文件：<code class="language-plaintext highlighter-rouge">fopen</code>、<code class="language-plaintext highlighter-rouge">fprintf</code>、<code class="language-plaintext highlighter-rouge">fscanf</code>、<code class="language-plaintext highlighter-rouge">fclose</code></li>
  <li>二进制文件：<code class="language-plaintext highlighter-rouge">fread</code>、<code class="language-plaintext highlighter-rouge">fwrite</code></li>
  <li>MAT文件：<code class="language-plaintext highlighter-rouge">save</code>、<code class="language-plaintext highlighter-rouge">load</code></li>
</ul>

<p><strong>案例</strong>：读写文本文件</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% 写入文件</span>
<span class="n">fid</span> <span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">'data.txt'</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">);</span>
<span class="nb">fprintf</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="s1">'%d %f\n'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">);</span>
<span class="nb">fprintf</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="s1">'%d %f\n'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.71</span><span class="p">);</span>
<span class="nb">fclose</span><span class="p">(</span><span class="n">fid</span><span class="p">);</span>

<span class="c1">% 读取文件</span>
<span class="n">fid</span> <span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">'data.txt'</span><span class="p">,</span> <span class="s1">'r'</span><span class="p">);</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">fscanf</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="s1">'%d %f'</span><span class="p">);</span>
<span class="nb">fclose</span><span class="p">(</span><span class="n">fid</span><span class="p">);</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[])</span><span class="o">'</span><span class="p">;</span> <span class="c1">% 重塑为矩阵</span>
</code></pre></div></div>

<h3 id="7-数据分析与统计"><strong>7. 数据分析与统计</strong></h3>
<h4 id="71-基本统计函数"><strong>7.1 基本统计函数</strong></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">mean</code>、<code class="language-plaintext highlighter-rouge">median</code>、<code class="language-plaintext highlighter-rouge">std</code>、<code class="language-plaintext highlighter-rouge">var</code>、<code class="language-plaintext highlighter-rouge">min</code>、<code class="language-plaintext highlighter-rouge">max</code>、<code class="language-plaintext highlighter-rouge">sum</code></li>
</ul>

<p><strong>案例</strong>：分析数据集</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">75</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">92</span><span class="p">];</span>
<span class="n">avg</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="n">std_dev</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'平均值：%.2f，标准差：%.2f\n'</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="72-多项式拟合"><strong>7.2 多项式拟合</strong></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">polyfit(x, y, n)</code>：n次多项式拟合</li>
  <li><code class="language-plaintext highlighter-rouge">polyval(p, x)</code>：多项式求值</li>
</ul>

<p><strong>案例</strong>：拟合数据点</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">];</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">% 二次多项式拟合</span>
<span class="n">x_fit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="mf">0.1</span><span class="p">:</span><span class="mi">5</span><span class="p">;</span>
<span class="n">y_fit</span> <span class="o">=</span> <span class="nb">polyval</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x_fit</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">'ro'</span><span class="p">,</span> <span class="n">x_fit</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">,</span> <span class="s1">'b-'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="8-符号计算"><strong>8. 符号计算</strong></h3>
<h4 id="81-符号变量与表达式"><strong>8.1 符号变量与表达式</strong></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">syms x y</code>：定义符号变量</li>
  <li>符号运算：<code class="language-plaintext highlighter-rouge">expand</code>、<code class="language-plaintext highlighter-rouge">factor</code>、<code class="language-plaintext highlighter-rouge">simplify</code>、<code class="language-plaintext highlighter-rouge">diff</code>、<code class="language-plaintext highlighter-rouge">int</code></li>
</ul>

<p><strong>案例</strong>：求解方程和微分</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>
<span class="c1">% 解方程 ax²+bx+c=0</span>
<span class="n">eqn</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="nb">disp</span><span class="p">(</span><span class="s1">'方程的解：'</span><span class="p">);</span>
<span class="nb">disp</span><span class="p">(</span><span class="n">sol</span><span class="p">);</span>

<span class="c1">% 求导</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
<span class="n">df</span> <span class="o">=</span> <span class="nb">diff</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="nb">disp</span><span class="p">([</span><span class="s1">'f(x)的导数：'</span> <span class="nb">char</span><span class="p">(</span><span class="n">df</span><span class="p">)]);</span>
</code></pre></div></div>

<h3 id="9-工具箱应用以图像处理为例"><strong>9. 工具箱应用（以图像处理为例）</strong></h3>
<h4 id="91-图像读取与显示"><strong>9.1 图像读取与显示</strong></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">imread</code>、<code class="language-plaintext highlighter-rouge">imshow</code>、<code class="language-plaintext highlighter-rouge">imwrite</code></li>
</ul>

<p><strong>案例</strong>：图像灰度化与边缘检测</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">img</span> <span class="o">=</span> <span class="nb">imread</span><span class="p">(</span><span class="s1">'peppers.png'</span><span class="p">);</span> <span class="c1">% 读取图像</span>
<span class="n">gray_img</span> <span class="o">=</span> <span class="nb">rgb2gray</span><span class="p">(</span><span class="n">img</span><span class="p">);</span>    <span class="c1">% 转为灰度图</span>
<span class="n">edge_img</span> <span class="o">=</span> <span class="n">edge</span><span class="p">(</span><span class="n">gray_img</span><span class="p">,</span> <span class="s1">'Sobel'</span><span class="p">);</span> <span class="c1">% 边缘检测</span>

<span class="nb">figure</span><span class="p">;</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="nb">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'原始图像'</span><span class="p">);</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="nb">imshow</span><span class="p">(</span><span class="n">gray_img</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'灰度图像'</span><span class="p">);</span>
<span class="nb">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="nb">imshow</span><span class="p">(</span><span class="n">edge_img</span><span class="p">);</span> <span class="nb">title</span><span class="p">(</span><span class="s1">'边缘检测'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="10-程序调试与优化"><strong>10. 程序调试与优化</strong></h3>
<h4 id="101-调试工具"><strong>10.1 调试工具</strong></h4>
<ul>
  <li>设置断点：<code class="language-plaintext highlighter-rouge">dbstop in filename at line</code></li>
  <li>调试命令：<code class="language-plaintext highlighter-rouge">dbstep</code>、<code class="language-plaintext highlighter-rouge">dbcont</code>、<code class="language-plaintext highlighter-rouge">dbstack</code></li>
</ul>

<p><strong>案例</strong>：调试含错误的函数</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="nb">result</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="nb">error</span><span class="p">(</span><span class="s1">'除数不能为零！'</span><span class="p">);</span> <span class="c1">% 抛出错误</span>
    <span class="k">end</span>
    <span class="nb">result</span> <span class="o">=</span> <span class="n">a</span> <span class="p">/</span> <span class="n">b</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Matlab" /><summary type="html"><![CDATA[MATLAB学习笔记]]></summary></entry><entry><title type="html">Javascript学习笔记</title><link href="http://localhost:4000/blog/javascript/2025/05/29/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="Javascript学习笔记" /><published>2025-05-29T00:00:00+08:00</published><updated>2025-05-29T00:00:00+08:00</updated><id>http://localhost:4000/blog/javascript/2025/05/29/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/javascript/2025/05/29/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="javascript学习笔记">Javascript学习笔记</h1>

<h3 id="一基础语法与核心概念">一、基础语法与核心概念</h3>

<h4 id="1-变量与作用域">1. 变量与作用域</h4>
<ul>
  <li><strong>变量声明</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">let</code> 和 <code class="language-plaintext highlighter-rouge">const</code> 具有块级作用域，即它们的作用范围被限制在最近的一对花括号 <code class="language-plaintext highlighter-rouge">{}</code> 内。</li>
      <li><code class="language-plaintext highlighter-rouge">var</code> 具有函数作用域，它的作用范围是整个函数。
```javascript
// let 和 const 的块级作用域
{
let blockScopedLet = ‘I am block scoped with let’;
const blockScopedConst = ‘I am block scoped with const’;
}
// 下面这两行会报错，因为变量超出了作用域
// console.log(blockScopedLet); 
// console.log(blockScopedConst);</li>
    </ul>
  </li>
</ul>

<p>// var 的函数作用域
function varScopeExample() {
  var functionScopedVar = ‘I am function scoped with var’;
}
// 下面这行会报错，因为变量超出了函数作用域
// console.log(functionScopedVar);</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **作用域链**：JavaScript 采用词法作用域，变量的查找是从当前作用域开始，逐级向上查找，直到全局作用域。
```javascript
function outerFunction() {
  let outerVariable = 'I am from outer function';
  function innerFunction() {
    console.log(outerVariable); // 可以访问外层函数的变量
  }
  innerFunction();
}
outerFunction();
</code></pre></div></div>
<ul>
  <li><strong>垃圾回收</strong>：JavaScript 采用标记清除算法进行垃圾回收，当一个对象没有任何引用指向它时，它会被标记为可回收的，然后在适当的时候被回收。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">createObject</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">value</span><span class="dl">'</span> <span class="p">};</span>
<span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="nf">createObject</span><span class="p">();</span>
<span class="nx">myObj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 释放对对象的引用，对象可能会被垃圾回收</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="2-数据类型与操作">2. 数据类型与操作</h4>
<ul>
  <li><strong>原始类型</strong>：JavaScript 有 7 种原始类型，分别是 <code class="language-plaintext highlighter-rouge">string</code>、<code class="language-plaintext highlighter-rouge">number</code>、<code class="language-plaintext highlighter-rouge">boolean</code>、<code class="language-plaintext highlighter-rouge">null</code>、<code class="language-plaintext highlighter-rouge">undefined</code>、<code class="language-plaintext highlighter-rouge">bigint</code> 和 <code class="language-plaintext highlighter-rouge">symbol</code>。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello, World!</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// string</span>
<span class="kd">let</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// number</span>
<span class="kd">let</span> <span class="nx">bool</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// boolean</span>
<span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// null</span>
<span class="kd">let</span> <span class="nx">u</span><span class="p">;</span> <span class="c1">// undefined</span>
<span class="kd">let</span> <span class="nx">big</span> <span class="o">=</span> <span class="mi">123456789012345678901234567890</span><span class="nx">n</span><span class="p">;</span> <span class="c1">// bigint</span>
<span class="kd">let</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nc">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">unique</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// symbol</span>
</code></pre></div>    </div>
  </li>
  <li><strong>引用类型</strong>：常见的引用类型有 <code class="language-plaintext highlighter-rouge">Object</code>、<code class="language-plaintext highlighter-rouge">Array</code>、<code class="language-plaintext highlighter-rouge">Function</code>、<code class="language-plaintext highlighter-rouge">Date</code> 等。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">};</span> <span class="c1">// Object</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="c1">// Array</span>
<span class="kd">function</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am a function</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span> <span class="c1">// Function</span>
<span class="kd">let</span> <span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="p">();</span> <span class="c1">// Date</span>
</code></pre></div>    </div>
  </li>
  <li><strong>类型转换</strong>：JavaScript 有隐式和显式的类型转换。<code class="language-plaintext highlighter-rouge">===</code> 是严格相等运算符，会同时比较值和类型。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 隐式转换</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">5</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 结果是 '55'，数字 5 被隐式转换为字符串</span>
<span class="c1">// 显式检查</span>
<span class="kd">let</span> <span class="nx">num1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">str1</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">5</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">num1</span> <span class="o">===</span> <span class="nx">str1</span><span class="p">);</span> <span class="c1">// false，值相同但类型不同</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="3-函数与执行机制">3. 函数与执行机制</h4>
<ul>
  <li><strong>函数定义</strong>：可以使用声明式、表达式或箭头函数来定义函数。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 声明式函数</span>
<span class="kd">function</span> <span class="nf">declarationFunction</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am a declaration function</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 函数表达式</span>
<span class="kd">let</span> <span class="nx">expressionFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am an expression function</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
<span class="c1">// 箭头函数</span>
<span class="kd">let</span> <span class="nx">arrowFunction</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am an arrow function</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </li>
  <li><strong>高阶函数</strong>：<code class="language-plaintext highlighter-rouge">map</code>、<code class="language-plaintext highlighter-rouge">filter</code> 和 <code class="language-plaintext highlighter-rouge">reduce</code> 是常见的高阶函数，它们接受一个函数作为参数。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="c1">// map 方法</span>
<span class="kd">let</span> <span class="nx">squared</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">*</span> <span class="nx">num</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">squared</span><span class="p">);</span> <span class="c1">// [1, 4, 9]</span>
<span class="c1">// filter 方法</span>
<span class="kd">let</span> <span class="nx">evenNumbers</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">evenNumbers</span><span class="p">);</span> <span class="c1">// [2]</span>
<span class="c1">// reduce 方法</span>
<span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span> <span class="c1">// 6</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">this</code> 动态绑定</strong>：可以使用 <code class="language-plaintext highlighter-rouge">call</code>、<code class="language-plaintext highlighter-rouge">apply</code> 和 <code class="language-plaintext highlighter-rouge">bind</code> 方法来显式绑定 <code class="language-plaintext highlighter-rouge">this</code>。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
<span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span>
<span class="na">sayHello</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Hello, my name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="kd">let</span> <span class="nx">anotherPerson</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Jane</span><span class="dl">'</span> <span class="p">};</span>
<span class="c1">// 使用 call 方法</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">anotherPerson</span><span class="p">);</span> <span class="c1">// Hello, my name is Jane</span>
<span class="c1">// 使用 apply 方法</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">anotherPerson</span><span class="p">);</span> <span class="c1">// Hello, my name is Jane</span>
<span class="c1">// 使用 bind 方法</span>
<span class="kd">let</span> <span class="nx">boundFunction</span> <span class="o">=</span> <span class="nx">person</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="nx">anotherPerson</span><span class="p">);</span>
<span class="nf">boundFunction</span><span class="p">();</span> <span class="c1">// Hello, my name is Jane</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="二核心进阶特性">二、核心进阶特性</h3>

<h4 id="1-异步编程">1. 异步编程</h4>
<ul>
  <li><strong>回调函数</strong>：使用 <code class="language-plaintext highlighter-rouge">setTimeout</code> 等函数时会使用回调函数，但可能会导致回调地狱。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">First timeout</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Second timeout</span><span class="dl">'</span><span class="p">);</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Third timeout</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Promise</strong>：<code class="language-plaintext highlighter-rouge">Promise</code> 可以实现链式调用，避免回调地狱。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">asyncOperation</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">Async operation completed</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">});</span>
<span class="p">}</span>
<span class="nf">asyncOperation</span><span class="p">()</span>
 <span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
  <span class="k">return</span> <span class="dl">'</span><span class="s1">Chained operation</span><span class="dl">'</span><span class="p">;</span>
<span class="p">})</span>
 <span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">})</span>
 <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Async/Await</strong>：<code class="language-plaintext highlighter-rouge">async/await</code> 提供了同步化的写法，使异步代码更易读。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">asyncOperation</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">Async operation completed</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">});</span>
<span class="p">}</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">asyncOperation</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="nf">main</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="2-闭包与模块化">2. 闭包与模块化</h4>
<ul>
  <li><strong>闭包本质</strong>：闭包是函数和其词法环境的组合，可以实现私有变量。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">createCounter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 闭包保护的私有变量</span>
<span class="k">return </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">counter</span> <span class="o">=</span> <span class="nf">createCounter</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">counter</span><span class="p">());</span> <span class="c1">// 0</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">counter</span><span class="p">());</span> <span class="c1">// 1</span>
</code></pre></div>    </div>
  </li>
  <li><strong>模块化方案</strong>：ES Modules 使用 <code class="language-plaintext highlighter-rouge">import</code> 和 <code class="language-plaintext highlighter-rouge">export</code> 来实现模块化。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// module.js</span>
<span class="k">export</span> <span class="kd">function</span> <span class="nf">sayHello</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello from module</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// main.js</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">sayHello</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./module.js</span><span class="dl">'</span><span class="p">;</span>
<span class="nf">sayHello</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="3-面向对象与原型">3. 面向对象与原型</h4>
<ul>
  <li><strong>构造函数 vs <code class="language-plaintext highlighter-rouge">class</code> 语法糖</strong>：<code class="language-plaintext highlighter-rouge">class</code> 是构造函数的语法糖。
```javascript
// 构造函数
function Person(name, age) {
this.name = name;
this.age = age;
this.sayHello = function() {
  console.log(<code class="language-plaintext highlighter-rouge">Hello, my name is ${this.name}</code>);
};
}
let person1 = new Person(‘John’, 30);
person1.sayHello();</li>
</ul>

<p>// class 语法糖
class PersonClass {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sayHello() {
    console.log(<code class="language-plaintext highlighter-rouge">Hello, my name is ${this.name}</code>);
  }
}
let person2 = new PersonClass(‘Jane’, 25);
person2.sayHello();</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **原型链继承**：可以使用 `Object.create()` 和 `prototype` 来实现原型链继承。
```javascript
let animal = {
  eat() {
    console.log('Animal is eating');
  }
};
let rabbit = Object.create(animal);
rabbit.eat(); // Animal is eating
</code></pre></div></div>

<h3 id="三浏览器环境-api">三、浏览器环境 API</h3>

<h4 id="1-dom-操作">1. DOM 操作</h4>
<ul>
  <li><strong>节点查询</strong>：可以使用 <code class="language-plaintext highlighter-rouge">querySelector</code> 和 <code class="language-plaintext highlighter-rouge">getElementById</code> 来查询 DOM 节点。
```html
&lt;!DOCTYPE html&gt;</li>
</ul>
<html lang="en">
<head>
  <meta charset="UTF-8" />
</head>
<body>
  <div id="myDiv">This is a div</div>
  <script>
    // 使用 getElementById
    let divById = document.getElementById('myDiv');
    console.log(divById.textContent);
    // 使用 querySelector
    let divByQuery = document.querySelector('#myDiv');
    console.log(divByQuery.textContent);
  </script>
</body>
</html>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **事件委托**：事件委托可以高效处理动态元素。
```html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;ul id="list"&gt;
    &lt;li&gt;Item 1&lt;/li&gt;
    &lt;li&gt;Item 2&lt;/li&gt;
    &lt;li&gt;Item 3&lt;/li&gt;
  &lt;/ul&gt;
  &lt;script&gt;
    let list = document.getElementById('list');
    list.addEventListener('click', function(event) {
      if (event.target.tagName === 'LI') {
        console.log(`Clicked on ${event.target.textContent}`);
      }
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div>

<h4 id="2-bom-对象">2. BOM 对象</h4>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">window</code></strong>：<code class="language-plaintext highlighter-rouge">window</code> 是浏览器的全局对象，包含 <code class="language-plaintext highlighter-rouge">location</code> 和 <code class="language-plaintext highlighter-rouge">history</code> 等属性。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取当前页面的 URL</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">);</span>
<span class="c1">// 前进到历史记录中的下一页</span>
<span class="c1">// window.history.forward();</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">fetch</code></strong>：<code class="language-plaintext highlighter-rouge">fetch</code> 是现代网络请求 API，替代了 XMLHttpRequest。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://jsonplaceholder.typicode.com/todos/1</span><span class="dl">'</span><span class="p">)</span>
 <span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nf">json</span><span class="p">())</span>
 <span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
 <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="3-存储机制">3. 存储机制</h4>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">localStorage</code></strong>：用于持久化存储数据，除非手动删除，否则数据不会过期。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 存储数据</span>
<span class="nx">localStorage</span><span class="p">.</span><span class="nf">setItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 获取数据</span>
<span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nf">getItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
<span class="c1">// 删除数据</span>
<span class="nx">localStorage</span><span class="p">.</span><span class="nf">removeItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">sessionStorage</code></strong>：用于会话级存储，当会话结束（关闭浏览器窗口）时，数据会被清除。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 存储数据</span>
<span class="nx">sessionStorage</span><span class="p">.</span><span class="nf">setItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello, session!</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 获取数据</span>
<span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="nx">sessionStorage</span><span class="p">.</span><span class="nf">getItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>IndexedDB</strong>：用于结构化数据存储。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 打开数据库</span>
<span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">indexedDB</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">myDatabase</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">request</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Database opened successfully</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">request</span><span class="p">.</span><span class="nx">onupgradeneeded</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">createObjectStore</span><span class="p">(</span><span class="dl">'</span><span class="s1">myObjectStore</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">keyPath</span><span class="p">:</span> <span class="dl">'</span><span class="s1">id</span><span class="dl">'</span> <span class="p">});</span>
<span class="nx">objectStore</span><span class="p">.</span><span class="nf">add</span><span class="p">({</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span> <span class="p">});</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="四工程化与最佳实践">四、工程化与最佳实践</h3>

<h4 id="1-代码质量">1. 代码质量</h4>
<ul>
  <li><strong>ESLint 规则</strong>：ESLint 可以强制代码风格一致性。
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装 ESLint</span>
npm <span class="nb">install </span>eslint <span class="nt">--save-dev</span>
<span class="c"># 初始化 ESLint 配置</span>
npx eslint <span class="nt">--init</span>
</code></pre></div>    </div>
  </li>
  <li><strong>目录结构规范</strong>：推荐的目录结构如下：
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/
├── components/  # 组件化组织
├── utils/       # 工具函数
└── services/    # API服务层
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="2-安全实践">2. 安全实践</h4>
<ul>
  <li><strong>输入消毒</strong>：防止 XSS 攻击，转义 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">sanitizeInput</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">input</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/&lt;script&gt;/gi</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&amp;lt;script&amp;gt;</span><span class="dl">'</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/&lt;</span><span class="se">\/</span><span class="sr">script&gt;/gi</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&amp;lt;/script&amp;gt;</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">userInput</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">&lt;script&gt;alert("XSS attack")&lt;/script&gt;</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">sanitizedInput</span> <span class="o">=</span> <span class="nf">sanitizeInput</span><span class="p">(</span><span class="nx">userInput</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">sanitizedInput</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>CSP 策略</strong>：限制资源加载源。
```html
&lt;!DOCTYPE html&gt;</li>
</ul>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'" />
</head>
<body>
  <!-- 页面内容 -->
</body>
</html>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **API 防护**：使用 HTTPS 和 JWT 认证。
```javascript
// 假设这是一个使用 JWT 认证的 API 请求
let token = 'your_jwt_token';
fetch('https://api.example.com/data', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
})
 .then(response =&gt; response.json())
 .then(data =&gt; console.log(data))
 .catch(error =&gt; console.error(error));
</code></pre></div></div>

<h4 id="3-性能优化">3. 性能优化</h4>
<ul>
  <li><strong>防抖/节流</strong>：用于高频事件处理。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 防抖函数</span>
<span class="kd">function</span> <span class="nf">debounce</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">timer</span><span class="p">;</span>
<span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
  <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
  <span class="nx">timer</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">func</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
  <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span>
<span class="c1">// 节流函数</span>
<span class="kd">function</span> <span class="nf">throttle</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">limit</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">inThrottle</span><span class="p">;</span>
<span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">inThrottle</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">func</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="nx">inThrottle</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">inThrottle</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">limit</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>虚拟 DOM</strong>：React 和 Vue 的核心优化原理。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这是一个简化的虚拟 DOM 示例</span>
<span class="kd">class</span> <span class="nc">VNode</span> <span class="p">{</span>
<span class="nf">constructor</span><span class="p">(</span><span class="nx">tag</span><span class="p">,</span> <span class="nx">props</span><span class="p">,</span> <span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">tag</span> <span class="o">=</span> <span class="nx">tag</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">props</span> <span class="o">=</span> <span class="nx">props</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="nx">children</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">vnode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">myDiv</span><span class="dl">'</span> <span class="p">},</span> <span class="p">[]);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>代码分割</strong>：使用动态 <code class="language-plaintext highlighter-rouge">import()</code> 实现代码分割。
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在需要的时候动态加载模块</span>
<span class="nx">button</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">sayHello</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./module.js</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">sayHello</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="五现代工具链">五、现代工具链</h3>

<h4 id="1-开发环境">1. 开发环境</h4>
<ul>
  <li><strong>编辑器</strong>：推荐使用 VS Code，并安装 ESLint 和 Prettier 插件。</li>
  <li><strong>调试工具</strong>：可以使用 Chrome DevTools 进行性能分析。</li>
</ul>

<h4 id="2-框架生态">2. 框架生态</h4>
<ul>
  <li><strong>三大框架</strong>：React、Vue 和 Angular 各有特点。</li>
  <li><strong>元框架</strong>：Next.js 用于服务器端渲染（SSR），Nuxt.js 用于静态站点生成。</li>
</ul>

<h4 id="3-构建工具">3. 构建工具</h4>
<ul>
  <li><strong>打包器</strong>：Webpack 和 Vite 是常用的打包器。
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装 Webpack</span>
npm <span class="nb">install </span>webpack webpack-cli <span class="nt">--save-dev</span>
<span class="c"># 安装 Vite</span>
npm <span class="nb">install </span>vite <span class="nt">--save-dev</span>
</code></pre></div>    </div>
  </li>
  <li><strong>测试工具</strong>：Jest 用于单元测试，Cypress 用于端到端测试（E2E）。
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装 Jest</span>
npm <span class="nb">install </span>jest <span class="nt">--save-dev</span>
<span class="c"># 安装 Cypress</span>
npm <span class="nb">install </span>cypress <span class="nt">--save-dev</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name></name></author><category term="Javascript" /><summary type="html"><![CDATA[Javascript学习笔记]]></summary></entry><entry><title type="html">深度学习学习笔记</title><link href="http://localhost:4000/blog/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2024/02/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="深度学习学习笔记" /><published>2024-02-29T00:00:00+08:00</published><updated>2024-02-29T00:00:00+08:00</updated><id>http://localhost:4000/blog/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2024/02/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2024/02/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="深度学习学习笔记">深度学习学习笔记</h1>

<h2 id="一神经网络基础-neural-network-basics">一、神经网络基础 (Neural Network Basics)</h2>

<h3 id="11-神经网络的组成">1.1 神经网络的组成</h3>
<ul>
  <li><strong>神经元</strong>：模拟生物神经元，接收输入信号并通过激活函数输出</li>
  <li><strong>权重 (Weights)</strong>：控制输入信号的重要性</li>
  <li><strong>偏置 (Bias)</strong>：调整神经元的激活阈值</li>
  <li><strong>激活函数</strong>：引入非线性，常见类型：
    <ul>
      <li>Sigmoid: σ(x) = 1/(1+e⁻ˣ) （用于二分类输出层）</li>
      <li>ReLU: f(x)=max(0,x) （隐藏层首选）</li>
      <li>Softmax: 多分类输出层</li>
    </ul>
  </li>
</ul>

<h4 id="案例房价预测">案例：房价预测</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 单神经元实现
</span><span class="k">def</span> <span class="nf">predict_price</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="nc">ReLU</span><span class="p">(</span><span class="n">area</span> <span class="o">*</span> <span class="n">weight</span> <span class="o">+</span> <span class="n">bias</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="12-反向传播算法">1.2 反向传播算法</h3>
<ol>
  <li>前向传播计算损失</li>
  <li>计算损失函数对权重的梯度 ∂L/∂W</li>
  <li>使用链式法则逐层回传梯度</li>
  <li>更新参数：W = W - α*(∂L/∂W)</li>
</ol>

<h4 id="案例线性回归梯度计算">案例：线性回归梯度计算</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 简化版梯度下降
</span><span class="k">def</span> <span class="nf">gradient_descent</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">W</span> <span class="o">+</span> <span class="n">b</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="n">predictions</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">db</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">predictions</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">W</span> <span class="o">-=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">dW</span>
    <span class="n">b</span> <span class="o">-=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">db</span>
</code></pre></div></div>

<hr />

<h2 id="二浅层神经网络-shallow-neural-networks">二、浅层神经网络 (Shallow Neural Networks)</h2>

<h3 id="21-网络结构">2.1 网络结构</h3>
<ul>
  <li>输入层 → 隐藏层 → 输出层</li>
  <li>隐藏层维度选择：通常为输入特征数的 1.5-2 倍</li>
</ul>

<h3 id="22-激活函数对比">2.2 激活函数对比</h3>
<p>| 函数      | 优点                     | 缺点                     | 使用场景           |
|———–|————————–|————————–|——————–|
| ReLU      | 计算快，缓解梯度消失     | 神经元可能”死亡”        | 隐藏层首选         |
| Leaky ReLU| 解决神经元死亡问题       | 负值区域响应较弱         | 需改进ReLU时使用   |
| Tanh      | 输出零中心化             | 梯度消失问题依然存在     | 二分类输出层       |</p>

<h3 id="23-损失函数">2.3 损失函数</h3>
<ul>
  <li><strong>交叉熵损失</strong>：用于分类任务
\(L = -\frac{1}{N}\sum_{i=1}^N [y_i \log(\hat{y}_i) + (1-y_i)\log(1-\hat{y}_i)]\)</li>
  <li><strong>均方误差</strong>：用于回归任务
\(MSE = \frac{1}{n}\sum_{i=1}^n (y_i - \hat{y}_i)^2\)</li>
</ul>

<h4 id="案例二分类交叉熵计算">案例：二分类交叉熵计算</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binary_cross_entropy</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-15</span>  <span class="c1"># 防止log(0)
</span>    <span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">clip</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">y_true</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_true</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">))</span>
</code></pre></div></div>

<hr />

<h2 id="三深层神经网络-deep-neural-networks">三、深层神经网络 (Deep Neural Networks)</h2>

<h3 id="31-网络深度选择">3.1 网络深度选择</h3>
<ul>
  <li>图像识别：至少5层</li>
  <li>NLP任务：10-24层Transformer</li>
  <li>过拟合预防：增加深度时配合使用正则化</li>
</ul>

<h3 id="32-权重初始化">3.2 权重初始化</h3>
<ul>
  <li><strong>Xavier初始化</strong>：适合tanh激活
\(W \sim \mathcal{N}(0, \sqrt{\frac{1}{n_{in}}})\)</li>
  <li><strong>He初始化</strong>：适合ReLU激活
\(W \sim \mathcal{N}(0, \sqrt{\frac{2}{n_{in}}})\)</li>
</ul>

<h4 id="案例he初始化实现">案例：He初始化实现</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">he_initialization</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">n_in</span><span class="p">):</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">n_in</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">std</span>
</code></pre></div></div>

<h3 id="33-批归一化-batch-normalization">3.3 批归一化 (Batch Normalization)</h3>
<ol>
  <li>计算均值 μ = (1/m)Σx_i</li>
  <li>计算方差 σ² = (1/m)Σ(x_i-μ)²</li>
  <li>归一化 x_norm = (x-μ)/√(σ²+ε)</li>
  <li>缩放平移 y = γ*x_norm + β</li>
</ol>

<h4 id="案例批归一化层实现">案例：批归一化层实现</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BatchNorm</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">var</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">x_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">x_norm</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">beta</span>
</code></pre></div></div>

<hr />

<h2 id="四超参数调优-hyperparameter-tuning">四、超参数调优 (Hyperparameter Tuning)</h2>

<h3 id="41-学习率选择">4.1 学习率选择</h3>
<ul>
  <li>典型值范围：0.001, 0.01, 0.1</li>
  <li>学习率衰减策略：
    <ul>
      <li>指数衰减：α = α₀ * 0.95^epoch</li>
      <li>离散下降：每5个epoch减少50%</li>
    </ul>
  </li>
</ul>

<h3 id="42-优化器对比">4.2 优化器对比</h3>
<p>| 优化器       | 特点                          | 适用场景               |
|————–|——————————-|————————|
| Adam         | 自适应学习率，收敛快          | 大多数场景首选         |
| RMSprop      | 自适应学习率，适合RNN         | 循环神经网络           |
| Momentum     | 加入动量项加速SGD             | 有局部最优问题的场景   |</p>

<h4 id="案例adam优化器实现">案例：Adam优化器实现</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AdamOptimizer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">beta1</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">beta2</span><span class="o">=</span><span class="mf">0.999</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lr</span> <span class="o">=</span> <span class="n">lr</span>
        <span class="n">self</span><span class="p">.</span><span class="n">beta1</span> <span class="o">=</span> <span class="n">beta1</span>
        <span class="n">self</span><span class="p">.</span><span class="n">beta2</span> <span class="o">=</span> <span class="n">beta2</span>
    
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">grads</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">params</span><span class="p">)):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">beta1</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">self</span><span class="p">.</span><span class="n">beta1</span><span class="p">)</span><span class="o">*</span><span class="n">grads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">beta2</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">self</span><span class="p">.</span><span class="n">beta2</span><span class="p">)</span><span class="o">*</span><span class="n">grads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">m_hat</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">beta1</span><span class="o">**</span><span class="n">self</span><span class="p">.</span><span class="n">t</span><span class="p">)</span>
            <span class="n">v_hat</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">beta2</span><span class="o">**</span><span class="n">self</span><span class="p">.</span><span class="n">t</span><span class="p">)</span>
            <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">self</span><span class="p">.</span><span class="n">lr</span> <span class="o">*</span> <span class="n">m_hat</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">v_hat</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="五卷积神经网络-cnn">五、卷积神经网络 (CNN)</h2>

<h3 id="51-卷积层参数计算">5.1 卷积层参数计算</h3>
<ul>
  <li>输出尺寸：O = (W - F + 2P)/S + 1
    <ul>
      <li>W: 输入尺寸</li>
      <li>F: 卷积核大小</li>
      <li>P: 填充</li>
      <li>S: 步长</li>
    </ul>
  </li>
</ul>

<h3 id="52-经典网络架构">5.2 经典网络架构</h3>
<p>| 网络       | 年份 | 特点                          |
|————|——|——————————-|
| LeNet      | 1998 | 最早卷积网络，5层结构         |
| VGG16      | 2014 | 全部使用3x3卷积核，16层       |
| ResNet     | 2015 | 引入残差连接，解决梯度消失     |</p>

<h4 id="案例resnet残差模块">案例：ResNet残差模块</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ResidualBlock</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">filters</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="nc">Conv2D</span><span class="p">(</span><span class="n">filters</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="sh">'</span><span class="s">same</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="nc">Conv2D</span><span class="p">(</span><span class="n">filters</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="sh">'</span><span class="s">same</span><span class="sh">'</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">shortcut</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">X</span> <span class="o">=</span> <span class="nf">relu</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">conv1</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">conv2</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">+=</span> <span class="n">shortcut</span>  <span class="c1"># 残差连接
</span>        <span class="k">return</span> <span class="nf">relu</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="六序列模型-sequence-models">六、序列模型 (Sequence Models)</h2>

<h3 id="61-rnn变体对比">6.1 RNN变体对比</h3>
<p>| 模型       | 遗忘机制 | 门控结构 | 适用场景           |
|————|———-|———-|——————–|
| Vanilla RNN| 无       | 无       | 简单序列任务       |
| LSTM       | 有       | 输入/遗忘/输出门 | 长序列依赖         |
| GRU        | 有       | 重置/更新门      | 需要平衡效果与效率 |</p>

<h3 id="62-注意力机制">6.2 注意力机制</h3>
<ol>
  <li>计算Query-Key相似度：e_t = Query·Key_t</li>
  <li>计算注意力权重：α_t = softmax(e_t)</li>
  <li>加权求和Value向量：c = Σα_t·Value_t</li>
</ol>

<h4 id="案例注意力实现">案例：注意力实现</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">attention</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">d_k</span> <span class="o">=</span> <span class="n">query</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="nf">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="七实践建议-practical-tips">七、实践建议 (Practical Tips)</h2>

<h3 id="71-数据预处理">7.1 数据预处理</h3>
<ol>
  <li>图像：[0,255] → [-1,1] 或 [0,1]</li>
  <li>文本：构建词表 → 分词 → Word2Vec嵌入</li>
  <li>标准化公式：x’ = (x - μ)/(σ + ε)</li>
</ol>

<h3 id="72-正则化技术">7.2 正则化技术</h3>
<ul>
  <li>L2正则化：λΣw²</li>
  <li>Dropout：训练时随机失活神经元</li>
  <li>早停法：监控验证集损失停止训练</li>
</ul>

<h4 id="案例dropout实现">案例：Dropout实现</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dropout</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">drop_prob</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">training</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">drop_prob</span>
    <span class="k">return</span> <span class="n">X</span> <span class="o">*</span> <span class="n">mask</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">drop_prob</span><span class="p">)</span>  <span class="c1"># 反向缩放
</span></code></pre></div></div>]]></content><author><name></name></author><category term="Python" /><category term="深度学习" /><summary type="html"><![CDATA[深度学习学习笔记]]></summary></entry><entry><title type="html">吴恩达深度学习笔记</title><link href="http://localhost:4000/blog/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2023/12/13/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="吴恩达深度学习笔记" /><published>2023-12-13T00:00:00+08:00</published><updated>2023-12-13T00:00:00+08:00</updated><id>http://localhost:4000/blog/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2023/12/13/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/blog/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2023/12/13/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><![CDATA[<h1 id="吴恩达深度学习笔记">吴恩达深度学习笔记</h1>

<h1 id="第一门课-神经网络和深度学习neural-networks-and-deep-learning">第一门课 神经网络和深度学习(Neural Networks and Deep Learning)</h1>

<h2 id="第一周深度学习引言introduction-to-deep-learning">第一周：深度学习引言(Introduction to Deep Learning)</h2>
<h3 id="11-欢迎welcome">1.1 欢迎(Welcome)</h3>
<p>深度学习改变传统互联网业务，如网络搜索和广告，还催生新产品和企业，在读取X光图像、个性化教育、精准农业、自动驾驶等领域表现出色。本课程是专项课程的第一门，后续还有四门。</p>
<ul>
  <li><strong>课程安排</strong>
    <ul>
      <li><strong>第一门课（神经网络和深度学习）</strong>：四周，学习神经网络基础，建立深度神经网络并在数据上训练，结尾用深度神经网络辨认猫。</li>
      <li><strong>第二门课</strong>：三周，进行深度学习实践，学习超参数调整、正则化、诊断偏差和方差以及高级优化算法（如Momentum和Adam算法）。</li>
      <li><strong>第三门课</strong>：两周，学习如何结构化机器学习工程，如数据分割方式、端对端深度学习等。</li>
      <li><strong>第四门课</strong>：学习卷积神经网络（CNN）搭建。</li>
      <li><strong>第五门课</strong>：学习序列模型（如RNN、LSTM）及其在自然语言处理等问题中的应用。</li>
    </ul>
  </li>
</ul>

<h3 id="13-神经网络的监督学习supervised-learning-with-neural-networks">1.3 神经网络的监督学习(Supervised Learning with Neural Networks)</h3>
<p>深度学习系统通过选择合适的 $x$ 和 $y$ 拟合监督学习部分，不同类型的神经网络适用于不同应用：</p>
<ul>
  <li><strong>标准神经网络</strong>：用于房地产和在线广告等相对标准的应用。</li>
  <li><strong>卷积神经网络（CNN）</strong>：常用于图像应用。</li>
  <li><strong>递归神经网络（RNN）</strong>：适用于序列数据，如音频、语言等。对于更复杂的应用（如自动驾驶），可能会使用定制或混合的神经网络结构。</li>
</ul>

<h2 id="第二周神经网络的编程基础basics-of-neural-network-programming">第二周：神经网络的编程基础(Basics of Neural Network programming)</h2>
<h3 id="21-二分类binary-classification">2.1 二分类(Binary Classification)</h3>
<ul>
  <li><strong>训练集表示</strong>：定义矩阵 $X$ 由输入向量 $x^{(1)},x^{(2)},\cdots,x^{(m)}$ 按列组成，规模为 $n_x \times m$，即 <code class="language-plaintext highlighter-rouge">X.shape</code> 等于 $(n_x,m)$。输出标签 $Y$ 由 $y^{(1)},y^{(2)},\cdots,y^{(m)}$ 按列组成，规模为 $1 \times m$，即 <code class="language-plaintext highlighter-rouge">Y.shape</code> 等于 $(1,m)$。</li>
</ul>

<h3 id="24-梯度下降法gradient-descent">2.4 梯度下降法（Gradient Descent）</h3>
<ul>
  <li><strong>步骤</strong>
    <ol>
      <li>以小红点坐标初始化参数 $w$ 和 $b$。</li>
      <li>朝最陡的下坡方向走一步，不断迭代。</li>
      <li>直到走到全局最优解或者接近全局最优解的地方。</li>
    </ol>
  </li>
  <li><strong>细节说明（仅有一个参数）</strong>：假定代价函数 $J(w)$ 只有一个参数 $w$，迭代公式为：
    <ul>
      <li>$w := w - \alpha \frac{dJ(w)}{dw}$</li>
      <li>其中，$\alpha$ 表示学习率，控制步长；$\frac{dJ(w)}{dw}$ 是函数 $J(w)$ 对 $w$ 的导数，代码中用 $dw$ 表示。</li>
    </ul>
  </li>
</ul>

<h3 id="210--m-个样本的梯度下降gradient-descent-on-m-examples">2.10  m 个样本的梯度下降(Gradient Descent on m Examples)</h3>
<ul>
  <li><strong>代价函数</strong>：$J(w,b)=\frac{1}{m}\sum\limits_{i=1}^{m}{L(^{(i)},^{(i)})}$</li>
  <li><strong>代码流程</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">J</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dw1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dw2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">db</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
  <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">J</span> <span class="o">+=</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="nf">log</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
  <span class="n">dz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">dw1</span> <span class="o">+=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dz</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">dw2</span> <span class="o">+=</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dz</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">db</span> <span class="o">+=</span> <span class="n">dz</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="n">J</span> <span class="o">/=</span> <span class="n">m</span><span class="p">;</span>
<span class="n">dw1</span> <span class="o">/=</span> <span class="n">m</span><span class="p">;</span>
<span class="n">dw2</span> <span class="o">/=</span> <span class="n">m</span><span class="p">;</span>
<span class="n">db</span> <span class="o">/=</span> <span class="n">m</span><span class="p">;</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">dw1</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">db</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>这种方法有两个缺点，需要编写两个 <code class="language-plaintext highlighter-rouge">for</code> 循环，深度学习中显式使用 <code class="language-plaintext highlighter-rouge">for</code> 循环会使算法低效，可使用向量化技术摆脱显式 <code class="language-plaintext highlighter-rouge">for</code> 循环。</p>
  </li>
</ul>

<h3 id="217-jupyteripython-notebooks快速入门quick-tour-of-jupyteripython-notebooks">2.17 Jupyter/iPython Notebooks快速入门（Quick tour of Jupyter/iPython Notebooks）</h3>
<ul>
  <li><strong>界面与代码块</strong>：通过界面连接到Coursera，有空白代码块可编写代码，代码块中有开始代码和结束代码，编程练习时代码写在两者之间。</li>
  <li><strong>运行代码块</strong>：可按 <code class="language-plaintext highlighter-rouge">shift + enter</code> 运行代码块，也可点击 <code class="language-plaintext highlighter-rouge">Cell</code> 菜单的 <code class="language-plaintext highlighter-rouge">Run Cells</code> 执行部分代码。</li>
  <li><strong>恢复格式</strong>：若不小心将区域变成markdown语言形式，运行单元格（<code class="language-plaintext highlighter-rouge">shift + enter</code> 或点击 <code class="language-plaintext highlighter-rouge">Cell</code> 菜单的 <code class="language-plaintext highlighter-rouge">Run Cells</code>）可恢复。</li>
  <li><strong>重启内核</strong>：若出现错误信息（如Kernel中断），可点击 <code class="language-plaintext highlighter-rouge">Kernel</code>，选择 <code class="language-plaintext highlighter-rouge">Restart</code> 重启内核。</li>
  <li><strong>提交作业</strong>：完成作业后，点击右上方蓝色的 <code class="language-plaintext highlighter-rouge">Submit Assignment</code> 按钮提交。</li>
</ul>

<h2 id="第三周浅层神经网络shallow-neural-networks">第三周：浅层神经网络(Shallow neural networks)</h2>
<h3 id="31-神经网络概述neural-network-overview">3.1 神经网络概述（Neural Network Overview）</h3>
<ul>
  <li><strong>逻辑回归回顾</strong>：输入特征 $x$、参数 $w$ 和 $b$，计算 $z = w^T x + b$，再通过激活函数 $\sigma(z)$ 得到 $a$，最后计算损失函数 $L(a,y)$。</li>
  <li><strong>神经网络结构</strong>：由多个sigmoid单元堆叠而成，使用符号 $^{[m]}$ 表示第 $m$ 层网络中节点相关的数，与表示单个训练样本的 $^{(i)}$ 区分。</li>
</ul>

<h3 id="32-多样本向量化vectorizing-across-multiple-examples">3.2 多样本向量化（Vectorizing across multiple examples）</h3>
<ul>
  <li><strong>非向量化实现</strong>：对于 $m$ 个训练样本，需重复计算预测值，方程如下：
    <ul>
      <li>$z^{<a href="i">1</a>}=W^{<a href="i">1</a>}x^{(i)}+b^{<a href="i">1</a>}$</li>
      <li>$a^{<a href="i">1</a>}=\sigma(z^{<a href="i">1</a>})$</li>
      <li>$z^{<a href="i">2</a>}=W^{<a href="i">2</a>}a^{<a href="i">1</a>}+b^{<a href="i">2</a>}$</li>
      <li>$a^{<a href="i">2</a>}=\sigma(z^{<a href="i">2</a>})$</li>
    </ul>
  </li>
  <li><strong>向量化实现</strong>：将训练样本组合成矩阵 $X$（规模为 $n \times m$），同理得到矩阵 $Z^{[1]}$、$A^{[1]}$、$Z^{[2]}$ 和 $A^{[2]}$。水平索引对应不同训练样本，垂直索引对应神经网络不同节点。</li>
</ul>

<h1 id="第二门课-改善深层神经网络超参数调试正则化以及优化improving-deep-neural-networkshyperparameter-tuning-regularization-and-optimization">第二门课 改善深层神经网络：超参数调试、正则化以及优化(Improving Deep Neural Networks:Hyperparameter tuning, Regularization and Optimization)</h1>

<h2 id="第一周深度学习的实践层面practical-aspects-of-deep-learning">第一周：深度学习的实践层面(Practical aspects of Deep Learning)</h2>
<h3 id="16-dropout-正则化dropout-regularization">1.6 dropout 正则化（Dropout Regularization）</h3>
<h4 id="实施方法">实施方法</h4>
<p>实施 <strong>dropout</strong> 最常用的方法是 <strong>inverted dropout</strong>（反向随机失活），下面以一个三层（$l = 3$）网络为例说明如何在某一层中实施 <strong>dropout</strong>：</p>
<ol>
  <li>定义向量 $d$，$d^{[3]}$ 表示一个三层的 <strong>dropout</strong> 向量：
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">d3</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">a3</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a3</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div>    </div>
  </li>
  <li>设定 <strong>keep-prob</strong>，它表示保留某个隐藏单元的概率，例如设为 0.8，意味着消除任意一个隐藏单元的概率是 0.2。判断 $d^{[3]}$ 中的元素是否小于 <strong>keep-prob</strong>：
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">keep_prob</span> <span class="o">=</span> <span class="mf">0.8</span>
<span class="n">d3</span> <span class="o">=</span> <span class="p">(</span><span class="n">d3</span> <span class="o">&lt;</span> <span class="n">keep_prob</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>从第三层中获取激活函数 $a^{[3]}$，将其与 $d^{[3]}$ 进行元素相乘：
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a3</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">d3</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>这里的乘法运算会让 $d^{[3]}$ 中所有等于 0 的元素对应的 $a^{[3]}$ 元素归零。在 Python 中，$d^{[3]}$ 是布尔型数组，值为 <strong>true</strong> 和 <strong>false</strong>，乘法运算时 Python 会把 <strong>true</strong> 和 <strong>false</strong> 翻译为 1 和 0。</p>
  </li>
</ol>

<h3 id="17-理解-dropoutunderstanding-dropout">1.7 理解 dropout（Understanding Dropout）</h3>
<h4 id="功能与特点">功能与特点</h4>
<ul>
  <li><strong>dropout</strong> 的功能类似于 $L2$ 正则化，但应用方式不同，且适用于不同的输入范围。</li>
  <li>不同层的 <strong>keep-prob</strong> 可以不同。对于含有较多参数、容易过拟合的层，<strong>keep-prob</strong> 值可以相对较低，如 0.5；对于过拟合程度没那么严重的层，<strong>keep-prob</strong> 值可以高一些，如 0.7；若某一层不必担心过拟合问题，<strong>keep-prob</strong> 可以为 1。通常输入层的 <strong>keep-prob</strong> 接近 1，如 0.9。</li>
</ul>

<h4 id="应用场景与缺点">应用场景与缺点</h4>
<ul>
  <li><strong>dropout</strong> 在计算机视觉领域应用频繁，因为计算机视觉输入量非常大，数据相对不足，容易出现过拟合。</li>
  <li><strong>dropout</strong> 的一大缺点是代价函数 $J$ 不再被明确定义，每次迭代都会随机移除一些节点，难以复查梯度下降的性能。调试时，通常先关闭 <strong>dropout</strong> 函数，将 <strong>keep-prob</strong> 的值设为 1，运行代码确保 $J$ 函数单调递减，然后再打开 <strong>dropout</strong> 函数。</li>
</ul>

<h3 id="113-梯度检验gradient-checking">1.13 梯度检验（Gradient checking）</h3>
<p>梯度检验可用于调试或检验 <strong>backprop</strong> 的实施是否正确，具体步骤如下：</p>
<ol>
  <li>将网络中的所有参数（$W^{[1]}$ 和 $b^{[1]}$……$W^{[l]}$ 和 $b^{[l]}$）转换成一个巨大的向量数据 $\theta$，即将矩阵 $W$ 转换成向量，再进行连接运算。代价函数 $J$ 变为 $\theta$ 的函数 $J(\theta)$。</li>
  <li>同样地，把 $dW^{[1]}$ 和 ${db}^{[1]}$……${dW}^{[l]}$ 和 ${db}^{[l]}$ 转换成一个新的向量 $d\theta$，它与 $\theta$ 具有相同维度。</li>
  <li>为了实施梯度检验，循环执行，对每个 $\theta$ 组成元素计算 $d\theta_{\text{approx}}[i]$ 的值，使用双边误差：
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 示例代码框架，具体实现需要根据实际情况完善
</span><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-7</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">theta</span><span class="p">)):</span>
 <span class="n">theta_plus</span> <span class="o">=</span> <span class="n">theta</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
 <span class="n">theta_plus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_plus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">epsilon</span>
 <span class="n">theta_minus</span> <span class="o">=</span> <span class="n">theta</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
 <span class="n">theta_minus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_minus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">epsilon</span>
 <span class="n">dtheta_approx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nc">J</span><span class="p">(</span><span class="n">theta_plus</span><span class="p">)</span> <span class="o">-</span> <span class="nc">J</span><span class="p">(</span><span class="n">theta_minus</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="第二周优化算法-optimization-algorithms">第二周：优化算法 (Optimization algorithms)</h2>
<h3 id="21-mini-batch-梯度下降mini-batch-gradient-descent">2.1 Mini-batch 梯度下降（Mini-batch gradient descent）</h3>
<h4 id="训练集分割">训练集分割</h4>
<p>可以把训练集分割为小一点的子集，这些子集被称为 <strong>mini-batch</strong>。假设每个子集中有 1000 个样本，将 $x^{(1)}$ 到 $x^{(1000)}$ 称为第一个子训练集 $X^{{1}}$，$x^{(1001)}$ 到 $x^{(2000)}$ 称为 $X^{{2}}$，以此类推。对 $Y$ 也进行相同处理，得到 $Y^{{1}}$，$Y^{{2}}$……$Y^{{t}}$。</p>

<h4 id="符号说明">符号说明</h4>
<ul>
  <li>之前用上角小括号 $(i)$ 表示训练集里的值，$x^{(i)}$ 是第 $i$ 个训练样本。</li>
  <li>用上角中括号 $[l]$ 表示神经网络的层数，$z^{[l]}$ 表示神经网络中第 $l$ 层的 $z$ 值。</li>
  <li>现在引入大括号 ${t}$ 代表不同的 <strong>mini-batch</strong>，所以有 $X^{{t}}$ 和 $Y^{{t}}$。</li>
</ul>

<h4 id="维数说明">维数说明</h4>
<p>如果 $X^{{1}}$ 是一个有 1000 个样本的训练集，其维数应该是 $(n_{x}, 1000)$，$X^{{2}}$ 等所有子集的维数都是 $(n_{x}, 1000)$，而 $Y^{{t}}$ 的维数都是 $(1, 1000)$。</p>

<h4 id="算法对比">算法对比</h4>
<ul>
  <li><strong>batch</strong> 梯度下降法：同时处理整个训练集。</li>
  <li><strong>mini-batch</strong> 梯度下降法：每次同时处理单个的 <strong>mini-batch</strong> $X^{{t}}$ 和 $Y^{{t}}$，而不是同时处理全部的 $X$ 和 $Y$ 训练集。</li>
</ul>

<h3 id="27-rmsprop">2.7 RMSprop</h3>
<h4 id="算法作用">算法作用</h4>
<p><strong>RMSprop</strong> 可以消除梯度下降中的摆动，包括 <strong>mini-batch</strong> 梯度下降，并允许使用一个更大的学习率 $a$，从而加快算法学习速度。其更新过程会使纵轴方向上摆动较小，横轴方向继续推进。</p>

<h4 id="算法细节">算法细节</h4>
<ul>
  <li>为了避免混淆，采用超参数 $\beta_{2}$（与 <strong>Momentum</strong> 中的 $\beta$ 区分）。</li>
  <li>为确保数值稳定，在分母上加上一个很小的 $\varepsilon$，如 $10^{-8}$。</li>
</ul>

<h3 id="29-学习率衰减learning-rate-decay">2.9 学习率衰减(Learning rate decay)</h3>
<p>学习率衰减可以让学习率随着代数或 <strong>mini-batch</strong> 的增加而递减，常见的学习率衰减公式有：</p>
<ul>
  <li>$a = \frac{1}{1 + decayrate * \text{epoch-num}}a_{0}$（<strong>decay-rate</strong> 为衰减率，<strong>epoch-num</strong> 为代数，$\alpha_{0}$ 为初始学习率）
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 示例代码
</span><span class="n">decay_rate</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a0</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">epoch_num</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">decay_rate</span> <span class="o">*</span> <span class="n">epoch_num</span><span class="p">))</span> <span class="o">*</span> <span class="n">a0</span>
</code></pre></div>    </div>
  </li>
  <li>指数衰减：$a = 0.95^{\text{epoch-num}} a_{0}$
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 示例代码
</span><span class="n">a0</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">epoch_num</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.95</span> <span class="o">**</span> <span class="n">epoch_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">a0</span>
</code></pre></div>    </div>
  </li>
  <li>$a = \frac{k}{\sqrt{\text{epoch-num}}}a_{0}$ 或 $a = \frac{k}{\sqrt{t}}a_{0}$（$t$ 为 <strong>mini-batch</strong> 的数字）</li>
  <li>离散下降：在某些步骤学习率减少一半。</li>
</ul>

<h2 id="第三周-超参数调试batch正则化和程序框架hyperparameter-tuning">第三周 超参数调试、Batch正则化和程序框架（Hyperparameter tuning）</h2>
<h3 id="31-调试处理tuning-process">3.1 调试处理（Tuning process）</h3>
<h4 id="超参数重要性">超参数重要性</h4>
<ul>
  <li>学习速率 $a$ 是需要调试的最重要的超参数。</li>
  <li>其次比较重要的参数有 <strong>Momentum</strong> 参数 $\beta$（默认值 0.9）、<strong>mini-batch</strong> 的大小、隐藏单元数量。</li>
  <li>重要性排第三位的参数有层数、学习率衰减。当应用 <strong>Adam</strong> 算法时，通常将 $\beta_{1}$、$\beta_{2}$ 和 $\varepsilon$ 分别选定为 0.9、0.999 和 $10^{-8}$。</li>
</ul>

<h3 id="35-将-batch-norm-拟合进神经网络fitting-batch-norm-into-a-neural-network">3.5 将 Batch Norm 拟合进神经网络（Fitting Batch Norm into a neural network）</h3>
<h4 id="单层-batch-归一化">单层 Batch 归一化</h4>
<p>在单一隐藏层进行 <strong>Batch</strong> 归一化时，将 $z^{[l]}$ 值进行归一化，此过程由 ${\beta}^{[l]}$ 和 $\gamma^{[l]}$ 两参数控制，得到规范化的 ${\tilde{z}}^{[l]}$，然后将其输入激活函数中得到 $a^{[l]}$，即 $a^{[l]} = g^{[l]}({\tilde{z}}^{[l]})$。</p>

<h4 id="深度网络中的应用">深度网络中的应用</h4>
<p>在深度网络训练中，<strong>Batch</strong> 归一化通常和训练集的 <strong>mini-batch</strong> 一起使用。以第一个 <strong>mini-batch</strong>($X^{{1}}$) 为例，计算 $z^{[1]}$ 后进行 <strong>Batch</strong> 归一化，得到 ${\tilde{z}}^{[1]}$，再应用激活函数得到 $a^{[1]}$，然后用 $w^{[2]}$ 和 $b^{[2]}$ 计算 $z^{[2]}$，重复上述过程。</p>

<h3 id="39-训练一个-softmax-分类器training-a-softmax-classifier">3.9 训练一个 Softmax 分类器（Training a Softmax classifier）</h3>
<h4 id="关键方程">关键方程</h4>
<p>在有 <strong>Softmax</strong> 输出层时，初始化反向传播所需要的关键方程是 $dz^{[l]} = \hat{y} - y$，其中 $\hat{y}$ 和 $y$ 都是 $C×1$ 维向量（$C$ 为分类数），$dz^{[l]}$ 是对 $z^{[l]}$ 损失函数的偏导数（$dz^{[l]} = \frac{\partial J}{\partial z^{[l]}}$）。</p>

<h4 id="编程框架应用">编程框架应用</h4>
<p>在这周的初级练习中，使用深度学习编程框架时，通常只需要专注于把前向传播做对，框架会自动实现反向传播和导数计算。</p>

<h3 id="310-深度学习框架deep-learning-frameworks">3.10 深度学习框架（Deep Learning frameworks）</h3>
<h4 id="选择标准">选择标准</h4>
<ul>
  <li>便于编程：包括神经网络的开发和迭代，以及为产品进行配置。</li>
  <li>运行速度：特别是训练大数据集时，一些框架能更高效地运行和训练神经网络。</li>
  <li>开放性：框架不仅要开源，还要有良好的管理，确保能长时间保持开源。</li>
</ul>

<h4 id="框架作用">框架作用</h4>
<p>深度学习框架通过提供比数值线性代数库更高程度的抽象化，能让开发深度机器学习应用更加高效。</p>

<h1 id="第三门课-结构化机器学习项目structuring-machine-learning-projects">第三门课 结构化机器学习项目（Structuring Machine Learning Projects）</h1>

<h2 id="第一周-机器学习ml策略1ml-strategy1">第一周 机器学习（ML）策略（1）（ML strategy（1））</h2>
<p>此部分文档仅提供目录信息 <code class="language-plaintext highlighter-rouge">[TOC]</code>，暂无详细内容。</p>

<h2 id="第二周机器学习策略2ml-strategy-2">第二周：机器学习策略（2）(ML Strategy (2))</h2>

<h3 id="21-进行误差分析carrying-out-error-analysis">2.1 进行误差分析（Carrying out error analysis）</h3>
<p>在机器学习中，人工统计的错误分析步骤虽看似简单，但能节省大量时间，可迅速明确重要且有希望的方向。具体操作如下：</p>
<ul>
  <li>收集约 100 个错误标记的开发集样本，逐个手动检查，统计其中狗的图片数量。</li>
  <li>若 100 个错误标记样本中只有 5% 是狗，即便完全解决狗的问题，最多也只能使错误率从 10% 降至 9.5%，说明在此问题上投入大量时间可能并非明智之举。</li>
  <li>若 100 个错误标记样本中有 50 张是狗的图片，即占比 50%，那么解决狗的问题可能会使错误率从 10% 降至 5%，值得集中精力解决。</li>
</ul>

<p>错误分析还可同时并行评估多个改善算法的想法，如改善针对狗图的性能、处理猫科动物分类错误、解决模糊图像分类问题等。</p>

<h3 id="22-清除标注错误的数据cleaning-up-incorrectly-labeled-data">2.2 清除标注错误的数据（Cleaning up Incorrectly labeled data）</h3>
<p>监督学习问题的数据由输入 $x$ 和输出标签 $y$ 构成，当发现部分输出标签 $y$ 错误时，可参考以下处理方式：</p>

<h4 id="训练集">训练集</h4>
<p>深度学习算法对训练集中的随机错误具有较强的健壮性。只要标记出错的样本接近随机错误，如标记人员的疏忽或误操作，可不花大量时间修复这些错误。但如果存在系统性错误，如将白色的狗一直标记成猫，会影响分类器的学习效果。</p>

<h4 id="开发集和测试集">开发集和测试集</h4>
<ul>
  <li><strong>判断是否值得修正</strong>：若标记错误严重影响在开发集上评估算法的能力，则应花时间修正；反之，则可不处理。例如，当开发集整体错误率为 10%，其中 6% 的错误来自标记出错，即标记错误导致的错误率为 0.6%，此时标记错误占比较小；若将错误率降至 2%，标记错误仍占 0.6%，则标记错误占比变为 30%，此时修正开发集里的错误标签更有价值。</li>
  <li><strong>修正原则</strong>：
    <ul>
      <li>修正手段应同时作用于开发集和测试集，以确保它们来自相同的分布。</li>
      <li>同时检验算法判断正确和判断错误的样本。只修正算法出错的样本可能会使对算法的偏差估计变大，让算法获得不公平的优势。但由于分类器准确时，判断正确的样本数量远多于判断错误的样本，检查所有判断正确样本的标签耗时过长，通常难以实现。</li>
    </ul>
  </li>
</ul>

<h3 id="23-快速搭建你的第一个系统并进行迭代build-your-first-system-quickly-then-iterate">2.3 快速搭建你的第一个系统，并进行迭代（Build your first system quickly, then iterate）</h3>
<p>对于几乎所有的机器学习程序，可能有多个方向可改善系统，但选择优先处理的方向颇具挑战。建议如下：</p>
<ul>
  <li>快速搭建第一个系统，设立开发集、测试集和评估指标，明确目标。</li>
  <li>构建机器学习系统原型，使用训练集进行训练，观察算法在开发集和测试集上的表现。</li>
  <li>利用偏差方差分析和错误分析，确定下一步优先处理的方向。例如，若错误分析表明大部分错误源于说话人远离麦克风，可集中精力研究远场语音识别技术。</li>
</ul>

<p>初始系统可以是快速且粗糙的实现，其目的是确定偏差方差范围，便于进行错误分析，找出最有希望的改进方向。不过，若在应用程序领域有丰富经验，或该领域有大量可借鉴的学术文献（如人脸识别），则可从现有文献出发，搭建更复杂的系统。</p>

<h3 id="28-多任务学习multi-task-learning">2.8 多任务学习（Multi-task learning）</h3>
<p>与迁移学习中串行学习不同，多任务学习是让单个神经网络同时处理多个任务，期望每个任务能相互促进。</p>

<h4 id="示例">示例</h4>
<p>以研发无人驾驶车辆为例，车辆需同时检测行人、车辆、停车标志和交通灯等物体。输入图像 $x^{(i)}$ 对应 4 个标签，$y^{(i)}$ 为 4×1 向量。将训练集的标签水平堆叠起来，得到 $4×m$ 矩阵 $Y$：
\(Y = \begin{bmatrix}
| &amp; | &amp; | &amp; \ldots &amp; | \\
y^{(1)} &amp; y^{(2)} &amp; y^{(3)} &amp; \ldots &amp; y^{(m)} \\
| &amp; | &amp; | &amp; \ldots &amp; | \\
\end{bmatrix}\)</p>

<p>训练一个神经网络，输入 $x$，输出为四维向量 $\hat y$，分别预测图中是否有行人、车辆、停车标志和交通灯。</p>

<h4 id="与-softmax-回归的区别">与 softmax 回归的区别</h4>
<p>softmax 回归为单个样本分配单个标签，而多任务学习中一张图可以有多个标签。训练一个神经网络处理多个任务比训练多个独立的神经网络分别处理这些任务性能更好。</p>

<h4 id="处理部分标记的情况">处理部分标记的情况</h4>
<p>多任务学习也能处理图像只有部分物体被标记的情况。</p>

<h3 id="210-是否要使用端到端的深度学习whether-to-use-end-to-end-learning">2.10 是否要使用端到端的深度学习？（Whether to use end-to-end learning?）</h3>
<p>以无人驾驶技术为例，非端到端的深度学习方法是将车前方传感器的读数作为输入，先检测附近的车、行人等物体，再通过运动规划软件确定车辆行驶路径，最后由控制算法确定方向盘转角、油门和刹车力度。</p>

<p>虽然端到端的深度学习方法（输入图像直接得出方向盘转角）听起来很有吸引力，但就目前可收集的数据和训练神经网络的能力而言，多步方法可能更具前景。因此，在应用监督学习时，应根据可收集的数据仔细选择要学习的 $x$ 到 $y$ 映射类型。</p>

<p>综上所述，端到端的深度学习有时效果显著，但需谨慎选择使用场景。通过学习本周内容，应能更好地做出优先分配任务的决策，推动机器学习项目的发展。同时，建议完成本周作业，以实践这些理念，确保掌握相关知识。</p>

<h1 id="第四门课-卷积神经网络convolutional-neural-networks">第四门课 卷积神经网络（Convolutional Neural Networks）</h1>

<h2 id="第一周-卷积神经网络foundations-of-convolutional-neural-networks">第一周 卷积神经网络（Foundations of Convolutional Neural Networks）</h2>
<h3 id="12-边缘检测示例edge-detection-example">1.2 边缘检测示例（Edge detection example）</h3>
<p>卷积运算是卷积神经网络最基本的组成部分，以边缘检测作为入门样例。神经网络的前几层检测边缘，后面的层检测物体的部分区域，更靠后的层检测完整的物体。</p>

<p>示例：对6×6的灰度图像（6×6×1矩阵）进行垂直边缘检测，使用3×3的过滤器 $\begin{bmatrix}1 &amp; 0 &amp; -1\ 1 &amp; 0 &amp; -1\ 1 &amp; 0 &amp; -1\end{bmatrix}$ 进行卷积运算。在数学中“$*$”是卷积的标准标志，但在Python中常表示乘法或元素乘法，需特别说明。</p>

<p>卷积运算输出是4×4的矩阵，计算方式如下：</p>
<ul>
  <li>计算第一个元素（4×4左上角）：将3×3过滤器覆盖在输入图像上，进行元素乘法运算，如 $\begin{bmatrix} 3 \times 1 &amp; 0 \times 0 &amp; 1 \times \left(-1 \right) \ 1 \times 1 &amp; 5 \times 0 &amp; 8 \times \left( - 1 \right) \ 2 \times1 &amp; 7 \times 0 &amp; 2 \times \left( - 1 \right) \ \end{bmatrix} = \begin{bmatrix}3 &amp; 0 &amp; - 1 \ 1 &amp; 0 &amp; - 8 \ 2 &amp; 0 &amp; - 2 \\end{bmatrix}$，然后将矩阵元素相加得 $3+1+2+0+0 +0+(-1)+(-8) +(-2)=-5$。</li>
  <li>计算第二个元素：将过滤器向右移动一步，继续元素乘法和相加，$0×1+5×1+7×1+1×0+8×0+2×0+2×(-1)+ 9×(-1)+5×(-1)=-4 $。</li>
</ul>

<h3 id="17-单层卷积网络one-layer-of-a-convolutional-network">1.7 单层卷积网络（One layer of a convolutional network）</h3>
<p>每个过滤器有一个偏差参数，是实数，在代码中表示为1×1×1×$n_{c}^{[l]}$ 的四维向量或四维张量。</p>

<p>卷积有多种标记方法，关于高度、宽度和通道的顺序没有完全统一的标准，课上按高度、宽度和通道损失数量的顺序依次计算。</p>

<h3 id="18-简单卷积网络示例a-simple-convolution-network-example">1.8 简单卷积网络示例（A simple convolution network example）</h3>
<p>假设输入图片大小为39×39×3，即 $n_{H}^{[0]} = n_{W}^{[0]} = 39$，$n_{c}^{[0]} = 3$。</p>
<ul>
  <li>第一层：用3×3的过滤器（$f^{[1]} = 3$），步幅 $s^{[1]} = 1$，padding $p^{[1]} = 0$，10个过滤器。输出激活值为37×37×10，因为 $\frac{39 + 0 - 3}{1} + 1 = 37$，即 $n_{H}^{[1]} = n_{W}^{[1]} = 37$，$n_{c}^{[1]} = 10$。</li>
  <li>第二层：用5×5的过滤器（$f^{\left\lbrack 2 \right\rbrack} = 5$），步幅 $s^{\left\lbrack 2 \right\rbrack} = 2$，padding $p^{\left\lbrack 2 \right\rbrack} = 0$，20个过滤器。输出为17×17×20，即 $n_{H}^{\left\lbrack 2 \right\rbrack} = n_{W}^{\left\lbrack 2 \right\rbrack} = 17$，$n_{c}^{\left\lbrack 2 \right\rbrack} = 20$。</li>
  <li>第三层：用5×5的过滤器（$f^{\left\lbrack 2 \right\rbrack} = 5$），步幅 $s^{\left\lbrack 3 \right\rbrack} = 2$，padding为0，40个过滤器。输出为7×7×40。</li>
</ul>

<h3 id="110-卷积神经网络示例convolutional-neural-network-example">1.10 卷积神经网络示例（Convolutional neural network example）</h3>
<p>假设输入是32×32×3的RGB图片，用于手写体数字识别（识别0 - 9）。</p>
<ul>
  <li><strong>CONV1</strong>：使用5×5的过滤器，步幅1，padding 0，6个过滤器。输出为28×28×6，增加偏差，应用ReLU非线性函数。</li>
  <li><strong>POOL1</strong>：最大池化，过滤器2×2，步幅2，padding 0。输出为14×14×6。</li>
  <li>全连接层：添加一个含84个单元的全连接层（FC4）。</li>
  <li>Softmax层：最后用84个单元填充一个Softmax单元，有10个输出。</li>
</ul>

<p>随着神经网络深度加深，高度 $n_{H}$ 和宽度 $n_{W}$ 通常减少，通道数量增加。常见模式是一个或多个卷积后面跟随一个池化层，然后是几个全连接层，最后是一个Softmax。</p>

<p>激活值形状和大小：输入为32×32×3，激活值 $a^{[0]}$ 有3072维，输入层无参数。池化层和最大池化层无参数，卷积层参数相对较少，许多参数在全连接层。</p>

<h3 id="111-为什么使用卷积why-convolutions">1.11 为什么使用卷积？（Why convolutions?）</h3>
<p>本周学习了卷积神经网络的基本构造模块，可通过编程练习深入理解。下周将展示有效卷积神经网络示例，分析其高效原因，讲解新的计算机视觉应用。</p>

<h2 id="第二周-深度卷积网络实例探究deep-convolutional-models-case-studies">第二周 深度卷积网络：实例探究（Deep convolutional models: case studies）</h2>
<h3 id="21-为什么要进行实例探究why-look-at-case-studies">2.1 为什么要进行实例探究？（Why look at case studies?）</h3>
<p>过去几年计算机视觉研究集中在组合基本构件形成有效卷积神经网络，通过看案例学习是不错的办法。在计算机视觉任务中表现良好的神经网络框架往往适用于其它任务。</p>

<p>后面几节课将介绍经典网络，如LeNet - 5、AlexNet、VGG网络，还有ResNet（残差网络）和Inception神经网络。</p>

<h3 id="29-迁移学习transfer-learning">2.9 迁移学习（Transfer Learning）</h3>
<p>可从网上下载训练好的神经网络开源实现和权重，如ImageNet数据集的网络。去掉原网络的Softmax层，创建自己的Softmax单元，冻结前面层的参数，只训练与新Softmax层有关的参数。不同深度学习框架有不同方式指定是否训练特定层的权重。</p>

<h3 id="211-计算机视觉现状the-state-of-computer-vision">2.11 计算机视觉现状（The state of computer vision）</h3>
<p>计算机视觉研究者致力于在基准测试中表现出色以发表论文，这有助于社区找出有效算法，但有些技巧不适合实际生产应用。</p>

<p>有助于在基准测试中表现出色的技巧：</p>
<ul>
  <li>集成：独立训练几个神经网络，平均它们的输出，但不要平均权重。可提高性能，但会增加运行时间。</li>
  <li>Multi - crop at test time：将数据扩充应用到测试图像，如10 - crop技术，取图片的中心区域和四个角落区域进行裁剪，通过分类器运行，对镜像图像做同样操作。</li>
</ul>

<h2 id="第三周">第三周</h2>
<h3 id="32-特征点检测landmark-detection">3.2 特征点检测（Landmark detection）</h3>
<p>可定义人物的关键特征点，如脸部特征点（假设64个）、人体姿态特征点（如胸部中点、左肩、左肘、腰等，假设32个）。</p>

<p>具体做法：准备卷积网络和特征集，输入人脸图片，输出1或0表示有无人脸，再输出特征点的 $(x,y)$ 坐标。例如，检测脸部特征有129个输出单元（1表示有人脸，64×2 = 128个特征点坐标）。可用于识别脸部表情、实现AR过滤器、脸部扭曲等效果，需要准备标签训练集。</p>

<h3 id="310-候选区域选修region-proposals-optional">3.10 候选区域（选修）（Region proposals (Optional)）</h3>
<p>相关文献：</p>
<ul>
  <li>Joseph Redmon, Ali Farhadi - <a href="https://arxiv.org/abs/1612.08242">YOLO9000: Better, Faster, Stronger</a> (2016)</li>
  <li>Allan Zelener - <a href="https://github.com/allanzelener/YAD2K">YAD2K: Yet Another Darknet 2 Keras</a></li>
  <li>The official YOLO website (<a href="https://pjreddie.com/darknet/yolo/">https://pjreddie.com/darknet/yolo/</a>)</li>
</ul>

<h2 id="第四周">第四周</h2>
<h3 id="47-cnn特征可视化what-are-deep-convnets-learning">4.7 CNN特征可视化（What are deep ConvNets learning?）</h3>
<p>通过可视化例子理解深度卷积网络在学什么，有助于实现神经风格迁移。</p>

<p>以Alexnet为例，从第一层隐藏单元开始，遍历训练集，找到使单元激活最大化的图片或图片块。第一层隐藏单元通常找简单特征，如边缘或颜色阴影。</p>

<h1 id="第五门课-序列模型学习笔记">第五门课 序列模型学习笔记</h1>

<h2 id="第一周-循环序列模型recurrent-neural-networks">第一周 循环序列模型（Recurrent Neural Networks）</h2>
<h3 id="17-对新序列采样sampling-novel-sequences">1.7 对新序列采样（Sampling novel sequences）</h3>
<p>基础的 RNN 结构可用于建立语言模型并进行采样。示例生成的句子如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>And subject of this thou art another this fold.
When besser be my love to me see sabl's.
For whose are ruse of mine eyes heaves.
</code></pre></div></div>
<p>后续将探讨训练 RNN 时的梯度消失问题，以及引入 GRU（门控循环单元）和 LSTM（长期记忆网络模型）。</p>

<h3 id="112-深层循环神经网络deep-rnns">1.12 深层循环神经网络（Deep RNNs）</h3>
<ul>
  <li><strong>激活值计算示例</strong>：以激活值 $a^{\lbrack 2\rbrack &lt;3&gt;}$ 为例，它有两个输入。</li>
  <li><strong>网络层数特点</strong>：与标准神经网络不同，RNN 有三层就算比较深了，因为时间维度会使网络规模增大。</li>
</ul>

<p>从基本的 RNN 网络，到 GRU、LSTM、双向 RNN 以及深层版模型，学完后可构建不错的学习序列的模型。</p>

<h2 id="第二周-词嵌入相关内容">第二周 词嵌入相关内容</h2>
<h3 id="21-词汇表征word-representation">2.1 词汇表征（Word Representation）</h3>
<ul>
  <li><strong>词嵌入与可视化</strong>：学习 300 维的词嵌入后，可用 t - SNE 算法将其可视化到二维空间。相近概念的词嵌入在可视化时会聚集在一起，如 man 和 woman、king 和 queen 等。</li>
  <li><strong>嵌入的含义</strong>：每个单词对应 300 维空间里的一个点，就像被“嵌入”到这个空间中。词嵌入是 NLP 领域重要概念。</li>
</ul>

<h3 id="22-使用词嵌入using-word-embeddings">2.2 使用词嵌入（Using Word Embeddings）</h3>
<ul>
  <li><strong>迁移学习步骤</strong>：
    <ol>
      <li>用词嵌入模型迁移到新的少量标注训练集任务中，用 300 维特征向量代替 10000 维的 one - hot 向量。</li>
      <li>在新任务训练模型时，可选择是否微调词嵌入。若标记数据集小，通常不进行微调。</li>
    </ol>
  </li>
  <li><strong>应用场景</strong>：词嵌入在训练集较小时作用明显，广泛用于命名实体识别、文本摘要、文本解析、指代消解等 NLP 任务，但在语言模型和机器翻译领域应用相对较少。</li>
  <li><strong>与人脸编码的关系</strong>：词嵌入和人脸编码有奇妙关系，人脸识别训练的 Siamese 网络结构与之相关。</li>
</ul>

<h3 id="24-嵌入矩阵embedding-matrix">2.4 嵌入矩阵（Embedding Matrix）</h3>
<ul>
  <li><strong>矩阵定义</strong>：假设词汇表有 10000 个单词，学习的嵌入矩阵 $E$ 是 300×10000 的矩阵，各列代表词汇表中不同单词的向量。</li>
  <li><strong>计算示例</strong>：若“orange”编号是 6257，用 one - hot 向量 $O_{6527}$ 与 $E$ 相乘，可得到“orange”的 300 维嵌入向量。</li>
  <li><strong>实际应用</strong>：实际中，使用专门函数查找矩阵 $E$ 的某列，而非矩阵乘法，如 Keras 中的嵌入层。</li>
</ul>

<h3 id="25-学习词嵌入learning-word-embeddings">2.5 学习词嵌入（Learning Word Embeddings）</h3>
<ul>
  <li><strong>神经网络模型</strong>：将 300 维嵌入向量放入神经网络，经过 softmax 层预测结尾单词。</li>
  <li><strong>固定历史窗口</strong>：使用固定历史窗口（如 4 个单词）可处理任意长度句子，输入维度固定为 1200 维。</li>
  <li><strong>简单上下文模型</strong>：可以用目标词的前一个词或附近一个单词作为上下文来构建神经网络学习词嵌入。</li>
</ul>

<h3 id="26-word2vec">2.6 Word2Vec</h3>
<ul>
  <li><strong>监督学习问题构造</strong>：随机选一个上下文词，在其正负 10 个词距或正负 5 个词距内选目标词，构造监督学习问题来学习词嵌入。</li>
  <li><strong>模型细节</strong>：输入上下文词的 one - hot 向量 $O_{c}$ 与嵌入矩阵 $E$ 相乘得到嵌入向量 $e_{c}$，将其喂入 softmax 单元，预测不同目标词的概率：
  \(Softmax:p\left( t \middle| c \right) = \frac{e^{\theta_{t}^{T}e_{c}}}{\sum_{j = 1}^{10,000}e^{\theta_{j}^{T}e_{c}}}\)</li>
</ul>

<h3 id="27-负采样negative-sampling">2.7 负采样（Negative Sampling）</h3>
<ul>
  <li><strong>训练集生成</strong>：选择一个上下文词和一个目标词作为正样本（标签为 1），再用相同上下文词和从字典中随机选取的词作为负样本（标签为 0）。</li>
  <li><strong>监督学习问题</strong>：输入一对词，预测它们是否一起出现。</li>
  <li><strong>K 值选择</strong>：小数据集 $K$ 选 5 到 20，大数据集 $K$ 选 2 到 5。</li>
</ul>

<h2 id="第三周-序列模型和注意力机制sequence-models--attention-mechanism">第三周 序列模型和注意力机制（Sequence models &amp; Attention mechanism）</h2>
<h3 id="31-基础模型basic-models">3.1 基础模型（Basic Models）</h3>
<ul>
  <li><strong>seq2seq 模型</strong>：本周学习 seq2seq 模型，用于机器翻译、语音识别等。</li>
  <li><strong>编码解码网络</strong>：建立编码网络（RNN 结构，单元可以是 GRU 或 LSTM）对输入序列编码，输出向量；再建立解码网络，以编码网络输出为输入，训练为每次输出一个翻译后的单词。</li>
  <li><strong>图像描述应用</strong>：类似结构可用于图像描述，输入图像输出描述。</li>
</ul>

<h3 id="37-注意力模型直观理解attention-model-intuition">3.7 注意力模型直观理解（Attention Model Intuition）</h3>
<ul>
  <li><strong>模型改进</strong>：在编码解码构架基础上引入注意力模型，使其工作更好。</li>
  <li><strong>模型起源</strong>：注意力模型源于 Dimitri, Bahdanau, Camcrun Cho, Yoshe Bengio 的论文，虽源于机器翻译，但已推广到其他领域。</li>
  <li><strong>示例说明</strong>：用短句举例说明注意力模型思想。</li>
</ul>

<h3 id="310-触发字检测trigger-word-detection">3.10 触发字检测（Trigger Word Detection）</h3>
<ul>
  <li><strong>算法现状</strong>：触发字检测系统文献处于发展阶段，尚无广泛定论的最佳算法。</li>
  <li><strong>简单解决方法</strong>：在输出变回 0 之前多次输出 1，提高 1 与 0 的比例，便于训练。</li>
  <li><strong>学习总结</strong>：总结学习了 RNN（包括 GRU 和 LSTM）、词嵌入、注意力模型等内容。</li>
</ul>

<h3 id="311-结论和致谢conclusion-and-thank-you">3.11 结论和致谢（Conclusion and thank you）</h3>
<ul>
  <li><strong>学习总结</strong>：学完整个专业课程，掌握了神经网络和深度学习、改进深度神经网络、结构化机器学习项目、卷积神经网络和序列模型等知识。</li>
  <li><strong>鼓励与感谢</strong>：深度学习是超能力，恭喜完成课程学习，感谢花费时间和精力学习。</li>
</ul>]]></content><author><name></name></author><category term="Python" /><category term="深度学习" /><summary type="html"><![CDATA[吴恩达深度学习笔记]]></summary></entry></feed>