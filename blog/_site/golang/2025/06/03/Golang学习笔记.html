<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Golang学习笔记</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Golang学习笔记" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Golang学习笔记" />
<meta property="og:description" content="Golang学习笔记" />
<link rel="canonical" href="http://localhost:4000/blog/golang/2025/06/03/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" />
<meta property="og:url" content="http://localhost:4000/blog/golang/2025/06/03/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-06-03T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Golang学习笔记" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-03T00:00:00+08:00","datePublished":"2025-06-03T00:00:00+08:00","description":"Golang学习笔记","headline":"Golang学习笔记","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/golang/2025/06/03/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},"url":"http://localhost:4000/blog/golang/2025/06/03/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" /></head>
<body><a href="/" class="home-link">返回简历主页</a>
<!-- 确保自定义样式被加载 -->
<link rel="stylesheet" href="/blog/assets/css/main.scss"><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Golang学习笔记</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-06-03T00:00:00+08:00" itemprop="datePublished">Jun 3, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="golang学习笔记">Golang学习笔记</h1>

<h3 id="一基础语法">一、基础语法</h3>
<h4 id="1-变量与常量">1. 变量与常量</h4>
<ul>
  <li><strong>变量声明</strong>：
    <ul>
      <li>标准格式：<code class="language-plaintext highlighter-rouge">var 变量名 类型</code></li>
      <li>简短格式：<code class="language-plaintext highlighter-rouge">变量名 := 值</code>（函数内使用）</li>
      <li>批量声明：<code class="language-plaintext highlighter-rouge">var (a int; b string)</code>
```go
package main</li>
    </ul>
  </li>
</ul>

<p>import “fmt”</p>

<p>func main() {
    // 标准格式
    var num int
    num = 10
    // 简短格式
    str := “Hello, Golang!”
    // 批量声明
    var (
        a int
        b string
    )
    a = 20
    b = “World”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println(num, str, a, b) } ``` - **常量**：使用 `const` 定义，支持 `iota` 实现枚举自增。 ```go package main
</code></pre></div></div>

<p>import “fmt”</p>

<p>const (
    Monday = iota + 1
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)</p>

<p>func main() {
    fmt.Println(Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **数据类型**：
    - 基本类型：整型（`int8~int64`）、浮点型（`float32/64`）、布尔型（`bool`）、字符串（`string`，不可变）。
    - 派生类型：数组、切片、Map、结构体、指针等。
```go
package main

import "fmt"

func main() {
    // 基本类型
    var num int8 = 127
    var f float32 = 3.14
    var isTrue bool = true
    var str string = "Golang"

    // 派生类型 - 数组
    var arr [3]int = [3]int{1, 2, 3}
    // 派生类型 - 切片
    slice := []int{4, 5, 6}
    // 派生类型 - Map
    m := map[string]int{"one": 1, "two": 2}
    // 派生类型 - 结构体
    type Person struct {
        Name string
        Age  int
    }
    p := Person{Name: "John", Age: 30}
    // 派生类型 - 指针
    ptr := &amp;num

    fmt.Println(num, f, isTrue, str, arr, slice, m, p, *ptr)
}
</code></pre></div></div>

<h4 id="2-流程控制">2. 流程控制</h4>
<ul>
  <li><strong>分支</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">if-else</code> 条件灵活，可前置执行语句；</li>
      <li><code class="language-plaintext highlighter-rouge">switch</code> 支持多值匹配，默认 <code class="language-plaintext highlighter-rouge">break</code>，需显式使用 <code class="language-plaintext highlighter-rouge">fallthrough</code> 继续下一分支。
```go
package main</li>
    </ul>
  </li>
</ul>

<p>import “fmt”</p>

<p>func main() {
    // if-else
    if num := 10; num &gt; 5 {
        fmt.Println(“num is greater than 5”)
    } else {
        fmt.Println(“num is less than or equal to 5”)
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// switch
day := 3
switch day {
case 1, 2, 3, 4, 5:
    fmt.Println("Weekday")
case 6, 7:
    fmt.Println("Weekend")
default:
    fmt.Println("Invalid day")
}

// fallthrough
num := 2
switch num {
case 1:
    fmt.Println("One")
case 2:
    fmt.Println("Two")
    fallthrough
case 3:
    fmt.Println("Three")
} } ``` - **循环**：仅 `for` 关键字，支持 `break`/`continue` 控制嵌套循环。 ```go package main
</code></pre></div></div>

<p>import “fmt”</p>

<p>func main() {
    // 基本 for 循环
    for i := 0; i &lt; 5; i++ {
        fmt.Print(i, “ “)
    }
    fmt.Println()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 类似 while 循环
j := 0
for j &lt; 5 {
    fmt.Print(j, " ")
    j++
}
fmt.Println()

// 无限循环
k := 0
for {
    if k &gt;= 5 {
        break
    }
    fmt.Print(k, " ")
    k++
}
fmt.Println()

// 嵌套循环
for i := 0; i &lt; 3; i++ {
    for j := 0; j &lt; 2; j++ {
        if i == 1 &amp;&amp; j == 1 {
            continue
        }
        fmt.Printf("(%d, %d) ", i, j)
    }
}
fmt.Println() } ```
</code></pre></div></div>

<h4 id="3-函数特性">3. 函数特性</h4>
<ul>
  <li><strong>多返回值</strong>：函数可返回多个值，需显式接收。
```go
package main</li>
</ul>

<p>import “fmt”</p>

<p>func swap(a, b int) (int, int) {
    return b, a
}</p>

<p>func main() {
    x, y := 10, 20
    x, y = swap(x, y)
    fmt.Println(x, y)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **闭包**：匿名函数可捕获外部变量，形成闭包。
```go
package main

import "fmt"

func getSequence() func() int {
    i := 0
    return func() int {
        i++
        return i
    }
}

func main() {
    nextNumber := getSequence()
    fmt.Println(nextNumber())
    fmt.Println(nextNumber())
    fmt.Println(nextNumber())

    newNextNumber := getSequence()
    fmt.Println(newNextNumber())
}
</code></pre></div></div>
<ul>
  <li><strong>延迟执行</strong>：<code class="language-plaintext highlighter-rouge">defer</code> 注册延迟调用，按栈顺序执行（后进先出），常用于资源释放。
```go
package main</li>
</ul>

<p>import “fmt”</p>

<p>func main() {
    defer fmt.Println(“Last”)
    defer fmt.Println(“Second”)
    fmt.Println(“First”)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### 二、并发模型（核心优势）
#### 1. Goroutine
- 轻量级协程，由 Go 运行时调度，开销极小（可创建百万级），比线程高效。
- 启动方式：`go func()`
```go
package main

import (
    "fmt"
    "time"
)

func printNumbers() {
    for i := 0; i &lt; 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Print(i, " ")
    }
}

func main() {
    go printNumbers()
    time.Sleep(1 * time.Second)
    fmt.Println("Main goroutine finished")
}
</code></pre></div></div>

<h4 id="2-channel">2. Channel</h4>
<ul>
  <li>协程间通信管道，分无缓冲（同步阻塞）和有缓冲（异步队列）。
```go
package main</li>
</ul>

<p>import (
    “fmt”
)</p>

<p>func main() {
    // 无缓冲通道
    ch := make(chan int)
    go func() {
        ch &lt;- 10
    }()
    num := &lt;-ch
    fmt.Println(num)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 有缓冲通道
bufferedCh := make(chan int, 2)
bufferedCh &lt;- 20
bufferedCh &lt;- 30
fmt.Println(&lt;-bufferedCh)
fmt.Println(&lt;-bufferedCh) } ```
</code></pre></div></div>

<h4 id="3-同步原语">3. 同步原语</h4>
<ul>
  <li><strong>互斥锁</strong>：<code class="language-plaintext highlighter-rouge">sync.Mutex</code> 保护临界区。
```go
package main</li>
</ul>

<p>import (
    “fmt”
    “sync”
)</p>

<p>var (
    counter int
    mutex   sync.Mutex
)</p>

<p>func increment() {
    mutex.Lock()
    defer mutex.Unlock()
    counter++
}</p>

<p>func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            increment()
        }()
    }
    wg.Wait()
    fmt.Println(counter)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **读写锁**：`sync.RWMutex` 允许多读单写。
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var (
    data     int
    rwMutex  sync.RWMutex
)

func readData() {
    rwMutex.RLock()
    defer rwMutex.RUnlock()
    fmt.Println("Read data:", data)
    time.Sleep(100 * time.Millisecond)
}

func writeData() {
    rwMutex.Lock()
    defer rwMutex.Unlock()
    data++
    fmt.Println("Write data:", data)
    time.Sleep(200 * time.Millisecond)
}

func main() {
    var wg sync.WaitGroup

    // 启动多个读操作
    for i := 0; i &lt; 3; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            readData()
        }()
    }

    // 启动一个写操作
    wg.Add(1)
    go func() {
        defer wg.Done()
        writeData()
    }()

    wg.Wait()
}
</code></pre></div></div>
<ul>
  <li><strong>WaitGroup</strong>：<code class="language-plaintext highlighter-rouge">sync.WaitGroup</code> 等待一组协程结束。
```go
package main</li>
</ul>

<p>import (
    “fmt”
    “sync”
    “time”
)</p>

<p>func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf(“Worker %d starting\n”, id)
    time.Sleep(time.Second)
    fmt.Printf(“Worker %d done\n”, id)
}</p>

<p>func main() {
    var wg sync.WaitGroup
    for i := 1; i &lt;= 5; i++ {
        wg.Add(1)
        go worker(i, &amp;wg)
    }
    wg.Wait()
    fmt.Println(“All workers finished”)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### 三、数据结构
#### 1. 切片（Slice）
- 动态数组，基于数组封装，含指针、长度、容量三属性。
- 操作：`make()` 创建、`append()` 追加（自动扩容）、`copy()` 深拷贝。
```go
package main

import (
    "fmt"
)

func main() {
    // 创建切片
    slice := make([]int, 0, 5)
    // 追加元素
    slice = append(slice, 1, 2, 3)
    fmt.Println(slice)

    // 深拷贝
    newSlice := make([]int, len(slice))
    copy(newSlice, slice)
    fmt.Println(newSlice)
}
</code></pre></div></div>

<h4 id="2-映射map">2. 映射（Map）</h4>
<ul>
  <li>键值对集合，无序，使用 <code class="language-plaintext highlighter-rouge">make(map[key]value)</code> 初始化。</li>
  <li>安全访问：需配合 <code class="language-plaintext highlighter-rouge">sync.Map</code> 或互斥锁应对并发。
```go
package main</li>
</ul>

<p>import (
    “fmt”
    “sync”
)</p>

<p>func main() {
    // 初始化 Map
    m := make(map[string]int)
    m[“one”] = 1
    m[“two”] = 2
    fmt.Println(m)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 并发安全的 Map
var syncMap sync.Map
syncMap.Store("three", 3)
value, ok := syncMap.Load("three")
if ok {
    fmt.Println(value)
} } ```
</code></pre></div></div>

<h4 id="3-结构体struct">3. 结构体（Struct）</h4>
<ul>
  <li>组合不同类型字段，支持匿名字段和嵌套，实现组合式“继承”。</li>
  <li>方法定义：<code class="language-plaintext highlighter-rouge">func (s Struct) method() {}</code>，接收者可为值或指针。
```go
package main</li>
</ul>

<p>import (
    “fmt”
)</p>

<p>// 定义结构体
type Animal struct {
    Name string
    Age  int
}</p>

<p>// 定义方法
func (a Animal) Speak() {
    fmt.Printf(“%s says hello!\n”, a.Name)
}</p>

<p>// 嵌套结构体
type Dog struct {
    Animal
    Breed string
}</p>

<p>func main() {
    dog := Dog{
        Animal: Animal{Name: “Buddy”, Age: 3},
        Breed:  “Golden Retriever”,
    }
    dog.Speak()
    fmt.Println(dog.Breed)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### 四、面向对象特性
#### 1. 封装
- 通过首字母大小写控制可见性：大写公有，小写私有。
```go
package main

import (
    "fmt"
)

// 公有结构体
type PublicStruct struct {
    PublicField string
    privateField string
}

// 公有方法
func (p PublicStruct) PublicMethod() {
    fmt.Println("Public method called")
}

// 私有方法
func (p PublicStruct) privateMethod() {
    fmt.Println("Private method called")
}

func main() {
    ps := PublicStruct{PublicField: "Hello"}
    ps.PublicMethod()
    // ps.privateMethod() // 无法调用私有方法
}
</code></pre></div></div>

<h4 id="2-接口interface">2. 接口（Interface）</h4>
<ul>
  <li>隐式实现：类型无需显式声明接口，只需实现全部方法（Duck Typing）。</li>
  <li>空接口 <code class="language-plaintext highlighter-rouge">interface{}</code> 可接收任意类型（类似 <code class="language-plaintext highlighter-rouge">any</code>）。
```go
package main</li>
</ul>

<p>import (
    “fmt”
)</p>

<p>// 定义接口
type Shape interface {
    Area() float64
}</p>

<p>// 定义结构体
type Circle struct {
    Radius float64
}</p>

<p>// 实现接口方法
func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}</p>

<p>func printArea(s Shape) {
    fmt.Println(“Area:”, s.Area())
}</p>

<p>func main() {
    circle := Circle{Radius: 5}
    printArea(circle)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 空接口
var anyValue interface{}
anyValue = 10
fmt.Println(anyValue)
anyValue = "Hello"
fmt.Println(anyValue) } ```
</code></pre></div></div>

<h4 id="3-多态">3. 多态</h4>
<ul>
  <li>接口变量可持有不同实现类型的实例，调用同名方法表现不同行为。
```go
package main</li>
</ul>

<p>import (
    “fmt”
)</p>

<p>// 定义接口
type Speaker interface {
    Speak()
}</p>

<p>// 定义结构体
type Dog struct{}
type Cat struct{}</p>

<p>// 实现接口方法
func (d Dog) Speak() {
    fmt.Println(“Woof!”)
}</p>

<p>func (c Cat) Speak() {
    fmt.Println(“Meow!”)
}</p>

<p>func makeSpeak(s Speaker) {
    s.Speak()
}</p>

<p>func main() {
    dog := Dog{}
    cat := Cat{}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makeSpeak(dog)
makeSpeak(cat) } ```
</code></pre></div></div>

<h3 id="五高级特性与工具">五、高级特性与工具</h3>
<h4 id="1-错误处理">1. 错误处理</h4>
<ul>
  <li>多返回值返回 <code class="language-plaintext highlighter-rouge">error</code> 对象，配合 <code class="language-plaintext highlighter-rouge">if err != nil</code> 检查。</li>
  <li>自定义错误：<code class="language-plaintext highlighter-rouge">errors.New()</code> 或实现 <code class="language-plaintext highlighter-rouge">error</code> 接口。
```go
package main</li>
</ul>

<p>import (
    “errors”
    “fmt”
)</p>

<p>func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New(“division by zero”)
    }
    return a / b, nil
}</p>

<p>func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println(“Error:”, err)
    } else {
        fmt.Println(“Result:”, result)
    }
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#### 2. 包管理
- **初始化**：`init()` 函数在包导入时自动执行。
- **依赖**：Go Modules 管理版本（`go.mod`）
```go
// main.go
package main

import (
    "fmt"
    "./mypackage"
)

func main() {
    mypackage.PrintMessage()
}

// mypackage/mypackage.go
package mypackage

import "fmt"

func init() {
    fmt.Println("Initializing mypackage")
}

func PrintMessage() {
    fmt.Println("Hello from mypackage")
}
</code></pre></div></div>

<h4 id="3-性能优化技巧">3. 性能优化技巧</h4>
<ul>
  <li><strong>内存复用</strong>：使用 <code class="language-plaintext highlighter-rouge">sync.Pool</code> 减少对象分配（如 <code class="language-plaintext highlighter-rouge">fasthttp</code> 复用 RequestCtx）。
```go
package main</li>
</ul>

<p>import (
    “fmt”
    “sync”
)</p>

<p>type MyObject struct {
    Data []int
}</p>

<p>var objectPool = sync.Pool{
    New: func() interface{} {
        return &amp;MyObject{Data: make([]int, 0, 100)}
    },
}</p>

<p>func main() {
    obj := objectPool.Get().(*MyObject)
    defer objectPool.Put(obj)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>obj.Data = append(obj.Data, 1, 2, 3)
fmt.Println(obj.Data) } ``` - **高效数据结构**：优先用 `[]byte` 替代 `string`（避免不可变性带来的内存复制）。 ```go package main
</code></pre></div></div>

<p>import (
    “fmt”
)</p>

<p>func main() {
    // 使用 []byte
    byteSlice := []byte(“Hello”)
    byteSlice = append(byteSlice, ‘ ‘, ‘W’, ‘o’, ‘r’, ‘l’, ‘d’)
    fmt.Println(string(byteSlice))
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#### 4. 常用命令
- `go build`：编译项目
- `go run`：编译并运行
- `go get`：安装依赖
- `go test`：执行测试
- `go mod init`：初始化模块管理

这些命令通常在终端中使用，例如：
```bash
# 初始化模块管理
go mod init myproject
# 安装依赖
go get github.com/some/package
# 编译项目
go build
# 编译并运行
go run main.go
# 执行测试
go test
</code></pre></div></div>

  </div><a class="u-url" href="/blog/golang/2025/06/03/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name"></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
